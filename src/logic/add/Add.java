package logic.add;

import logic.*;
import storage.*;
import common.*;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.util.ArrayList;
import java.time.DateTimeException;
import java.time.LocalDateTime;
import java.util.logging.*;
import java.io.File;

import common.TaskObject;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

/**
 * Creates an "Add" object to facilitate adding of a task into Adult
 * TaskFinder's TaskList. Tasks will be added internally before being saved to
 * its default file location. <br>
 * Events to be added will be checked against all existing events - the names of
 * clashing events will be generated in the output list, but the user will not
 * be stopped from adding the event. <br>
 * Deadlines to be added will be checked if it is already overdue - overdue
 * deadlines will have their status toggled to "overdue" before being added.
 * 
 * @author ChongYan, RuiBin
 *
 */
public class Add {

	private TaskObject task;
	private int index;
	private boolean addedInternal = false;
	private boolean addedExternal = false;
	private boolean isClash = false;
	private ArrayList<TaskObject> taskList;
	private ArrayList<String> output = new ArrayList<String>();
	private ArrayList<TaskObject> clashedTasks = new ArrayList<TaskObject>();

	private boolean isEvent = false;
	private boolean isDeadline = false;
	private boolean isFloating = false;

	private static Logger logger = Logger.getLogger(Add.class.getName());

	public Add() {

	}

	/**
	 * Normal constructor for Add
	 * 
	 * @param taskObj
	 *            The task to be added, generated by parser.
	 * @param index
	 *            The position within the task list to add the task. Optional,
	 *            default value 0.
	 * @param taskList
	 *            The list of tasks maintained internally by Adult TaskFinder
	 */
	public Add(TaskObject taskObj, int index, ArrayList<TaskObject> taskList) {
		this.task = taskObj;
		this.index = index;
		this.taskList = taskList;
	}

	public void setUpLogger() {
		try {
			File fakeFile = new File("");
			String filePath = fakeFile.getAbsolutePath();
			FileHandler fileHandler = new FileHandler(filePath + "/src/logic/add/" + "addLog.txt");
			logger.addHandler(fileHandler);
			SimpleFormatter formatter = new SimpleFormatter();
			fileHandler.setFormatter(formatter);
			logger.setUseParentHandlers(false);

			logger.log(Level.INFO, "First log, going to start processing for adding");
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Called by logic to add the task initialised in the Add object to the task
	 * list.
	 * 
	 * @return output: ArrayList<String> - Contains all the output that the user
	 *         will see
	 */
	public ArrayList<String> run() {
		// Special processing to handle undoing the deletion of an occurrence of a recurring task
		if (task.getIsContainingOnlyTaskDateTimes()) {
			addSingleOccurrence(task.getTaskDateTimes());
		} else {
			assert (!task.getTitle().equals(""));
			setUpLogger();
			try {
				determineTaskCategory();
				processTaskInformation();
				addTask();
				createOutput();
			} catch (DateTimeException e) {
				output.add(MESSAGE_FAIL + MESSAGE_INVALID_TIME);
				logger.log(Level.WARNING, "date within input task is invalid");
			} catch (NullPointerException e) {
				e.printStackTrace();
				output.add(MESSAGE_FAIL + MESSAGE_NULL_POINTER);
				logger.log(Level.WARNING, "tried to retrieve an unavailable object");
			} catch (Exception e) {
				e.printStackTrace();
				output.add(MESSAGE_FAIL);
				logger.log(Level.WARNING, "task does not have a valid category");
			}
		}
		return output;
	}

	private void determineTaskCategory() {
		if (task.getCategory().equals(CATEGORY_EVENT)) {
			this.isEvent = true;
		}
		if (task.getCategory().equals(CATEGORY_DEADLINE)) {
			this.isDeadline = true;
		}
		if (task.getCategory().equals(CATEGORY_FLOATING)) {
			this.isFloating = true;
		}
	}

	/**
	 * Control flow to determine adding process for each type of task
	 * @throws Exception
	 */
	private void processTaskInformation() throws Exception {
		if (isEvent) {
			assert (!task.getStartDateTime().equals(LocalDateTime.MAX));
			assert (!task.getEndDateTime().equals(LocalDateTime.MAX));
			logger.log(Level.INFO, "event to be added");
			processEventDetails();
		}
		if (isDeadline) {
			assert (!task.getStartDateTime().equals(LocalDateTime.MAX));
			assert (task.getEndDateTime().equals(LocalDateTime.MAX));
			logger.log(Level.INFO, "deadline to be added");
			processDeadlineDetails();
		}
		if (isFloating) {
			assert (task.getStartDateTime().equals(LocalDateTime.MAX));
			assert (task.getEndDateTime().equals(LocalDateTime.MAX));
			logger.log(Level.INFO, "floating to be added");
		}
		if (!isEvent && !isDeadline && !isFloating) {
			Exception e = new Exception("Invalid task");
			throw e;
		}
	}

	/*****************************************************************************/
	/**
	 * Checks for clashes between events (including recurrent times) and adds to taskList
	 * Also creates all dates and times for recurrent tasks
	 */
	private void processEventDetails() {
		copyToTaskDateTimeList(task.getStartDateTime(), task.getEndDateTime());
		if (task.getIsRecurring()) {
			addRecurringEventTimes(task);
		}
		checkIfEventsClash();
	}

	/**
	 * Copies startDateTime and endDateTime to taskDateTimes
	 * @param startDateTime
	 * @param endDateTime
	 */
	private void copyToTaskDateTimeList(LocalDateTime startDateTime, LocalDateTime endDateTime) {
		LocalDateTimePair pair = new LocalDateTimePair(startDateTime, endDateTime);
		task.addToTaskDateTimes(pair);
	}

	private void addRecurringEventTimes(TaskObject task) {
		Recurring.setAllRecurringEventTimes(task);
	}
	
	/***********************************************************************************/
	/**
	 *  Checks if a deadline is overdue, modifies status if necessary, adds to taskList
	 */
	private void processDeadlineDetails() {
		boolean isOverdue = checkIfOverdue();
		copyToTaskDateTimeList(task.getStartDateTime(), task.getEndDateTime());
		if (task.getIsRecurring()) {
			addRecurringDeadlineTimes(task);
		}
		if (isOverdue) {
			setTaskStatus(isOverdue);
			if (task.getIsRecurring()) {
				Recurring.updateDeadline(task);
			}
		}
	}
	
	private void addRecurringDeadlineTimes(TaskObject task) {
		Recurring.setAllRecurringDeadlineTimes(task);
	}

	/**
	 * Throws Exception if time input is invalid. Deadline to be added has a
	 * valid date and time in its TaskObject <br>
	 * Converts date and time to the LocalDateTime format by calling static
	 * method in Logic class.
	 * 
	 * @return isOverdue: boolean - True if deadline is before current time
	 */
	private boolean checkIfOverdue() throws DateTimeException {
		boolean isOverdue = false;
		// LocalDateTime deadline = task.getStartDateTime();

		logger.log(Level.INFO, "going to check whether a deadline is overdue");

		if (task.getStartDateTime().isBefore(LocalDateTime.now())) {
			isOverdue = true;
		}
		return isOverdue;
	}

	private void setTaskStatus(boolean isOverdue) {
		if (isOverdue) {
			task.setStatus("overdue");
		}
		logger.log(Level.INFO, "toggled a task's status if applicable");
	}

	/*********************************************************************************/
	/**
	 * Group of functions checking for clashes between events.
	 */
	
	private void checkIfEventsClash() throws NullPointerException {
		if (task.getStartDateTime().isAfter(task.getEndDateTime())) {
			DateTimeException e = new DateTimeException("Start Date Time after End Date Time");
			throw e;
		}
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getCategory().equals("event")) {
				checkAllExistingTimes(taskList.get(i));
			}
		}
		logger.log(Level.INFO, "checked if events clash");
	}

	private void checkAllExistingTimes(TaskObject current) throws NullPointerException {
		ArrayList<LocalDateTimePair> currentTaskDateTimes = current.getTaskDateTimes();
		ArrayList<LocalDateTimePair> newTaskDateTimes = task.getTaskDateTimes();

		for (int i = 0; i < currentTaskDateTimes.size(); i++) {
			for (int j = 0; j < newTaskDateTimes.size(); j++) {
				processIndividualClashes(i, j, currentTaskDateTimes, newTaskDateTimes, current);
			}
		}
	}

	private void processIndividualClashes(int currentIndex, int newIndex,
			ArrayList<LocalDateTimePair> currentTaskDateTimes, ArrayList<LocalDateTimePair> newTaskDateTimes, 
			TaskObject current) {
		
		LocalDateTime currentStart = currentTaskDateTimes.get(currentIndex).getStartDateTime();
		LocalDateTime currentEnd = currentTaskDateTimes.get(currentIndex).getEndDateTime();
		LocalDateTime newStart = newTaskDateTimes.get(newIndex).getStartDateTime();
		LocalDateTime newEnd = newTaskDateTimes.get(newIndex).getEndDateTime();
		
		if (checkIndividualTimeClash(currentStart, currentEnd, newStart, newEnd)) {
			this.isClash = true;
			addToClashedTasks(current);
			logger.log(Level.INFO, "detected a clash between non-recurring tasks");
		}
	}

	/**
	 * LocalDateTime format obtained by calling static method in Logic class
	 * Checks if two events clash. Achieves this by: <br>
	 * 1) Checking if event 1's start time is between event 2's start and end
	 * time <br>
	 * 2) Checking if event 1's end time is between event 2's start and end time
	 * <br>
	 * 3) Checking if event 2's start time is between event 1's start and end
	 * time <br>
	 * 4) Checking if event 2's end time is between event 1's start and end time
	 * 
	 * @param current
	 *            The TaskObject passed into the function from the task list.
	 * @return
	 */
	private boolean checkIndividualTimeClash(LocalDateTime currentStart, LocalDateTime currentEnd, 
			LocalDateTime newStart, LocalDateTime newEnd) throws DateTimeException {

		if (currentStart.isAfter(newStart) || currentStart.isEqual(newStart)) {
			if (currentStart.isBefore(newEnd) || currentStart.isEqual(newEnd)) {
				return true;
			}
		}
		if (currentEnd.isAfter(newStart) || currentEnd.isEqual(newStart)) {
			if (currentEnd.isBefore(newEnd) || currentEnd.isEqual(newEnd)) {
				return true;
			}
		}
		if (newStart.isAfter(currentStart) || newStart.isEqual(currentStart)) {
			if (newStart.isBefore(currentEnd) || newStart.isEqual(currentEnd)) {
				return true;
			}
		}
		if (newEnd.isAfter(currentStart) || newEnd.isEqual(currentStart)) {
			if (newEnd.isBefore(currentEnd) || newEnd.isEqual(currentEnd)) {
				return true;
			}
		}

		logger.log(Level.INFO, "no clash detected between two timings");

		return false;
	}

	/********************************************************************************/
	/**
	 * Group of functions for addition of task
	 */
	
	private void addSingleOccurrence(ArrayList<LocalDateTimePair> dateTimePair) {
		assert (dateTimePair.size() == 1);
		
		LocalDateTimePair occurrenceDetails = dateTimePair.get(0);
		ArrayList<LocalDateTimePair> allOccurrencesDetails = taskList.get(index-1).getTaskDateTimes();
		allOccurrencesDetails.add(0, occurrenceDetails); // adds it back to the front of the recurrence list
	}
	
	private void addTask() {
		addInternal();
		addExternal();
		logger.log(Level.INFO, "added tasks to the taskList");
	}

	private void addInternal() throws NullPointerException {
		int originalSize = taskList.size();
		int newSize = originalSize + 1;
		if (index != -1) { // must add at a specific point
			taskList.add(index - 1, task);
		} else {
			taskList.add(task);
		}

		if (taskList.size() == newSize) {
			addedInternal = true;
			logger.log(Level.INFO, "added task to internal taskList");
		} else {
			logger.log(Level.WARNING, "failed to add task");
		}
	}

	private void addExternal() {
		IStorage storage = FileStorage.getInstance();
		try {
			storage.save(taskList);
			logger.log(Level.INFO, "added task to external file storage");
		} catch (NoSuchFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			logger.log(Level.WARNING, "did not manage to add task externally, invalid file");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			logger.log(Level.WARNING, "did not manage to add task externally, IO exception");
		}
		addedExternal = true;

	}
	/****************************************************************************/
	/**
	 * Group of functions for creating output.
	 */

	private void createOutput() {
		if (addedInternal && addedExternal) {
			String title = task.getTitle();
			String text = MESSAGE_ADD.concat(title);
			output.add(text);
			if (isClash) {
				for (int i = 0; i < clashedTasks.size(); i++) {
					String clashMessage = createClashOutput(i);
					output.add(clashMessage);
				}
			}
			logger.log(Level.INFO, "output created successfully");
		} else {
			output.add(MESSAGE_FAIL);
			logger.log(Level.WARNING, "task was not added, failure output created");
		}
	}

	private String createClashOutput(int i) {
		String text = "";
		text = String.format(MESSAGE_CLASH, task.getTitle(), clashedTasks.get(i).getTitle());
		// NEED A BETTER WAY TO OUTPUT CLASHES
		return text;
	}
	/***************************************************************************/
	
	private void addToClashedTasks(TaskObject current) {
		boolean canAdd = true;
		for (int i = 0; i < clashedTasks.size(); i++) {
			if (clashedTasks.get(i).getTaskId() == current.getTaskId()) {
				canAdd = false;
			}
		}
		if (canAdd) {
			clashedTasks.add(current);
		}
	}

	// GETTERS, SETTERS
	public ArrayList<String> getOutput() {
		return output;
	}

	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}

	public TaskObject getTask() {
		return task;
	}
	
	public boolean getIsClash() {
		return isClash;
	}
	
	public ArrayList<TaskObject> getClashedTasks() {
		return clashedTasks;
	}

	public void setOutput(ArrayList<String> output) {
		this.output = output;
	}

	public void setTaskList(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}

	public void setTask(TaskObject task) {
		this.task = task;
	}
}
