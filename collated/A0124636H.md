# A0124636H
###### \src\common\CommandObject.java
``` java

package common;

public class CommandObject {
	
	private int commandType;
	private TaskObject taskObj;
	private int index = -1;
	private int lastSearchedIndex = -1;
	
	public CommandObject() {
	}
	
	public CommandObject(int commandType, TaskObject taskObj) {
		this.commandType = commandType;
		this.taskObj = taskObj;
	}
	
	public CommandObject(int commandType, TaskObject taskObj, int index) {
		this.commandType = commandType;
		this.taskObj = taskObj;
		this.index = index;
	}
	
	public CommandObject(int commandType, TaskObject taskObj, int index, int lastSearchedIndex) {
		this.commandType = commandType;
		this.taskObj = taskObj;
		this.index = index;
		this.lastSearchedIndex = lastSearchedIndex;
	}
	
	public int getCommandType() {
		return commandType;
	}
	
	public TaskObject getTaskObject() {
		return taskObj;
	}
	
	public int getIndex() {
		return index;
	}

	public int getLastSearchedIndex() {
		return lastSearchedIndex;
	}

	public void setCommandType(int newCommandType) {
		this.commandType = newCommandType;
	}
	
	public void setTaskObject(TaskObject newTaskObject) {
		this.taskObj = newTaskObject;
	}

	public void setIndex(int index) {
		this.index = index;
	}
	
	public void setLastSearchedIndex(int lastSearchedIndex) {
		this.lastSearchedIndex = lastSearchedIndex;
	}

}
```
###### \src\common\TaskObject.java
``` java

package common;

import java.time.LocalDateTime;
import java.time.DateTimeException;
import java.util.ArrayList;

/**
 * The TaskObject class contains all pertinent information regarding a task. The main attributes are: <br>
 * 1. Title <br>
 * 2. Start date/time <br>
 * 3. End date/time <br>
 * 4. Category <br>
 * 5. Status <br>
 * 6. Task ID <br>
 * 7. Interval object (for recurring tasks) <br>
 * 8. ArrayList of multiple dates and times (for recurring tasks) <br>
 * 
 * @author RuiBin
 *
 */

public class TaskObject implements Comparable<TaskObject> {

	protected String title = "";
	protected LocalDateTime startDateTime = LocalDateTime.MAX;
	protected LocalDateTime endDateTime = LocalDateTime.MAX;
	protected String category = ""; // deadline, event, or floating
	protected String status = ""; // completed, overdue or incomplete
	protected int taskId = -1;
	protected String timeOutputString = ""; // stores date time in the desired output for GUI
	protected Interval interval = new Interval();
	// stores all occurrences of a task
	protected ArrayList<LocalDateTimePair> taskDateTimes = new ArrayList<LocalDateTimePair>();
	protected boolean isRecurring;
	// stores all occurrences that has been deleted (if any)
	protected ArrayList<LocalDateTimePair> deletedTaskDateTimes = new ArrayList<LocalDateTimePair>();

	// Checks to facilitate undo processes
	protected boolean isEditAll = false;
	protected boolean isContainingOnlyTaskDateTimes = false;

	// ------------------------------------ CONSTRUCTORS ------------------------------------

	// Constructor for recurring event tasks
	public TaskObject(String title, LocalDateTime startDateTime, LocalDateTime endDateTime, String category,
			String status, int taskId, boolean isRecurring, ArrayList<LocalDateTimePair> taskDateTimes) {
		this.title = title;
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
		this.category = category;
		this.status = status;
		this.taskId = taskId;
		this.isRecurring = isRecurring;
		this.taskDateTimes = taskDateTimes;
	}

	// Constructor for event tasks
	public TaskObject(String title, LocalDateTime startDateTime, LocalDateTime endDateTime, String category,
			String status, int taskId) {
		this.title = title;
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
		this.category = category;
		this.status = status;
		this.taskId = taskId;
	}

	// Constructor for recurring deadline tasks
	public TaskObject(String title, LocalDateTime startDateTime, String category, String status, int taskId,
			boolean isRecurring, ArrayList<LocalDateTimePair> taskDateTimes) {
		this.title = title;
		this.startDateTime = startDateTime;
		this.endDateTime = LocalDateTime.MAX;
		this.category = category;
		this.status = status;
		this.taskId = taskId;
		this.isRecurring = isRecurring;
		this.taskDateTimes = taskDateTimes;
	}

	// Constructor for deadline tasks
	public TaskObject(String title, LocalDateTime startDateTime, String category, String status, int taskId) {
		this.title = title;
		this.startDateTime = startDateTime;
		this.endDateTime = LocalDateTime.MAX;
		this.category = category;
		this.status = status;
		this.taskId = taskId;
	}

	// Constructor for floating tasks
	public TaskObject(String title, String category, String status, int taskId) {
		this.title = title;
		this.startDateTime = LocalDateTime.MAX;
		this.endDateTime = LocalDateTime.MAX;
		this.category = category;
		this.status = status;
		this.taskId = taskId;
	}

	// Constructor for processing undo of edit tasks
	public TaskObject(String title, LocalDateTime startDateTime, LocalDateTime endDateTime,
			Interval interval) {
		this.title = title;
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
		this.interval = interval;
	}
	
	// Constructor for deleting all for recurring tasks
	public TaskObject(String title) {
		this.title = title;
	}

	// Constructor for dummyTask in searchByIndex
	public TaskObject(LocalDateTime startDateTime, LocalDateTime endDateTime, Interval interval) {
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
		this.interval = interval;
	}

	// Constructor for undoing the deletion of one occurrence of a recurring task
	public TaskObject(LocalDateTimePair dateTimePair) {
		this.taskDateTimes.add(dateTimePair);
		this.isContainingOnlyTaskDateTimes = true;
	}

	// Constructor for undoing an addition of a recurring task
	public TaskObject(boolean bool) {
		this.isEditAll = bool;
	}
	
	// Constructor for AddTest
	public TaskObject(String title, int taskId) {
		this.title = title;
		this.taskId = taskId;
	}

	// Constructor for SearchTest - search-by-date for deadline
	public TaskObject(LocalDateTime dateTime) {
		this.startDateTime = dateTime;
	}

	// Empty constructor
	public TaskObject() {

	}

	// ------------------------------------ USEFUL METHODS ------------------------------------

	public void addToTaskDateTimes() {
		taskDateTimes.add(new LocalDateTimePair(startDateTime, endDateTime));
	}
	
	public void addToTaskDateTimes(LocalDateTimePair pair) {
		this.taskDateTimes.add(pair);
	}
	
	public void addToTaskDateTimes(int index, LocalDateTimePair pair) {
		this.taskDateTimes.add(index, pair);
	}

	public void removeFromTaskDateTimes(int index) {
		this.taskDateTimes.remove(index);
	}

	public void removeAllDateTimes() {
		this.taskDateTimes.clear();
	}

	public void updateStartAndEndDateTimes() {
		this.startDateTime = taskDateTimes.get(0).getStartDateTime();
		this.endDateTime = taskDateTimes.get(0).getEndDateTime();
	}

	// Updates the first occurrence in the taskDateTimes array
	public void updateTaskDateTimesArray() {
		if (taskDateTimes.isEmpty()) {
			addToTaskDateTimes();
		} else {
			taskDateTimes.set(0, new LocalDateTimePair(startDateTime, endDateTime));
		}
	}
	
	public void addToDeletedTaskDateTimes(LocalDateTimePair deletedOccurrence) {
		this.deletedTaskDateTimes.add(deletedOccurrence);
	}

	// Checks if title, dates and times are invalid values
	public boolean isSearchKeywordPresent() {
		return (!this.title.equals("") || !this.startDateTime.equals(LocalDateTime.MAX)
				|| !this.category.equals("") || !this.status.equals(""));
	}
	
	public boolean isInfiniteRecurrence() {
		return (this.interval.getCount() == -1 && this.interval.getUntil().equals(LocalDateTime.MAX));
	}

	public boolean isNull() {
		return (title.equals("") && startDateTime.equals(LocalDateTime.MAX)
				&& endDateTime.equals(LocalDateTime.MAX) && category.equals("") && status.equals("")
				&& taskId == -1 && timeOutputString.equals(""));
	}
	
	// for testing purpose
	public void resetAttributes() {
		setTitle("");
		setStartDateTime(LocalDateTime.MAX);
		setEndDateTime(LocalDateTime.MAX);
	}

	@Override
	public int compareTo(TaskObject task) {
		// TODO Auto-generated method stub
		return 0;
	}

	// ------------------------------------ GETTERS/SETTERS ------------------------------------

	public String getTitle() {
		return title;
	}

	public LocalDateTime getStartDateTime() {
		return startDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public String getCategory() {
		return category;
	}

	public String getStatus() {
		return status;
	}

	public int getTaskId() {
		return taskId;
	}

	public String getTimeOutputString() {
		return timeOutputString;
	}

	public Interval getInterval() {
		return interval;
	}

	public boolean getIsRecurring() {
		return isRecurring;
	}

	public boolean getIsContainingOnlyTaskDateTimes() {
		return isContainingOnlyTaskDateTimes;
	}

	public boolean getIsEditAll() {
		return isEditAll;
	}

	public ArrayList<LocalDateTimePair> getTaskDateTimes() {
		return taskDateTimes;
	}

	public ArrayList<LocalDateTimePair> getDeletedTaskDateTimes() {
		return deletedTaskDateTimes;
	}

	public void setTitle(String newTitle) {
		this.title = newTitle;
	}

	public void setStartDateTime(LocalDateTime newStartDateTime) throws DateTimeException {
		this.startDateTime = newStartDateTime;
	}

	public void setEndDateTime(LocalDateTime newEndDateTime) throws DateTimeException {
		this.endDateTime = newEndDateTime;
	}

	public void setCategory(String newCategory) {
		this.category = newCategory;
	}

	public void setStatus(String newStatus) {
		this.status = newStatus;
	}

	public void setTaskId(int newTaskId) {
		this.taskId = newTaskId;
	}

	public void setTimeOutputString(String newTimeOutput) {
		this.timeOutputString = newTimeOutput;
	}

	public void setInterval(Interval interval) {
		this.interval = interval;
	}

	public void setIsRecurring(boolean isRecurring) {
		this.isRecurring = isRecurring;
	}

	public void setIsEditAll(boolean isEditAll) {
		this.isEditAll = isEditAll;
	}

	public void setTaskDateTimes(ArrayList<LocalDateTimePair> newTaskDateTimes) {
		this.taskDateTimes = newTaskDateTimes;
	}

	// Essentially creates a copy of the task object that is passed into this method
	public void setTaskObject(TaskObject task) {
		this.title = task.getTitle();
		this.startDateTime = task.getStartDateTime();
		this.endDateTime = task.getEndDateTime();
		this.category = task.getCategory();
		this.status = task.getStatus();
		this.taskId = task.getTaskId();
		this.timeOutputString = task.getTimeOutputString();
		this.isRecurring = task.getIsRecurring();
		this.interval = task.getInterval();
		this.taskDateTimes = task.getTaskDateTimes();
		this.isEditAll = task.getIsEditAll();
		this.isContainingOnlyTaskDateTimes = task.getIsContainingOnlyTaskDateTimes();
		
	}

}
```
###### \src\logic\add\Add.java
``` java

	// For processing undo of deletion of a single occurrence
	private void addSingleOccurrence() {
		ArrayList<LocalDateTimePair> timings = task.getTaskDateTimes();
		assert (timings.size() == 1); // it should only store 1 occurrence of
										// timings
		assert (lastSearchedIndex != -1);

		LocalDateTimePair occurrenceToBeAdded = timings.get(0);
		TaskObject taskToBeModified = taskList.get(lastSearchedIndex - 1);
		taskToBeModified.getTaskDateTimes().add(index - 1, occurrenceToBeAdded);

		// updates the startDateTime and endDateTime to that of the occurrence
		// that has been added back
		taskToBeModified.updateStartAndEndDateTimes();
		isAddSingleOccurrence = true;

	}

```
###### \src\logic\CommandFacade.java
``` java

package logic;

import common.*;
import logic.add.Add;
import logic.delete.Delete;
import logic.display.Display;
import logic.edit.Edit;
import logic.help.Help;
import logic.load.Load;
import logic.mark.Done;
import logic.mark.Incomplete;
import logic.mark.Mark;
import logic.mark.Overdue;
import logic.save.Save;
import logic.search.Search;
import logic.sort.Sort;
import logic.undoredo.UndoRedo;
import static logic.constants.Index.*;
import static logic.constants.Strings.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Deque;

import com.sun.media.jfxmedia.logging.Logger;

/**
 * This class represents a facade pattern to parse the CommandObject that has been returned by the parser. A
 * new CommandFacade class is initialised with each new user input, and all relevant arguments are passed to
 * this class. The variables that will be actually used depends on the input of the user.
 * 
 * @author RuiBin, ChongYan
 *
 */

public class CommandFacade {

	private ArrayList<TaskObject> taskList;
	private Deque<CommandObject> undoList;
	private Deque<CommandObject> redoList;
	private ArrayList<TaskObject> lastOutputTaskList;
	private ArrayList<String> output;
	private ArrayList<String> taskDateTimeOutput;

	private CommandObject commandObj;
	private int commandType;
	private TaskObject taskObj;
	private int index;
	private int sortedIndex = -1; // stores the index of the task after sorting
	private int lastSearchedIndex; // stores the index of the last recurring task searched

	private int lastCompletedTaskId; // stores task id of task most recently marked completed

	boolean isUndoAction;
	boolean isRedoAction;

	/**
	 * Constructor called by Logic which passes all arguments that might be used
	 * 
	 * @param taskList
	 *            The default taskList storing all the tasks
	 * @param undoList
	 *            The deque of CommandObjects which stores all undo actions
	 * @param redoList
	 *            The deque of CommandObjects which stores all redo actions
	 * @param lastOutputTaskList
	 *            The ArrayList which keeps track of what is currently being displayed to the user
	 * @param commandObj
	 *            The CommandObject returned by the Parser class which returns the processed information
	 * @param isUndoAction
	 *            Tracks if this call is an undo action
	 * @param isRedoAction
	 *            Tracks if this call is an undo action
	 */
	public CommandFacade(ArrayList<TaskObject> taskList, Deque<CommandObject> undoList,
			Deque<CommandObject> redoList, ArrayList<TaskObject> lastOutputTaskList, CommandObject commandObj,
			boolean isUndoAction, boolean isRedoAction) {
		this.taskList = taskList;
		this.undoList = undoList;
		this.redoList = redoList;
		this.lastOutputTaskList = lastOutputTaskList;
		this.commandObj = commandObj;
		this.isUndoAction = isUndoAction;
		this.isRedoAction = isRedoAction;
		setCommandObjectValues();
	}

	/**
	 * The run method is called by Logic after each initialisation of the CommandFacade class. It parses the
	 * command type and calls the appropriate function. Responsible for manipulating the undoList and
	 * determining whether the redoList should be cleared. <br>
	 * The redoList will be cleared as long as the command given is not an undo or redo. <br>
	 * A "reverse" CommandObject will be created and pushed into the undoList if the current CommandObject is
	 * an action which manipulates the existing task list.
	 */
	public void run() {

		//printTaskObjectFields(taskObj); // FOR DEBUGGING

		// Clears the redo stack if it is a new command which modifies the task list
		if (!redoList.isEmpty() && isListOperation(commandType) && !isUndoAction && !isRedoAction) {
			redoList.clear();
		}

		switch (commandType) {
			case INDEX_ADD:
				addFunction();
				break;
			case INDEX_SEARCH_DISPLAY:
				checkDisplayOrSearch();
				break;
			case INDEX_EDIT:
				editFunction();
				break;
			case INDEX_DELETE:
				deleteFunction();
				break;
			case INDEX_UNDO:
			case INDEX_REDO:
				undoRedoFunction();
				break;
			case INDEX_SAVE:
				saveFunction();
				break;
			case INDEX_EXIT:
				exitFunction();
				break;
			case INDEX_HELP:
				helpFunction();
				break;
			case INDEX_COMPLETE:
				doneFunction();
				break;
			case INDEX_INCOMPLETE:
				incompleteFunction();
				break;
			case INDEX_LOAD:
				loadFunction();
				break;
			default:
				printInvalidCommandMessage();
				break;
		}

		// method which filters lastOutputTaskList to hide completed tasks
		filterLastOutputTaskList();
		
	}

	// ----------------------- FUNCTIONS -------------------------

	/**
	 * Calls Add function, which adds the task to the task list and writes it to storage. It then adds the
	 * reverse CommandObject to the undo list or the redo list.
	 */
	private void addFunction() {
		Add add = new Add(taskObj, index, lastSearchedIndex, taskList);
		setOutput(add.run());
		setLastOutputTaskList(taskList);
		boolean isAddSingleOccurrence = add.getIsAddSingleOccurrence();
		boolean isExceptionThrown = add.getIsExceptionThrown();
		sortFunction();

		if (!isExceptionThrown) {
			if (isUndoAction) {
				addToList(commandObj, isAddSingleOccurrence, redoList);
			} else {
				addToList(commandObj, isAddSingleOccurrence, undoList);
			}
		}
		setLastSearchedIndex(-1);
	}

	// This method checks for the presence of a search keyword in TaskObject. If there is a keyword, search
	// function will be called. If there is no keyword, display function will be called.
	private void checkDisplayOrSearch() {
		if (taskObj.isSearchKeywordPresent() || commandObj.getIndex() != -1) {
			searchFunction();
		} else {
			displayFunction();
		}
	}

	/**
	 * Calls Search function which outputs only the tasks that match the search keyword.
	 */
	private void searchFunction() {
		Search search = new Search(commandObj, taskList, lastOutputTaskList);
		setOutput(search.run());
		setLastOutputTaskList(search.getLastOutputTaskList());
		setLastSearchedIndex(search.getSearchIndex());
		setTaskDateTimeOutput(search.getTaskDateTimeOutput());
	}

	// Called after delete/edit of an occurrence so that the sidebar remains open and is updated
	private void searchFunction(CommandObject cmdObjToRunSearchByIndex) {
		Search search = new Search(cmdObjToRunSearchByIndex, taskList, lastOutputTaskList);
		search.run();
		setLastSearchedIndex(search.getSearchIndex());
		setTaskDateTimeOutput(search.getTaskDateTimeOutput());
	}

	/**
	 * Calls Display function which outputs the entire task list.
	 */
	private void displayFunction() {
		Display display = new Display(taskList);
		setOutput(display.run());
		setLastOutputTaskList(display.getLastOutputTaskList());
		setLastSearchedIndex(-1);
	}

	/**
	 * Calls Edit function which edits the task title, date, or both. It then adds the reverse CommandObject
	 * to the undo list or the redo list.
	 */
	private void editFunction() {
		Edit edit = new Edit(commandObj, lastOutputTaskList, taskList, lastSearchedIndex);
		setOutput(edit.run());
		Incomplete.markAllIncompleteTasks(taskList);
		Overdue.markAllOverdueTasks(taskList);
		setLastOutputTaskList(taskList);
		boolean isExceptionThrown = edit.getIsExceptionThrown();
		sortFunction();
		
		// if it was a single occurrence that was edited, call search-by-index to update the sidebar
		callSearchByIndexToUpdateSidebar(edit.getIsEditSingleOccurrence());

		if (!isExceptionThrown) {
			if (isUndoAction) {
				addToList(edit, redoList);
			} else {
				addToList(edit, undoList);
			}
		}
	}

	/**
	 * The method checks if there is a task specified in the Delete command. If there is no task specified,
	 * quick delete is run, i.e. deletes the most recently added task. If there is a task specified, normal
	 * delete is run to remove the specified task.
	 */
	private void deleteFunction() {
		// 4 things to track
		TaskObject removedTask = new TaskObject();
		LocalDateTimePair removedOccurrenceTiming = new LocalDateTimePair(); // for single occurrence delete
		Integer removedOccurrenceIndex = Integer.valueOf(-1);
		Boolean isDeleteAll = false;

		Delete delete = new Delete(commandObj, taskList, lastOutputTaskList, undoList, redoList);
		setOutput(delete.run());
		setTaskList(delete.getTaskList());
		setLastOutputTaskList(this.taskList);
		setUndoList(delete.getUndoList());
		setRedoList(delete.getRedoList());

		// if it was a single occurrence that was edited, call search-by-index to update the sidebar
		callSearchByIndexToUpdateSidebar(delete.getIsDeleteSingleOccurrence());

		removedTask = delete.getRemovedTask();
		removedOccurrenceTiming = delete.getRemovedTaskOccurrenceDetails();
		removedOccurrenceIndex = delete.getRemovedOccurrenceIndex();
		isDeleteAll = delete.getIsDeleteAll();
		boolean isExceptionThrown = delete.getIsExceptionThrown();
		
		sortFunction();
		if (!isDeleteAll && !isExceptionThrown) {
			processUndoForDelete(removedTask, removedOccurrenceTiming, removedOccurrenceIndex);
		}
	}

	// Checks that removedTask is not null, then adds the corresponding CommandObject to the undo/redo list
	private void processUndoForDelete(TaskObject removedTask, LocalDateTimePair removedOccurrenceTiming,
			Integer removedOccurrenceIndex) {
		assert (!removedTask.isNull());

		if (isUndoAction) {
			addToList(removedTask, removedOccurrenceTiming, removedOccurrenceIndex, redoList);
		} else {
			addToList(removedTask, removedOccurrenceTiming, removedOccurrenceIndex, undoList);
		}
	}

	/**
	 * Calls the UndoRedo class, which is a parent of the Undo and Redo classes. The class reads in the
	 * command type and then calls the relevant child class.
	 */
	private void undoRedoFunction() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		setOutput(undoRedo.run(commandType));

		// Update the lists
		setTaskList(undoRedo.getTaskList());
		setUndoList(undoRedo.getUndoList());
		setRedoList(undoRedo.getRedoList());
		setLastOutputTaskList(this.taskList);
	}

	/**
	 * Calls the Save function, which saves the task list to an appropriate storage place.
	 */
	private void saveFunction() {
		Save save = new Save(taskObj, taskList);
		setOutput(save.run());
		setLastSearchedIndex(-1);
	}

	/**
	 * Calls the Exit function, which exits the program.
	 */
	private void exitFunction() {
		Exit exit = new Exit(taskList);
		exit.run();
	}

	/**
	 * Calls the Help function, which displays the user guide. If there is a search keyword entered, only the
	 * relevant topics will be displayed. If there is no search keyword entered, the entire user guide will be
	 * displayed.
	 */
	private void helpFunction() {
		String helpSearchKey = taskObj.getTitle();
		Help help = new Help(helpSearchKey);
		setOutput(help.run());
		setLastSearchedIndex(-1);
	}

	/**
	 * Calls the Done function, which marks a specified task as completed.
	 */
	private void doneFunction() {
		Done done = new Done(commandObj, taskList, lastOutputTaskList);
		setOutput(done.run());
		setLastOutputTaskList(taskList);
		sortFunction();
		setLastSearchedIndex(-1);
		boolean isExceptionThrown = done.getIsExceptionThrown();
		
		if (!isExceptionThrown && done.getTaskIdToMark() != -1) { // If successfully marked as done
			if (isUndoAction) {
				addToList(done, redoList);
			} else {
				addToList(done, undoList);
			}
		}

		lastCompletedTaskId = done.getMostRecentlyMarkedTaskId();
	}

	/**
	 * Calls the Incomplete function, which marks a specified task as incomplete.
	 */
	private void incompleteFunction() {
		Incomplete incomplete = new Incomplete(commandObj, taskList, lastOutputTaskList);
		setOutput(incomplete.run());
		setLastOutputTaskList(taskList);
		sortFunction();
		setLastSearchedIndex(-1);
		boolean isExceptionThrown = incomplete.getIsExceptionThrown();
		
		if (!isExceptionThrown && incomplete.getTaskIdToMark() != -1) {
			if (isUndoAction) {
				addToList(incomplete, redoList);
			} else {
				addToList(incomplete, undoList);
			}
		}
	}
	
	/**
	 * Calls the Load function, which loads the task list from a backup file or a specified file.
	 */
	private void loadFunction() {
		Load load = new Load(taskObj);
		setOutput(load.run());
		setLastOutputTaskList(load.getLoadedTaskList());
		setTaskList(load.getLoadedTaskList());
		setLastSearchedIndex(-1);
		undoList.clear();
		redoList.clear();
	}
	
	/**
	 * Calls the Sort function, which sorts the task list according to status, then start date/time, then
	 * end date/time, then title.
	 */
	private void sortFunction() {
		Sort sort = new Sort(taskList);
		sort.run();
		setLastOutputTaskList(taskList);
	}
	

	// ------------------------- OVERLOADED METHODS TO POPULATE UNDO/REDO LIST -------------------------

	/**
	 * Method for adding a CommandObject containing "add" to either the undoList or redoList, which is
	 * previously determined by the caller. <br>
	 * A "delete" CommandObject will be pushed into the list. The index of the previously added TaskObject
	 * will be added into the CommandObject to facilitate future deletion. <br>
	 * If the added task was a recurring task,
	 */
	private void addToList(CommandObject commandObj, boolean isAddSingleOccurrence,
			Deque<CommandObject> list) {
		assert (commandType == INDEX_ADD);

		CommandObject newCommandObj = new CommandObject();
		sortedIndex = getNewIndexLocationOfTask(commandObj.getTaskObject().getTaskId());

		if (isAddSingleOccurrence) { // it is addition of a single occurrence
			newCommandObj = new CommandObject(INDEX_DELETE, new TaskObject(), index, lastSearchedIndex);
		} else {
			if (commandObj.getTaskObject().getIsRecurring()) {
				// isEditAll set to 'true'
				newCommandObj = new CommandObject(INDEX_DELETE, new TaskObject(true), sortedIndex);
			} else {
				newCommandObj = new CommandObject(INDEX_DELETE, new TaskObject(), sortedIndex);
			}
		}

		list.push(newCommandObj);
	}

	/**
	 * Method for adding a CommandObject containing "add" or "delete" to either the undoList or redoList,
	 * which is previously determined by the caller. <br>
	 * For command "add", For command "delete", an "add" CommandObject will be pushed into the list, together
	 * with a copy of the task which was just deleted.
	 * 
	 * @param commandObj
	 *            The CommandObject to be added to the stated list.
	 * @param list
	 *            Either a undoList or a redoList
	 */
	private void addToList(TaskObject removedTask, LocalDateTimePair removedOccurrenceTiming,
			Integer removedOccurrenceIndex, Deque<CommandObject> list) {
		assert (commandType == INDEX_DELETE);

		CommandObject newCommandObj = new CommandObject();
	
		/*
		 * 2 types of delete: 
		 * 1. delete task 
		 * 2. delete occurrence in ArrayList<LocalDateTimePair>
		 */
		if (removedOccurrenceTiming.isEmpty()) {
			newCommandObj = new CommandObject(INDEX_ADD, removedTask, index);
		} else {
			TaskObject taskObjWithRemovedOccurrenceTiming = new TaskObject(removedOccurrenceTiming);
			if (lastSearchedIndex != -1) { // to ensure that the occurrence is added to the correct task
				newCommandObj = new CommandObject(INDEX_ADD, taskObjWithRemovedOccurrenceTiming,
						removedOccurrenceIndex, lastSearchedIndex);
			} else {
				newCommandObj = new CommandObject(INDEX_ADD, taskObjWithRemovedOccurrenceTiming,
						removedOccurrenceIndex, index);
			}
		}

		list.push(newCommandObj);
	}

	/**
	 * Method for adding a CommandObject containing edit to either the undoList or redoList, predetermined by
	 * the caller of this method. <br>
	 * 
	 * @param editOriginal
	 *            Contains an Edit object which stores information on retrieving the original TaskObject prior
	 *            to the edit.
	 * @param list
	 *            Either an undoList or redoList
	 */
	private void addToList(Edit editOriginal, Deque<CommandObject> list) {

		TaskObject originalTask = editOriginal.getOriginalTask();
		originalTask.setIsEditAll(editOriginal.getIsEditAll());
		int editOccurrenceIndex = editOriginal.getEditOccurrenceIndex();
		sortedIndex = getNewIndexLocationOfTask(originalTask.getTaskId());

		CommandObject newCommandObj = new CommandObject();
		if (editOccurrenceIndex == -1) {
			newCommandObj = new CommandObject(INDEX_EDIT, originalTask, sortedIndex);
		} else {
			newCommandObj = new CommandObject(INDEX_EDIT, originalTask, editOccurrenceIndex, sortedIndex);
		}
		list.push(newCommandObj);
	}

	/**
	 * Constructs a CommandObject for either "complete" or "incomplete" and pushes it into the list.
	 * 
	 * @param mark
	 *            Mark object which performed the modification to the task list
	 * @param list
	 *            Either an undoList or redoList
	 */
	private void addToList(Mark mark, Deque<CommandObject> list) {
		CommandObject newCommandObj = new CommandObject();

		TaskObject originalTask = mark.getOriginalTask();
		sortedIndex = getNewIndexLocationOfTask(originalTask.getTaskId());
		int commandIndex = getCommandIndex(mark.getStatusToChange());
		assert (commandIndex == INDEX_COMPLETE || commandIndex == INDEX_INCOMPLETE);
		

		newCommandObj.setCommandType(commandIndex);
		newCommandObj.setTaskObject(originalTask);
		newCommandObj.setIndex(sortedIndex);

		list.push(newCommandObj);
	}
	
	// Returns the new index of the task with the specified task ID in the sorted list
	private int getNewIndexLocationOfTask(int searchTaskId) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == searchTaskId) {
				return i+1;
			}
		}
		return -1;
	}

	// Returns the appropriate command index depending on the previous status
	private int getCommandIndex(String prevStatus) {
		if (prevStatus.equals("completed")) {
			return INDEX_COMPLETE;
		} else if (prevStatus.equals("incomplete")) {
			return INDEX_INCOMPLETE;
		}
		return -1;
	}

```
###### \src\logic\CommandFacade.java
``` java
	// ---------------------------- OTHER METHODS ----------------------------

	/**
	 * Determines if the command involves editing of a task in the list.
	 * 
	 * @param command
	 *            Integer containing the command index of this command
	 * @return a boolean value indicating whether the command involves editing
	 */
	private boolean isListOperation(int command) {
		return command == INDEX_ADD || command == INDEX_EDIT || command == INDEX_DELETE
				|| command == INDEX_COMPLETE || command == INDEX_INCOMPLETE;
	}

	private void callSearchByIndexToUpdateSidebar(boolean bool) {
		if (bool) {
			CommandObject cmdObjToRunSearchByIndex = new CommandObject(INDEX_SEARCH_DISPLAY, 
					new TaskObject(), lastSearchedIndex);
			searchFunction(cmdObjToRunSearchByIndex);
		}
	}

	private void printInvalidCommandMessage() {
		output.clear();
		output.add(MESSAGE_INVALID_COMMAND);
	}
	
	// ------------------------- GETTERS AND SETTERS -------------------------

	public int getCommandType() {
		return commandType;
	}

	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}

	public Deque<CommandObject> getUndoList() {
		return undoList;
	}

	public Deque<CommandObject> getRedoList() {
		return redoList;
	}

	public ArrayList<TaskObject> getLastOutputTaskList() {
		return lastOutputTaskList;
	}

	public ArrayList<String> getOutput() {
		return output;
	}

	public CommandObject getCommandObject() {
		return commandObj;
	}
	
	public int getSortedIndex() {
		return sortedIndex;
	}

	public int getLastSearchedIndex() {
		return lastSearchedIndex;
	}

	// Returns arraylist of timeoutput to commandFacade
	public ArrayList<String> getTaskDateTimeOutput() {
		return taskDateTimeOutput;
	}

	public void setTaskList(ArrayList<TaskObject> newTaskList) {
		this.taskList = newTaskList;
	}

	public void setUndoList(Deque<CommandObject> newUndoList) {
		this.undoList = newUndoList;
	}

	public void setRedoList(Deque<CommandObject> newRedoList) {
		this.redoList = newRedoList;
	}

	public void setLastOutputTaskList(ArrayList<TaskObject> newLastOutputTaskList) {
		this.lastOutputTaskList = newLastOutputTaskList;
	}

	public void setOutput(ArrayList<String> newOutput) {
		this.output = newOutput;
	}

	public void setCommandObject(CommandObject newCommandObj) {
		this.commandObj = newCommandObj;
	}

	public void setCommandObjectValues() {
		setCommandType();
		setTaskObject();
		setIndex();
		setLastSearchedIndex();
	}

	private void setCommandType() {
		this.commandType = commandObj.getCommandType();
	}

	private void setTaskObject() {
		this.taskObj = commandObj.getTaskObject();
	}

	private void setIndex() {
		this.index = commandObj.getIndex();
	}

	public void setLastSearchedIndex() {
		this.lastSearchedIndex = commandObj.getLastSearchedIndex();
	}

	// Called by Search/Display
	public void setLastSearchedIndex(int lastSearchedIndex) {
		this.lastSearchedIndex = lastSearchedIndex;
		// commandObj.setLastSearchedIndex(lastSearchedIndex);
	}

	// Called by Search
	public void setTaskDateTimeOutput(ArrayList<String> taskDateTimeOutput) {
		this.taskDateTimeOutput = taskDateTimeOutput;
	}
}
```
###### \src\logic\delete\Delete.java
``` java

	/**
	 * Called by logic to find and delete an object in the task list. Automatically decides whether to use
	 * quick delete or normal delete based on the index of the CommandObject in the Delete object.
	 * 
	 * @return output: ArrayList<String> - Contains all the output that the user will see
	 */
	public ArrayList<String> run() {
		assert (!taskList.isEmpty());

		try {
			if (commandObj.getIndex() == 0) {
				if (commandObj.getTaskObject().getStatus().equals(STATUS_COMPLETED)) {
					runDeleteCompletedTasks();
				} else {
					runDeleteAll();
				}
			} else {
				checkIfDeleteSingleOccurrence();
				
				if (isDeleteSingleOccurrence) {
					setDeleteInformationForSingleOccurrenceDelete();
					processDeleteForSingleOccurrence(); // deletes a single occurrence of recurring task
				} else {
					setDeleteInformationForNormalDelete();

					if (isRecurringTask && !commandObj.getTaskObject().getIsEditAll()) {
						processDeleteForSingleOccurrence();
					} else {
						runNormalDelete();
					}
				}
			}
		} catch (DeleteException e) {
			tempOutput.add(e.getDeleteExceptionMessage());
			isExceptionThrown = true;
		} catch (NullPointerException e) {
			tempOutput.add(MESSAGE_DELETE_ERROR + MESSAGE_NULL_POINTER);
			isExceptionThrown = true;
		} catch (IndexOutOfBoundsException e) {
			tempOutput.add(MESSAGE_DELETE_ERROR + MESSAGE_INDEX_OUT_OF_BOUNDS);
			isExceptionThrown = true;
		} catch (NoSuchFileException e) {
			tempOutput.add(MESSAGE_REQUEST_SAVE_LOCATION);
			isExceptionThrown = true;
		} catch (IOException e) {
			tempOutput.add(MESSAGE_REQUEST_SAVE_LOCATION);
			isExceptionThrown = true;
		}

		concatenateOutput();
		return output;
	}

```
###### \src\logic\delete\Delete.java
``` java

	// Clears everything - task list, undo list, redo list and the storage file
	private void runDeleteAll() throws NoSuchFileException, IOException {
		taskList.clear();
		undoList.clear();
		redoList.clear();
		deleteExternal();
		logger.log(Level.INFO, "Delete all executed");

		isDeleteAll = true;
		createDeletedAllOutput();
	}

	private void processDeleteForSingleOccurrence()
			throws NoSuchFileException, NullPointerException, IOException {
		if (removedTask.getTaskDateTimes().size() > 1) {
			runSingleOccurrenceDelete();
		} else { // if there is only 1 occurrence left, delete the entire task
			createOnlyOneOccurrenceRemainingOutput();
			runNormalDelete();
		}
	}

	// Gets the array list of LocalDateTimePair from the task and removes the specified occurrence
	private void runSingleOccurrenceDelete() throws NullPointerException, NoSuchFileException, IOException {
		try {
			ArrayList<LocalDateTimePair> taskDateTimes = removedTask.getTaskDateTimes();
			originalRecurrenceTimings.addAll(taskDateTimes);
			assert (taskDateTimes.size() > 1);

			removedTaskOccurrenceDetails = taskDateTimes.remove(removedOccurrenceIndex - 1);
			removedTask.addToDeletedTaskDateTimes(removedTaskOccurrenceDetails);
			removedTask.setTaskDateTimes(taskDateTimes);
			removedTask.updateStartAndEndDateTimes();

			// If it is an infinitely recurring task, add 1 more task to the end of the list
			if (removedTask.isInfiniteRecurrence()) {
				try {
					Recurring.updateInfiniteRecurrence(removedTask);
				} catch (RecurrenceException e) {
					output.add(String.format(MESSAGE_RECURRENCE_EXCEPTION, removedTask.getTitle()));
					isExceptionThrown = true;
				}
			}

			if (deleteExternal()) {
				TimeOutput.setTaskTimeOutput(removedTask); // to update the recurrence date in GUI
				createSingleOccurrenceOutput();
				logger.log(Level.INFO, "Single occurrence delete executed");
			}
		} catch (IndexOutOfBoundsException e) {
			createSingleOccurrenceMissingErrorOutput();
			isExceptionThrown = true;
		}
	}

```
###### \src\logic\delete\Delete.java
``` java

	/*
	 * This method will be relevant in the case of undoing the addition of a recurring task where the first
	 * occurrence is overdue. This ensures that when the undo is processed, the split overdue task will be
	 * deleted along with the main task.
	 */
	private void checkForOverdueTask() {
		if (removedTask.getIsRecurring()) { // situation will only arise for recurring tasks
			int i = taskList.size() - 1;
			boolean isFoundSimiliarTask = false;

			while (i >= 0 && !isFoundSimiliarTask) {
				TaskObject overdueTask = taskList.get(i);
				if (isSimiliarTasks(removedTask, overdueTask)) {
					addTimingsOfOverdueTaskBackToOriginalTask(removedTask, overdueTask);
					taskList.remove(i);
					isFoundSimiliarTask = true;
					logger.log(Level.INFO, "Split overdue task removed");
				}
				i--;
			}
		}
	}

	private boolean isSimiliarTasks(TaskObject removedTask, TaskObject task) {
		return (removedTask.getTitle().equals(task.getTitle())
				&& removedTask.getCategory().equals(task.getCategory())
				&& task.getStatus().equals(STATUS_OVERDUE) && task.getTaskId() < 0);
	}

	private void addTimingsOfOverdueTaskBackToOriginalTask(TaskObject removedTask, TaskObject overdueTask) {
		LocalDateTimePair overdueTaskTiming = new LocalDateTimePair(overdueTask.getStartDateTime(),
				overdueTask.getEndDateTime());
		removedTask.addToTaskDateTimes(0, overdueTaskTiming);
		removedTask.updateStartAndEndDateTimes();
	}

	// ----------------------- SETTING DELETE INFORMATION -----------------------

	private void checkIfDeleteSingleOccurrence() throws DeleteException {
		if (commandObj.getIndex() == -1) {
			DeleteException e = new DeleteException(commandObj.getIndex());
			throw e;
		}

		if (lastSearchedIndex != -1) {
			isDeleteSingleOccurrence = true;
			removedOccurrenceIndex = commandObj.getIndex();
		}
	}

	private void setDeleteInformationForSingleOccurrenceDelete() {
		removedTaskIndex = lastSearchedIndex - 1;
		removedTask = lastOutputTaskList.get(removedTaskIndex);
		removedTaskName = removedTask.getTitle();

		logger.log(Level.INFO, "Set delete information for single occurrence de;ete");
	}

```
###### \src\logic\delete\DeleteTest.java
``` java
	
	@Test
	// Delete all
	public void testDeleteAll() {
		testArray.add(taskOne);
		testArray.add(taskTwo);
		testArray.add(taskThree);
		CommandObject cmd = new CommandObject(INDEX_DELETE, new TaskObject(), 0);
		Delete deleteAll = new Delete(cmd, testArray, testUndoList);
		ArrayList<String> actualOutput = new ArrayList<String> ();
		actualOutput = deleteAll.run();
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("All tasks deleted. Undo and redo lists are cleared.");
		
		assertEquals(expectedOutput, actualOutput);
	}
	
	@Test
	// --------------------------- DELETE FOR RECURRING TASK ---------------------------
	public void testDeleteRecurrence() {
		testArray.clear();
		
		// For recurrence task 1
		LocalDateTime startOne = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("16:00"));
		LocalDateTime endOne = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("18:00"));
		LocalDateTime startTwo = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("16:00"));
		LocalDateTime endTwo = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("18:00"));
		LocalDateTime startThree = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("16:00"));
		LocalDateTime endThree = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("18:00"));
		LocalDateTime startFour = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("16:00"));
		LocalDateTime endFour = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("18:00"));
		LocalDateTimePair pairOne = new LocalDateTimePair(startOne, endOne);
		LocalDateTimePair pairTwo = new LocalDateTimePair(startTwo, endTwo);		
		LocalDateTimePair pairThree = new LocalDateTimePair(startThree, endThree);		
		LocalDateTimePair pairFour = new LocalDateTimePair(startFour, endFour);		
		testTimingsOne.add(pairOne);
		testTimingsOne.add(pairTwo);
		testTimingsOne.add(pairThree);
		testTimingsOne.add(pairFour);
		
		TaskObject recurrenceTaskOne = new TaskObject("CS2103 lecture", startOne, endFour, "event", "incomplete", 
				1, true, testTimingsOne);
		testArray.add(recurrenceTaskOne);
		
		// For recurrence task 2
		startOne = LocalDateTime.of(LocalDate.parse("2016-09-03"), LocalTime.parse("22:00"));
		endOne = LocalDateTime.of(LocalDate.parse("2016-09-03"), LocalTime.parse("23:30"));
		startTwo = LocalDateTime.of(LocalDate.parse("2016-09-10"), LocalTime.parse("22:00"));
		endTwo = LocalDateTime.of(LocalDate.parse("2016-09-10"), LocalTime.parse("23:30"));
		startThree = LocalDateTime.of(LocalDate.parse("2016-09-17"), LocalTime.parse("22:00"));
		endThree = LocalDateTime.of(LocalDate.parse("2016-09-17"), LocalTime.parse("23:30"));
		pairOne = new LocalDateTimePair(startOne, endOne);
		pairTwo = new LocalDateTimePair(startTwo, endTwo);
		pairThree = new LocalDateTimePair(startThree, endThree);
		testTimingsTwo.add(pairOne);
		testTimingsTwo.add(pairTwo);
		testTimingsTwo.add(pairThree);
		
		TaskObject recurrenceTaskTwo = new TaskObject("Soccer match", startOne, endThree, "event", "incomplete",
				2, true, testTimingsTwo);
		testArray.add(recurrenceTaskTwo);
		
		CommandObject testCmdObj = new CommandObject(INDEX_DELETE, new TaskObject(), 1);
		Delete delete = new Delete(testCmdObj, testArray, testArray);
		delete.run();
		
		ArrayList<String> actualOutput = delete.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Most recent occurrence of task 'CS2103 lecture' deleted.");
		
		// check if it is the correct occurrence that has been removed
		LocalDateTimePair removedTaskOccurrenceDetails = delete.getRemovedTaskOccurrenceDetails();
		LocalDateTime start = removedTaskOccurrenceDetails.getStartDateTime();
		LocalDateTime end = removedTaskOccurrenceDetails.getEndDateTime();
		assertEquals(start.toString(), "2016-03-25T16:00");
		assertEquals(end.toString(), "2016-03-25T18:00");
		
		assertEquals(expectedOutput.get(0), actualOutput.get(1));
		assertEquals(3, delete.getRemovedTask().getTaskDateTimes().size()); // new size of arrlist after first occurrence is removed
	}
	
	@Test
	public void testRecurrenceDeleteTwo() {
		LocalDateTime startOne = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("16:00"));
		LocalDateTime endFour = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("18:00"));
		startOne = LocalDateTime.of(LocalDate.parse("2016-09-03"), LocalTime.parse("22:00"));
		LocalDateTime endThree = LocalDateTime.of(LocalDate.parse("2016-09-17"), LocalTime.parse("23:30"));
		
		TaskObject recurrenceTaskOne = new TaskObject("CS2103 lecture", startOne, endFour, "event", "incomplete", 
				1, true, testTimingsOne);
		TaskObject recurrenceTaskTwo = new TaskObject("Soccer match", startOne, endThree, "event", "incomplete",
				2, true, testTimingsTwo);
		testArray.add(recurrenceTaskOne);
		testArray.add(recurrenceTaskTwo);
		
		CommandObject testCmdObj = new CommandObject(INDEX_DELETE, new TaskObject("all"), 2);
		Delete delete = new Delete(testCmdObj, testArray, testArray);
		delete.run();
		
		ArrayList<String> actualOutput = delete.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Only one occurrence remaining. All occurrences of task 'Soccer match' deleted.");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(1, delete.getTaskList().size());
	}
	
}
```
###### \src\logic\display\Display.java
``` java

package logic.display;

import java.util.ArrayList;
import java.util.logging.*;

import common.AtfLogger;
import common.TaskObject;
import logic.timeoutput.TimeOutput;

import static logic.constants.Strings.*;


/**
 *  The Display class is a parent of the Search class. <br>
 *  This class is called when the user inputs a search command with no search keyword, i.e. the entire task
 *  list is to be displayed. <br>
 *  There are 2 run methods: <br>
 *  (a) run() - This is called when the entire task list is to be displayed.
 *  (b) runSpecificList() - This is called by the child Search class, where an ArrayList<TaskObject> will be
 *	passed into the method and only the tasks in this list will be displayed.
 *  
 * @author ChongYan, RuiBin
 *
 */

public class Display {

	protected static Logger logger = AtfLogger.getLogger();
	
	private ArrayList<TaskObject> taskList;
	private ArrayList<TaskObject> outputTaskList = new ArrayList<TaskObject>();
	private ArrayList<String> output = new ArrayList<String>();
	protected int lastSearchedIndex = -1;
	
	public Display() {
		
	}

	/**
	 * Default constructor for a Display object.
	 * @param taskList	existing ArrayList of TaskObjects which comprises the entire task list
	 */
	public Display(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}
	
	/**
	 * Default run method to display all tasks in the task list.
	 * @return output	Task list formatted for display in the GUI
	 */
	public ArrayList<String> run() {
		if (!taskList.isEmpty()) {
			output.add(MESSAGE_DISPLAYING_ALL_TASKS);
		}
		return this.display();
	}

	/**
	 * Run method called by the child Search class. Only the tasks in the ArrayList passed to this method
	 * will be displayed.
	 * @param newTaskList	Contains a filtered list of tasks
	 * @return output		Task list formatted for display in the GUI
	 */
	public ArrayList<String> runSpecificList(ArrayList<TaskObject> newTaskList) {
		this.taskList = newTaskList;
		return this.display();
	}
	
	/**
	 * Extracts task information from each TaskObject and puts them into an ArrayList<String> for display in
	 * the GUI. <br>
	 * If the task list is empty, a default message for an empty task list will be printed instead. <br>
	 * @return output	Task list formatted for display in the GUI
	 */
	private ArrayList<String> display() {
		if (taskList.isEmpty()) {
			logger.log(Level.INFO, "Task list is empty");
			output.add(MESSAGE_EMPTY_LIST);
		} else {
			logger.log(Level.INFO, "Displaying tasks");
			outputTaskList.addAll(taskList);
			TimeOutput.setTimeOutputForGui(taskList);
		}
			
		return output;
	}
	
	public ArrayList<String> getOutput() {
		return output;
	}
	
	public ArrayList<TaskObject> getLastOutputTaskList() {
		return outputTaskList;
	}
	
	public int getLastSearchedIndex() {
		return lastSearchedIndex;
	}
	
}
```
###### \src\logic\display\DisplayTest.java
``` java

package logic.display;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;

import org.junit.Test;

import common.TaskObject;

public class DisplayTest {

	private static ArrayList<TaskObject> testList = new ArrayList<TaskObject>();

	@Test // Empty task list
	public void testA() {
		Display displayTest = new Display(testList);
		displayTest.run();

		assertEquals("Task list is empty.", displayTest.getOutput().get(0));
	}

	@Test // Displaying all tasks
	public void testB() {
		testList.add(new TaskObject("Be great in life", "floating", "incomplete", 1));
		testList.add(new TaskObject("Clear Year 2 IPPT",
				LocalDateTime.of(LocalDate.parse("2016-08-17"), LocalTime.MAX), "deadline", "incomplete", 2));
		testList.add(new TaskObject("ATAP internship",
				LocalDateTime.of(LocalDate.parse("2016-05-09"), LocalTime.MAX),
				LocalDateTime.of(LocalDate.parse("2016-10-21"), LocalTime.MAX), "event", "incomplete", 3));

		Display displayTest = new Display(testList);
		displayTest.run();

		assertEquals("Displaying all tasks.", displayTest.getOutput().get(0));
		assertEquals(3, displayTest.getLastOutputTaskList().size());
	}
	
	@Test // Run a specific list
	public void testC() {
		Display displayTest = new Display();
		displayTest.runSpecificList(testList);
		
		assertEquals(3, displayTest.getLastOutputTaskList().size());
		assertEquals(-1, displayTest.getLastSearchedIndex());
	}

}
```
###### \src\logic\edit\Edit.java
``` java

package logic.edit;

import storage.FileStorage;
import storage.IStorage;

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.logging.*;

import common.CommandObject;
import common.Interval;
import common.LocalDateTimePair;
import common.TaskObject;
import logic.Recurring;
import logic.exceptions.EditException;
import logic.exceptions.RecurrenceException;
import logic.timeoutput.TimeOutput;

import static logic.constants.Strings.*;

/**
 * Creates an Edit object which will edit the information of a selected task/occurrence. <br>
 * 
 * All the edit information is first set based on the information in the CommandObject that is passed in the
 * constructor. This is done by having boolean checks for each attribute. The attributes that can be edited
 * are: <br>
 * 1. Title <br>
 * 2. Start date <br>
 * 3. Start time <br>
 * 4. End date <br>
 * 5. End time <br>
 * 6. Interval <br>
 * 
 * If it is a single occurrence being edited instead of a task, there will only be 4 attributes that can be
 * edited: <br>
 * 1. Start date <br>
 * 2. Start time <br>
 * 3. End date <br>
 * 4. End time <br>
 * 
 * If the task to be edited is a recurring task, there are 2 ways that the edit can be processed: <br>
 * (a) Edit only the upcoming occurrence - this will be the default option, where only the date/time data for
 * the first occurrence in the ArrayList<LocalDateTimePair> will be modified. <br>
 * (b) Edit all occurrences - this will be called if the user input contains the 'all' keyword, i.e. 'edit all
 * <index> ...'. This will edit the date/time details for all occurrences in the ArrayList. <br>
 * 
 * @param commandObj
 *            Contains all the information regarding what to change. The TaskObject contained within contains
 *            all the new edit information, while the index in this CommandObject contains the relative
 *            position of the task in the lastOutputTaskList.
 * @param lastOutputTaskList
 *            Contains the task list that is currently being displayed to the user.
 * @param taskList
 *            Contains the entire list of all tasks.
 * @param lastSearchedIndex
 *            Contains the last searched index - it is only filled if it is an edit of a n-th occurrence.
 * 
 * @author ChongYan, RuiBin
 *
 */

public class Edit {

	private static final Logger logger = Logger.getLogger(Edit.class.getName());

	private CommandObject commandObj;
	private ArrayList<TaskObject> lastOutputTaskList;
	private ArrayList<TaskObject> taskList;
	private int lastSearchedIndex;
	private ArrayList<String> tempOutput = new ArrayList<String>();
	private ArrayList<String> output = new ArrayList<String>();
	private boolean isExceptionThrown = false;

	private TaskObject originalTask = new TaskObject(); // original task info; for undo purposes
	private ArrayList<LocalDateTimePair> originalTimings = new ArrayList<LocalDateTimePair>(); 	// for undo
	private TaskObject editTask; // task to be edited
	private int editTaskIndex;
	private int editOccurrenceIndex = -1;
	private int editTaskId;
	private String originalTitle = "";
	private LocalDateTime originalStartDateTime = LocalDateTime.MAX;
	private LocalDate originalStartDate = LocalDate.MAX;
	private LocalTime originalStartTime = LocalTime.MAX;
	private LocalDateTime originalEndDateTime = LocalDateTime.MAX;
	private LocalDate originalEndDate = LocalDate.MAX;
	private LocalTime originalEndTime = LocalTime.MAX;
	private Interval originalInterval = new Interval();
	private String editTitle;
	private LocalDate editStartDate;
	private LocalTime editStartTime;
	private LocalDate editEndDate;
	private LocalTime editEndTime;
	private Interval editInterval;

	// For normal tasks
	boolean isEditTitle = false;
	boolean isEditStartDate = false;
	boolean isEditStartTime = false;
	boolean isEditEndDate = false;
	boolean isEditEndTime = false;
	boolean isEditInterval = false;
	// For recurring tasks
	boolean isEditAll = false;
	boolean isRecurringTask = false;
	boolean isEditStartDateForAllOccurrences = false;
	boolean isEditStartTimeForAllOccurrences = false;
	boolean isEditEndDateForAllOccurrences = false;
	boolean isEditEndTimeForAllOccurrences = false;
	// For editing of an occurrence
	boolean isEditSingleOccurrence = false;
	boolean isEditStartDateOccurrence = false;
	boolean isEditStartTimeOccurrence = false;
	boolean isEditEndDateOccurrence = false;
	boolean isEditEndTimeOccurrence = false;

	public Edit(CommandObject commandObj, ArrayList<TaskObject> lastOutputTaskList,
			ArrayList<TaskObject> taskList, int lastSearchedIndex) {
		this.commandObj = commandObj;
		this.lastOutputTaskList = lastOutputTaskList;
		this.taskList = taskList;
		this.lastSearchedIndex = lastSearchedIndex;
	}

	/**
	 * Main method of Edit. <br>
	 * Sets the information to be edited, finds the task to be edited and edits all the information before
	 * saving the edited task to the external file location.
	 * 
	 * @return output
	 */
	public ArrayList<String> run() {
		setEditInformation();
		setTaskToBeEdited();
		processEdit();
		updateCategory();
		saveExternal();
		updateGuiDisplay();

		setOutput();
		return output;
	}

	/**
	 * Sets all the edit information by retrieving the relevant information from the CommandObject and
	 * TaskObject.
	 */
	private void setEditInformation() {
		try {
			editTaskIndex = commandObj.getIndex();

			editTitle = commandObj.getTaskObject().getTitle();
			if (!editTitle.equals("")) {
				isEditTitle = true;
			}
			editStartDate = commandObj.getTaskObject().getStartDateTime().toLocalDate();
			if (!editStartDate.isEqual(LocalDate.MAX)) {
				isEditStartDate = true;
			}
			editStartTime = commandObj.getTaskObject().getStartDateTime().toLocalTime();
			if (!editStartTime.equals(LocalTime.MAX)) {
				isEditStartTime = true;
			}
			editEndDate = commandObj.getTaskObject().getEndDateTime().toLocalDate();
			if (!editEndDate.isEqual(LocalDate.MAX)) {
				isEditEndDate = true;
			}
			editEndTime = commandObj.getTaskObject().getEndDateTime().toLocalTime();
			if (!editEndTime.equals(LocalTime.MAX)) {
				isEditEndTime = true;
			}
			editInterval = commandObj.getTaskObject().getInterval();
			if (!editInterval.isNull()) {
				isEditInterval = true;
			}
			if (lastSearchedIndex != -1) { // it is an occurrence, and not a task, that is to be edited
				isEditSingleOccurrence = true;
				editTaskIndex = lastSearchedIndex;
				editOccurrenceIndex = commandObj.getIndex();
			}
			isEditAll = commandObj.getTaskObject().getIsEditAll(); // if all occurrences are to be edited

			//checkEditInformation(); // for debugging
		} catch (NullPointerException e) {
			logger.log(Level.WARNING, "Error setting edit information");
			tempOutput.add(MESSAGE_SETTING_EDIT_INFO_ERROR);
			isExceptionThrown = true;
		}
	}

	/**
	 * Finds the task to be edited based on the edit task index value, and sets the originalTask to be a
	 * replicate of this task for undo purposes.
	 */
	private void setTaskToBeEdited() {
		assert (editTaskIndex > 0 && editTaskIndex <= lastOutputTaskList.size());

		editTaskId = lastOutputTaskList.get(editTaskIndex - 1).getTaskId();
		logger.log(Level.INFO, "Obtained task ID to be edited");

		for (int i = 0; i < taskList.size(); i++) {
			TaskObject task = taskList.get(i);
			if (task.getTaskId() == editTaskId) {
				editTask = task;
				isRecurringTask = task.getIsRecurring();
				compareOldAndNewCategory(task);

				originalTask.setTaskObject(task);
				originalTimings.addAll(task.getTaskDateTimes());
				originalTask.setTaskDateTimes(originalTimings);
				originalTimings.clear();
			}
		}
	}

	/**
	 * Processes the edit depending if it is an edit of a single occurrence or of a task.
	 */
	private void processEdit() {
		if (isEditSingleOccurrence) {
			updateBooleanChecksForEditOccurrence(); // so that the correct output will be printed
			editRecurrenceTiming();
		} else {
			editTask();
		}
	}

	// Edits a recurrence timing
	private void editRecurrenceTiming() {
		TaskObject task = lastOutputTaskList.get(editTaskIndex - 1);
		originalTask.setTaskObject(task);
		originalTimings.addAll(task.getTaskDateTimes());

		LocalDateTimePair timing = new LocalDateTimePair();
		LocalDateTimePair originalTiming = new LocalDateTimePair();
		
		try {
			originalTiming.setDateTimePair(task.getTaskDateTimes().get(editOccurrenceIndex - 1));
			timing = task.getTaskDateTimes().get(editOccurrenceIndex - 1);
			setOriginalStartAndEndDateAndTime(timing);

			// if it is an undo function, edit info will be the old info
			if (!commandObj.getTaskObject().getTaskDateTimes().isEmpty()) {
				LocalDateTimePair editDateTimes = 
						commandObj.getTaskObject().getTaskDateTimes().get(editOccurrenceIndex - 1);
				setEditStartAndEndDateAndTime(editDateTimes);
			} 
			
			editRespectiveOccurrences(timing);
			
			// Ensures that originalTask contains the old timings
			originalTask.setTaskDateTimes(originalTimings);
			originalTask.getTaskDateTimes().remove(editOccurrenceIndex - 1);
			originalTask.getTaskDateTimes().add(editOccurrenceIndex - 1, originalTiming);

			task.updateStartAndEndDateTimes();
			editTask = task;
		} catch (IndexOutOfBoundsException e) {
			tempOutput.add(MESSAGE_NO_SUCH_OCCURRENCE_EXISTS);
			isEditStartDateOccurrence = false;
			isEditStartTimeOccurrence = false;
			isEditEndDateOccurrence = false;
			isEditEndTimeOccurrence = false;
			isExceptionThrown = true;
		} catch (EditException e) {
			tempOutput.add(e.getMessage());
			isExceptionThrown = true;
		}
	}
	
	// Edits a task
	private void editTask() {
		try {
			if (isEditTitle) {
				editTitle(editTask);
			}
			if (isEditStartDate && isEditStartTime) {
				if (isRecurringTask && isEditAll) {
					editStartDateAndTimeForAllOccurrences(editTask);
				} else {
					editStartDateAndTime(editTask);
				}
			} else {
				if (isEditStartDate) {
					if (isRecurringTask && isEditAll) {
						editStartDateForAllOccurrences(editTask);
					} else {
						editStartDate(editTask);
					}
				} else if (isEditStartTime) {
					if (isRecurringTask && isEditAll) {
						editStartTimeForAllOccurrences(editTask);
					} else {
						editStartTime(editTask);
					}
				}
			}
			if (isEditEndDate && isEditEndTime) {
				if (isRecurringTask && isEditAll) {
					editEndDateAndTimeForAllOccurrences(editTask);
				} else {
					editEndDateAndTime(editTask);
				}
			} else {
				if (isEditEndDate) {
					if (isRecurringTask && isEditAll) {
						editEndDateForAllOccurrences(editTask);
					} else {
						editEndDate(editTask);
					}
				} else if (isEditEndTime) {
					if (isRecurringTask && isEditAll) {
						editEndTimeForAllOccurrences(editTask);
					} else {
						editEndTime(editTask);
					}
				}
			}
			if (isEditInterval) {
				editInterval(editTask);
			}
		} catch (RecurrenceException e) {
			tempOutput.add(e.getRecurrenceExceptionMessage());
			isExceptionThrown = true;
		} catch (Exception e) {
			tempOutput.add(e.getMessage());
			isExceptionThrown = true;
		}

	}
	
	// ------------------------- EDIT METHODS -------------------------

	// For editing of recurrence timing
	private void editRespectiveOccurrences(LocalDateTimePair timing) throws EditException {
		checkForInvalidDateTimeEdit(timing.getStartDateTime(), timing.getEndDateTime());
		
		if (isEditStartDateOccurrence && isEditStartTimeOccurrence) {
			timing.setStartDateTime(LocalDateTime.of(editStartDate, editStartTime));
			if (originalStartDate.equals(editStartDate)) {
				isEditStartDateOccurrence = false;
			}
			if (originalStartTime.equals(editStartTime)) {
				isEditStartTimeOccurrence = false;
			}
		} else {
			if (isEditStartDateOccurrence) {
				if (originalStartDate.equals(editStartDate)) {
					isEditStartDateOccurrence = false;
				} else {
					timing.setStartDateTime(LocalDateTime.of(editStartDate, originalStartTime));
				}
			} else if (isEditStartTimeOccurrence) {
				if (originalStartTime.equals(editStartTime)) {
					isEditStartTimeOccurrence = false;
				} else {
					timing.setStartDateTime(LocalDateTime.of(originalStartDate, editStartTime));
				}
			}
		}
		if (isEditEndDateOccurrence && isEditEndTimeOccurrence) {
			timing.setEndDateTime(LocalDateTime.of(editEndDate, editEndTime));
			if (originalEndDate.equals(editEndDate)) {
				isEditEndDateOccurrence = false;
			}
			if (originalEndTime.equals(editEndTime)) {
				isEditEndTimeOccurrence = false;
			}
		} else {
			if (isEditEndDateOccurrence) {
				if (originalEndDate.equals(editEndDate)) {
					isEditEndDateOccurrence = false;
				} else {
					timing.setEndDateTime(LocalDateTime.of(editEndDate, originalEndTime));
				}
			} else if (isEditEndTimeOccurrence) {
				if (originalEndTime.equals(editEndTime)) {
					isEditEndTimeOccurrence = false;
				} else {
					timing.setEndDateTime(LocalDateTime.of(originalEndDate, editEndTime));
				}
			}
		}
	}
	
	// Edits the title of the task
	private void editTitle(TaskObject task) throws Exception {
		try {
			originalTitle = task.getTitle();

			if (!originalTitle.equals(editTitle)) {
				task.setTitle(editTitle.trim());
				logger.log(Level.INFO, "Title edited");
			} else {
				isEditTitle = false;
			}
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editTitle");
			e = new EditException("title");
			throw e;
		}
	}

	// Edits the start date and time for all recurring occurrences
	private void editStartDateAndTimeForAllOccurrences(TaskObject task) throws Exception {
		try {
			ArrayList<LocalDateTimePair> taskDateTimes = task.getTaskDateTimes();
			setOriginalStartDateAndTime(task);

			// edit the ArrayList
			for (int i = 0; i < taskDateTimes.size(); i++) {
				LocalDateTimePair taskDateTime = taskDateTimes.get(i);
				LocalDateTime taskNewStartDateTime = LocalDateTime.of(editStartDate, editStartTime);
				taskDateTime.setStartDateTime(taskNewStartDateTime);
			}

			// then edit the TaskObject
			task.setStartDateTime(LocalDateTime.of(editStartDate, editStartTime));

			logger.log(Level.INFO, "Start dates and times edited for all occurrences of recurring task");
			isEditStartDateForAllOccurrences = true;
			isEditStartTimeForAllOccurrences = true;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editStartDateAndTimeForAllOccurrences");
			e = new EditException("start date and time for all occurrences");
			throw e;
		}
	}

	// Edit the start date and time of both the TaskObject and the first occurrence in the ArrayList.
	private void editStartDateAndTime(TaskObject task) throws EditException, Exception {
		LocalDateTimePair taskDateTimeFirst = new LocalDateTimePair();
		try {
			taskDateTimeFirst = task.getTaskDateTimes().get(0);
			setOriginalStartDateAndTime(task);
		} catch (Exception e) {
			// there is no previous start date/time
		}
		
		try {
			checkForInvalidDateTimeEdit(task.getStartDateTime(), task.getEndDateTime());
			
			if (!originalStartDate.isEqual(editStartDate) && !originalStartTime.equals(editStartTime)) {
				task.setStartDateTime(LocalDateTime.of(editStartDate, editStartTime));
				task.updateTaskDateTimesArray();
				taskDateTimeFirst.setStartDateTime(LocalDateTime.of(editStartDate, editStartTime));
				logger.log(Level.INFO, "Start date and time edited");
			} else if (originalStartTime.equals(editStartTime)) { // if old time == new time, only edit date
				isEditStartTime = false;
				editStartDate(task);
			} else if (originalStartDate.isEqual(editStartDate)) { // if old date == new date, only edit time
				isEditStartDate = false;
				editStartTime(task);
			}
		} catch (EditException e) {
			logger.log(Level.INFO, "EditException thrown in method editStartDateAndTime");
			throw e;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editStartDateAndTime");
			e = new EditException("start date and time");
			throw e;
		}

	}

	// Edits the start date for all recurring occurrences
	private void editStartDateForAllOccurrences(TaskObject task) throws Exception {
		ArrayList<LocalDateTimePair> taskDateTimes = task.getTaskDateTimes();
		setOriginalStartDateAndTime(task);

		try {
			// edit the ArrayList
			for (int i = 0; i < taskDateTimes.size(); i++) {
				LocalDateTimePair taskDateTime = taskDateTimes.get(i);
				LocalTime taskOriginalStartTime = taskDateTime.getStartDateTime().toLocalTime();

				// Sets the start date to be the new date
				LocalDateTime taskNewStartDateTime = LocalDateTime.of(editStartDate, taskOriginalStartTime);
				taskDateTime.setStartDateTime(taskNewStartDateTime);
			}

			// then edit the TaskObject
			task.setStartDateTime(LocalDateTime.of(editStartDate, originalStartTime));

			logger.log(Level.INFO, "Start dates edited for all occurrences of recurring task");
			isEditStartDateForAllOccurrences = true;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editStartDateForAllOccurrences");
			e = new EditException("start date for all occurrences");
			throw e;
		}
	}

	// Edit the start date of both the TaskObject and the first occurrence in the ArrayList.
	private void editStartDate(TaskObject task) throws EditException, Exception {
		LocalDateTimePair taskDateTimeFirst = new LocalDateTimePair();
		try {
			taskDateTimeFirst = task.getTaskDateTimes().get(0);
			setOriginalStartDateAndTime(task);
		} catch (Exception e) {
			// there is no previous start date/time
		}
		
		try {
			checkForInvalidDateTimeEdit(task.getStartDateTime(), task.getEndDateTime());

			if (!originalStartDate.isEqual(editStartDate)) {
				task.setStartDateTime(LocalDateTime.of(editStartDate, originalStartTime));
				task.updateTaskDateTimesArray();
				taskDateTimeFirst.setStartDateTime(LocalDateTime.of(editStartDate, originalStartTime));
				logger.log(Level.INFO, "Start date edited");
			} else {
				isEditStartDate = false;
			}
		} catch (EditException e) {
			logger.log(Level.INFO, "EditException thrown in method editStartDate");
			throw e;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editStartDate");
			e = new EditException("start date");
			throw e;
		}
	}

	// Edits the start time for all recurring occurrences
	private void editStartTimeForAllOccurrences(TaskObject task) throws Exception {
		ArrayList<LocalDateTimePair> taskDateTimes = task.getTaskDateTimes();
		setOriginalStartDateAndTime(task);
		
		try {
			// edit the ArrayList
			for (int i = 0; i < taskDateTimes.size(); i++) {
				LocalDateTimePair taskDateTime = taskDateTimes.get(i);
				LocalDate taskOriginalStartDate = taskDateTime.getStartDateTime().toLocalDate();

				// If the original start date is null, i.e. it is a floating task which is being edited to
				// another category, then the date will be default to today.
				if (taskOriginalStartDate.equals(LocalDate.MAX)) {
					taskOriginalStartDate = LocalDate.now();
				}

				// Sets the start time to be the new time
				LocalDateTime taskNewStartDateTime = LocalDateTime.of(taskOriginalStartDate, editStartTime);
				taskDateTime.setStartDateTime(taskNewStartDateTime);
			}

			// then edit the TaskObject
			task.setStartDateTime(LocalDateTime.of(originalStartDate, editStartTime));

			logger.log(Level.INFO, "Start times edited for all occurrences of recurring task");
			isEditStartTimeForAllOccurrences = true;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editStartTimeForAllOccurrences");
			e = new EditException("start time for all occurrences");
			throw e;
		}
	}

	// Edit the start time of both the TaskObject and the first occurrence in the ArrayList.
	private void editStartTime(TaskObject task) throws EditException, Exception {
		LocalDateTimePair taskDateTimeFirst = new LocalDateTimePair();
		try {
			taskDateTimeFirst = task.getTaskDateTimes().get(0);
			setOriginalStartDateAndTime(task);
		} catch (Exception e) {
			// there is no previous start date/time
		}

		try {
			checkForInvalidDateTimeEdit(task.getStartDateTime(), task.getEndDateTime());

			// If the original start date is null, i.e. it is a floating task which is being edited to another 
			// category, then the date will be default to today.
			if (originalStartDate.equals(LocalDate.MAX)) {
				originalStartDate = LocalDate.now();
			}
			
			if (!originalStartTime.equals(editStartTime)) {
				task.setStartDateTime(LocalDateTime.of(originalStartDate, editStartTime));
				task.updateTaskDateTimesArray();
				taskDateTimeFirst.setStartDateTime(LocalDateTime.of(originalStartDate, editStartTime));
				logger.log(Level.INFO, "Start time edited");
			} else {
				isEditStartTime = false;
			}
		} catch (EditException e) {
			logger.log(Level.INFO, "EditException thrown in method editStartTime");
			throw e;
		}catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editStartTime");
			e = new EditException("start time");
			throw e;
		}
	}

	// Edits the end date and time for all recurring occurrences
	private void editEndDateAndTimeForAllOccurrences(TaskObject task) throws Exception {
		ArrayList<LocalDateTimePair> taskDateTimes = task.getTaskDateTimes();
		setOriginalEndDateAndTime(task);

		try {
			// edit the ArrayList
			for (int i = 0; i < taskDateTimes.size(); i++) {
				LocalDateTimePair taskDateTime = taskDateTimes.get(i);
				LocalDateTime taskNewEndDateTime = LocalDateTime.of(editEndDate, editEndTime);
				taskDateTime.setEndDateTime(taskNewEndDateTime);
			}

			// then edit the TaskObject
			task.setEndDateTime(LocalDateTime.of(editEndDate, editEndTime));

			logger.log(Level.INFO, "End dates and times edited for all occurrences of recurring task");
			isEditEndDateForAllOccurrences = true;
			isEditEndTimeForAllOccurrences = true;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editEndDateAndTimeForAllOccurrences");
			e = new EditException("end date and time for all occurrences");
			throw e;
		}
	}

	// Edit the end date and time of both the TaskObject and the first occurrence in the ArrayList.
	private void editEndDateAndTime(TaskObject task) throws Exception {
		LocalDateTimePair taskDateTimeFirst = task.getTaskDateTimes().get(0);
		setOriginalEndDateAndTime(task);
		
		try {
			if (!originalEndDate.isEqual(editEndDate) && !originalEndTime.equals(editEndTime)) {
				task.setEndDateTime(LocalDateTime.of(editEndDate, editEndTime));
				taskDateTimeFirst.setEndDateTime(LocalDateTime.of(editEndDate, editEndTime));
				logger.log(Level.INFO, "End date and time edited");
			} else if (originalEndTime.equals(editEndTime)) { // if old time == new time, only edit date
				isEditEndTime = false;
				editEndDate(task);
			} else if (originalEndDate.isEqual(editEndDate)) { // if old date == new date, only edit time
				isEditEndDate = false;
				editEndTime(task);
			}
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editEndDateAndTime");
			e = new EditException("end date and time");
			throw e;
		}
	}

	// Edits the end date for all recurring occurrences
	private void editEndDateForAllOccurrences(TaskObject task) throws Exception {
		ArrayList<LocalDateTimePair> taskDateTimes = task.getTaskDateTimes();
		setOriginalEndDateAndTime(task);
		
		try {
			// edit the ArrayList
			for (int i = 0; i < taskDateTimes.size(); i++) {
				LocalDateTimePair taskDateTime = taskDateTimes.get(i);
				LocalTime taskOriginalEndTime = taskDateTime.getEndDateTime().toLocalTime();

				// Sets the end date to be the new date
				LocalDateTime taskNewEndDateTime = LocalDateTime.of(editEndDate, taskOriginalEndTime);
				taskDateTime.setEndDateTime(taskNewEndDateTime);
			}

			// then edit the TaskObject
			task.setEndDateTime(LocalDateTime.of(editEndDate, originalEndTime));

			logger.log(Level.INFO, "End dates edited for all occurrences of recurring task");
			isEditEndDateForAllOccurrences = true;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editEndDateForAllOccurrences");
			e = new EditException("end date for all occurrences");
			throw e;
		}
	}

	// Edit the end date of both the TaskObject and the first occurrence in the ArrayList.
	private void editEndDate(TaskObject task) throws Exception {
		LocalDateTimePair taskDateTimeFirst = task.getTaskDateTimes().get(0);
		setOriginalEndDateAndTime(task);

		try {
			if (!originalEndDate.isEqual(editEndDate)) {
				task.setEndDateTime(LocalDateTime.of(editEndDate, originalEndTime));
				taskDateTimeFirst.setEndDateTime(LocalDateTime.of(editEndDate, originalEndTime));
				logger.log(Level.INFO, "End date edited");
			} else {
				isEditEndDate = false;
			}
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editEndDate");
			e = new EditException("end date");
			throw e;
		}
	}

	// Edits the end time for all recurring occurrences
	private void editEndTimeForAllOccurrences(TaskObject task) throws Exception {
		ArrayList<LocalDateTimePair> taskDateTimes = task.getTaskDateTimes();
		setOriginalEndDateAndTime(task);

		try {
			// edit the ArrayList
			for (int i = 0; i < taskDateTimes.size(); i++) {
				LocalDateTimePair taskDateTime = taskDateTimes.get(i);
				LocalDate taskOriginalEndDate = taskDateTime.getEndDateTime().toLocalDate();

				// If the original end date is null, i.e. it is a floating task which is being edited to
				// another category, then the date will be set to the start date.
				if (taskOriginalEndDate.equals(LocalDate.MAX)) {
					taskOriginalEndDate = taskDateTime.getStartDateTime().toLocalDate();
				}

				// Sets the end time to be the new time
				LocalDateTime taskNewEndDateTime = LocalDateTime.of(taskOriginalEndDate, editEndTime);
				taskDateTime.setEndDateTime(taskNewEndDateTime);
			}

			// then edit the TaskObject
			task.setEndDateTime(LocalDateTime.of(originalEndDate, editEndTime));
			task.updateStartAndEndDateTimes();

			logger.log(Level.INFO, "End times edited for all occurrences of recurring task");
			isEditEndTimeForAllOccurrences = true;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editEndTimeForAllOccurrences");
			e = new EditException("end time for all occurrences");
			throw e;
		}
	}

	// Edit the end time of both the TaskObject and the first occurrence in the ArrayList.
	private void editEndTime(TaskObject task) throws EditException, Exception {
		LocalDateTimePair taskDateTimeFirst = task.getTaskDateTimes().get(0); 
		setOriginalEndDateAndTime(task);
		
		// Throw an exception if there is no start time
		if (task.getStartDateTime().toLocalTime().equals(LocalTime.MAX)) {
			isEditEndTime = false;
			throw new EditException(task.getStartDateTime().toLocalTime());
		}
		
		try {
			// If the original end date is null, i.e. it is a floating task which is being edited to another
			// category, then the date will be default to the start date.
			if (originalEndDate.equals(LocalDate.MAX)) {
				originalEndDate = task.getStartDateTime().toLocalDate();
			}

			checkForInvalidDateTimeEdit(task.getStartDateTime(), LocalDateTime.of(originalEndDate, editEndTime));
	
			if (!originalEndTime.equals(editEndTime)) {
				task.setEndDateTime(LocalDateTime.of(originalEndDate, editEndTime));
				taskDateTimeFirst.setEndDateTime(LocalDateTime.of(originalEndDate, editEndTime));
				logger.log(Level.INFO, "End time edited");
			} else {
				isEditEndTime = false;
			}
		} catch (EditException e) {
			logger.log(Level.INFO, "EditException thrown in method editEndTime");
			throw e;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editEndTime");
			e = new EditException("end time");
			throw e;
		}
	}

	private void editInterval(TaskObject task) throws RecurrenceException, Exception {
		try {
			originalInterval = task.getInterval();
			
			if (!originalInterval.equals(editInterval)) {
				task.setInterval(editInterval);
				Recurring.setAllRecurringEventTimes(task); // To update the list of recurrence timings
				logger.log(Level.INFO, "Interval edited");
			} else {
				isEditInterval = false;
			}
		} catch (RecurrenceException e) {
			logger.log(Level.INFO, "RecurrenceException thrown in method editInterval");
			throw e;
		} catch (Exception e) {
			logger.log(Level.INFO, "Exception thrown in method editInterval");
			e = new EditException("interval");
			throw e;
		}
	}
	
	// ------------------------- OTHER METHODS -------------------------
	
	
	// Checks if the new start date/time is after the current or the edit end date/time
	private void checkForInvalidDateTimeEdit(LocalDateTime currentStartDateTime, LocalDateTime currentEndDateTime) throws EditException {
		LocalDateTime newStartDateTime;
		LocalDateTime newEndDateTime;
		
		if ((isEditStartDate && isEditStartTime) || 
				(isEditStartDateOccurrence && isEditStartTimeOccurrence)) {
			newStartDateTime  = LocalDateTime.of(editStartDate, editStartTime);
		} else if ((isEditStartDate && !isEditStartTime) || 
				(isEditStartDateOccurrence && !isEditStartTimeOccurrence)) {
			newStartDateTime = LocalDateTime.of(editStartDate, currentStartDateTime.toLocalTime());
		} else if ((!isEditStartDate && isEditStartTime) || 
				(!isEditStartDateOccurrence && isEditStartTimeOccurrence)) {
			newStartDateTime = LocalDateTime.of(currentStartDateTime.toLocalDate(), editStartTime);
		} else {
			newStartDateTime = currentStartDateTime;
		}
		
		if ((isEditEndDate && isEditEndTime) || 
				(isEditEndDateOccurrence && isEditEndTimeOccurrence)) {
			newEndDateTime  = LocalDateTime.of(editEndDate, editEndTime);
		} else if ((isEditEndDate && !isEditEndTime) || 
				(isEditEndDateOccurrence && !isEditEndTimeOccurrence)) {
			newEndDateTime = LocalDateTime.of(editEndDate, currentEndDateTime.toLocalTime());
		} else if ((!isEditEndDate && isEditEndTime) || 
				(!isEditEndDateOccurrence && isEditEndTimeOccurrence)) {
			newEndDateTime = LocalDateTime.of(currentEndDateTime.toLocalDate(), editEndTime);
		} else {
			newEndDateTime = currentEndDateTime;
		}
		
		if (newStartDateTime.isAfter(newEndDateTime)) {
			isEditStartDate = false;
			isEditStartTime = false;
			isEditEndDate = false;
			isEditEndTime = false;
			isEditStartDateOccurrence = false;
			isEditStartTimeOccurrence = false;
			isEditEndDateOccurrence = false;
			isEditEndTimeOccurrence = false;
			throw new EditException(LocalDateTime.MAX);
		}
		
	}
	
	/*
	 * Compares the categories of the task to be edited and the edit data. If the edit data category is not
	 * empty, then this edit is an undo function. If it is an undo function, the date and times should be
	 * edited depending if the previous event (i.e. editTask) is a floating task or a deadline. This special
	 * check has to be implemented because by default, the boolean checks would be set to false if the edit
	 * value is MAX, which is the case if the previous event is a floating/deadline.
	 */
	private void compareOldAndNewCategory(TaskObject task) {
		String currentTaskCategory = task.getCategory();
		String editTaskCategory = commandObj.getTaskObject().getCategory();
		
		// if this edit is an undo
		if (!editTaskCategory.equals("")) {
			if (currentTaskCategory.equals(CATEGORY_DEADLINE) && 
					(editTaskCategory.equals(CATEGORY_FLOATING) || 
							editTaskCategory.equals(CATEGORY_DEADLINE))) {
				isEditStartDate = true;
				isEditStartTime = true;
				logger.log(Level.INFO, "Setting editStartDate and editStartTime to true");
			} else if (currentTaskCategory.equals(CATEGORY_EVENT) && 
					editTaskCategory.equals(CATEGORY_FLOATING)) {
				isEditStartDate = true;
				isEditStartTime = true;
				isEditEndDate = true;
				isEditEndTime = true;
				logger.log(Level.INFO, "Setting editStartDate, editStartTime, editEndDate and editEndTime to true");
			} else if (currentTaskCategory.equals(CATEGORY_EVENT) &&
					editTaskCategory.equals(CATEGORY_DEADLINE)) {
				isEditEndDate = true;
				isEditEndTime = true;
				logger.log(Level.INFO, "Setting editEndDate and editEndTime to true");
			}
		}
	}

	private void updateBooleanChecksForEditOccurrence() {
		if (isEditStartDate) {
			isEditStartDate = false;
			isEditStartDateOccurrence = true;
		}
		if (isEditStartTime) {
			isEditStartTime = false;
			isEditStartTimeOccurrence = true;
		}
		if (isEditEndDate) {
			isEditEndDate = false;
			isEditEndDateOccurrence = true;
		}
		if (isEditEndTime) {
			isEditEndTime = false;
			isEditEndTimeOccurrence = true;
		}
	}

	private void setOriginalStartAndEndDateAndTime(LocalDateTimePair timing) {
		originalStartDate = timing.getStartDateTime().toLocalDate();
		originalStartTime = timing.getStartDateTime().toLocalTime();
		originalEndDate = timing.getEndDateTime().toLocalDate();
		originalEndTime = timing.getEndDateTime().toLocalTime();
	}
	
	private void setEditStartAndEndDateAndTime(LocalDateTimePair editTiming) {
		editStartDate = editTiming.getStartDateTime().toLocalDate();
		editStartTime = editTiming.getStartDateTime().toLocalTime();
		editEndDate = editTiming.getEndDateTime().toLocalDate();
		editEndTime = editTiming.getEndDateTime().toLocalTime();
	}
	
	private void setOriginalStartDateAndTime(TaskObject task) {
		originalStartDate = task.getStartDateTime().toLocalDate();
		originalStartTime = task.getStartDateTime().toLocalTime();
	}
	
	private void setOriginalEndDateAndTime(TaskObject task) {
		originalEndDate = task.getEndDateTime().toLocalDate();
		originalEndTime = task.getEndDateTime().toLocalTime();
	}

	// Updates the category of the task in case it has been modified
	private void updateCategory() {
		LocalDateTime newStartDateTime = editTask.getStartDateTime();
		LocalDateTime newEndDateTime = editTask.getEndDateTime();

		if (newStartDateTime.equals(LocalDateTime.MAX) && newEndDateTime.equals(LocalDateTime.MAX)) {
			editTask.setCategory(CATEGORY_FLOATING);
			if (editTask.getStatus().equals(STATUS_OVERDUE)) { // for corner cases - floating task cannot be overdue
				editTask.setStatus(STATUS_INCOMPLETE);
			}
			logger.log(Level.INFO, "Updating category to floating");
		} else if (newEndDateTime.equals(LocalDateTime.MAX)) {
			editTask.setCategory(CATEGORY_DEADLINE);
			logger.log(Level.INFO, "Updating category to deadline");
		} else {
			editTask.setCategory(CATEGORY_EVENT);
			logger.log(Level.INFO, "Updating category to event");
		}
	}

	// Saves the updated file to Storage
	private void saveExternal() {
		try {
			IStorage storage = FileStorage.getInstance();
			storage.save(taskList);
			logger.log(Level.INFO, "Storage file updated");
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	private void updateGuiDisplay() {
		TimeOutput.setTaskTimeOutput(editTask);
	}

	/* FOR DEBUGGING
	private void checkEditInformation() {
		System.out.println("isEditTitle = " + isEditTitle);
		System.out.println("isEditStartDate = " + isEditStartDate);
		System.out.println("isEditStartTime = " + isEditStartTime);
		System.out.println("isEditStartTimeForAllOccurrences = " + isEditStartTimeForAllOccurrences);
		System.out.println("isEditEndDate = " + isEditEndDate);
		System.out.println("isEditEndTime = " + isEditEndTime);
		System.out.println("isEditEndTimeForAllOccurrences = " + isEditEndTimeForAllOccurrences);
		System.out.println("isEditInterval = " + isEditInterval);
		System.out.println("isRecurringTask = " + isRecurringTask);
		System.out.println("isEditAll = " + isEditAll);
		System.out.println("isEditSingleOccurrence = " + isEditSingleOccurrence);
	}*/

	// ------------------------- OUTPUT MESSAGES -------------------------

	/*
	 * The Deadline check is because output for deadlines is slightly different, as they should not have
	 * start/end dates/times. If the original date/time is equal to MAX value, then there was no previous
	 * date/time so the output should be 'added' instead of 'edited'.
	 */
	private void setOutput() {
		logger.log(Level.INFO, "Setting edit output");
		//checkEditInformation();

		if (!isEditSingleOccurrence) {
			if (isEditTitle) {
				outputTitleEditedMessage();
			}
			if (isEditStartDate) {
				if (isEditStartDateForAllOccurrences) {
					if (editTask.getCategory().equals(CATEGORY_DEADLINE)) {
						if (originalStartDate.equals(LocalDate.MAX)) {
							outputDateAddedForAllOccurrencesMessage();
						} else {
							outputDateEditedForAllOccurrencesMessage();
						}
					} else {
						if (originalStartDate.equals(LocalDate.MAX)) {
							outputStartDateAddedForAllOccurrencesMessage();
						} else {
							outputStartDateEditedForAllOccurrencesMessage();
						}
					}
				} else {
					if (editTask.getCategory().equals(CATEGORY_DEADLINE)) {
						if (originalStartDate.equals(LocalDate.MAX)) {
							outputDateAddedMessage();
						} else {
							outputDateEditedMessage();
						}
					} else {
						if (originalStartDate.equals(LocalDate.MAX)) {
							outputStartDateAddedMessage();
						} else {
							outputStartDateEditedMessage();
						}
					}
				}
			}
			if (isEditStartTime) {
				if (isEditStartTimeForAllOccurrences) {
					if (editTask.getCategory().equals(CATEGORY_DEADLINE)) {
						if (originalStartTime.equals(LocalTime.MAX)) { 
							outputTimeAddedForAllOccurrencesMessage();
						} else {
							outputTimeEditedForAllOccurrencesMessage();
						}
					} else {
						if (originalStartTime.equals(LocalTime.MAX)) { 
							outputStartTimeAddedForAllOccurrencesMessage();
						} else {
							outputStartTimeEditedForAllOccurrencesMessage();
						}
					}
				} else {
					if (editTask.getCategory().equals(CATEGORY_DEADLINE)) {
						if (originalStartTime.equals(LocalTime.MAX)) {
							outputTimeAddedMessage();
						} else {
							outputTimeEditedMessage();
						}
					} else {
						if (originalStartTime.equals(LocalTime.MAX)) {
							outputStartTimeAddedMessage();
						} else {
							outputStartTimeEditedMessage();
						}
					}
				}
			}
			if (isEditEndDate) {
				if (isEditEndDateForAllOccurrences) {
					if (originalEndDate.equals(LocalDate.MAX)) {
						outputEndDateAddedForAllOccurrencesMessage();
					} else {
						outputEndDateEditedForAllOccurrencesMessage();
					}
				} else {
					if (originalEndDate.equals(LocalDate.MAX)) {
						outputEndDateAddedMessage();
					} else {
						outputEndDateEditedMessage();
					}
				}
			}
			if (isEditEndTime) {
				if (isEditEndTimeForAllOccurrences) {
					if (originalEndTime.equals(LocalTime.MAX)) {
						outputEndTimeAddedForAllOccurrencesMessage();
					} else {
						outputEndTimeEditedForAllOccurrencesMessage();
					}
				} else {
					if (originalEndTime.equals(LocalTime.MAX)) {
						outputEndTimeAddedMessage();
					} else {
						outputEndTimeEditedMessage();
					}
				}
			}
			if (isEditInterval) {
				outputIntervalEditedMessage();
			}
		} else { // Output for editing of a single occurrence
			if (isEditStartDateOccurrence) {
				if (editTask.getCategory().equals(CATEGORY_DEADLINE)) {
					if (originalStartDate.equals(LocalDate.MAX)) {
						outputDateAddedForOccurrenceMessage();
					} else {
						outputDateEditedForOccurrenceMessage();
					}
				} else {
					if (originalStartDate.equals(LocalDate.MAX)) {
						outputStartDateAddedForOccurrenceMessage();
					} else {
						outputStartDateEditedForOccurrenceMessage();
					}
				}
			}
			if (isEditStartTimeOccurrence) {
				if (editTask.getCategory().equals(CATEGORY_DEADLINE)) {
					if (originalStartTime.equals(LocalTime.MAX)) {
						outputTimeAddedForOccurrenceMessage();
					} else {
						outputTimeEditedForOccurrenceMessage();
					}
				} else {
					if (originalStartTime.equals(LocalTime.MAX)) {
						outputStartTimeAddedForOccurrenceMessage();
					} else {
						outputStartTimeEditedForOccurrenceMessage();
					}
				}
			}
			if (isEditEndDateOccurrence) {
				if (originalEndDate.equals(LocalDate.MAX)) {
					outputEndDateAddedForOccurrenceMessage();
				} else {
					outputEndDateEditedForOccurrenceMessage();
				}
			}
			if (isEditEndTimeOccurrence) {
				if (originalEndTime.equals(LocalTime.MAX)) {
					outputEndTimeOccurrenceAddedMessage();
				} else {
					outputEndTimeOccurrenceEditedMessage();
				}
			}
		}

		concatenateOutput();
	}

	private void outputTitleEditedMessage() {
		tempOutput.add(String.format(MESSAGE_TITLE_EDIT, originalTitle, editTitle));
	}

	// DATE
	private void outputDateAddedMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_ADD, editStartDate, editTask.getTitle()));
	}

	private void outputDateEditedMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_EDIT, originalStartDate, editStartDate));
	}
	
	private void outputDateAddedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_FOR_OCCURRENCE_ADD, editStartDate, editOccurrenceIndex));
	}
	
	private void outputDateEditedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_FOR_OCCURRENCE_EDIT, editOccurrenceIndex,
				originalStartDate, editStartDate));
	}

	private void outputDateAddedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_FOR_ALL_OCCURRENCES_ADD, editStartDate));
	}
	
	private void outputDateEditedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_FOR_ALL_OCCURRENCES_EDIT, editStartDate));
	}
	
	// TIME
	private void outputTimeAddedMessage() {
		tempOutput.add(String.format(MESSAGE_TIME_ADD, editStartTime, editTask.getTitle()));
	}
	
	private void outputTimeEditedMessage() {
		tempOutput.add(String.format(MESSAGE_TIME_EDIT, originalStartTime, editStartTime));
	}

	private void outputTimeAddedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_TIME_FOR_OCCURRENCE_ADD, editStartTime, editOccurrenceIndex));
	}
	
	private void outputTimeEditedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_DATE_FOR_OCCURRENCE_EDIT, editOccurrenceIndex,
				originalStartTime, editStartTime));
	}

	private void outputTimeAddedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_TIME_FOR_ALL_OCCURRENCES_ADD, editStartTime));
	}
	
	private void outputTimeEditedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_TIME_FOR_ALL_OCCURRENCES_EDIT, editStartTime));
	}

	// START DATE
	private void outputStartDateAddedMessage() {
		tempOutput.add(String.format(MESSAGE_START_DATE_ADD, editStartDate, editTask.getTitle()));
	}

	private void outputStartDateEditedMessage() {
		tempOutput.add(String.format(MESSAGE_START_DATE_EDIT, originalStartDate, editStartDate));
	}
	
	private void outputStartDateAddedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_START_DATE_FOR_OCCURRENCE_ADD, editStartDate, 
				editOccurrenceIndex));
	}
	
	private void outputStartDateEditedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_START_DATE_FOR_OCCURRENCE_EDIT, editOccurrenceIndex,
				originalStartDate, editStartDate));
	}
	
	private void outputStartDateAddedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_START_DATE_FOR_ALL_OCCURRENCES_ADD, editStartDate));
	}

	private void outputStartDateEditedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_START_DATE_FOR_ALL_OCCURRENCES_EDIT, editStartDate));
	}

	// START TIME
	private void outputStartTimeAddedMessage() {
		tempOutput.add(String.format(MESSAGE_START_TIME_ADD, editStartTime, editTask.getTitle()));
	}

	private void outputStartTimeEditedMessage() {
		tempOutput.add(String.format(MESSAGE_START_TIME_EDIT, originalStartTime, editStartTime));
	}

	private void outputStartTimeAddedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_START_TIME_FOR_OCCURRENCE_ADD, editStartTime,
				editOccurrenceIndex));
	}
	
	private void outputStartTimeEditedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_START_TIME_FOR_OCCURRENCE_EDIT, editOccurrenceIndex,
				originalStartTime, editStartTime));
	}

	private void outputStartTimeAddedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_START_TIME_FOR_ALL_OCCURRENCES_ADD, editStartTime));
	}

	private void outputStartTimeEditedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_START_TIME_FOR_ALL_OCCURRENCES_EDIT, editStartTime));
	}

	// END DATE
	private void outputEndDateAddedMessage() {
		tempOutput.add(String.format(MESSAGE_END_DATE_ADD, editEndDate, editTask.getTitle()));
	}

	private void outputEndDateEditedMessage() {
		tempOutput.add(String.format(MESSAGE_END_DATE_EDIT, originalEndDate, editEndDate));
	}

	private void outputEndDateAddedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_END_DATE_FOR_OCCURRENCE_ADD, editEndDate,
				editOccurrenceIndex));
	}
	
	private void outputEndDateEditedForOccurrenceMessage() {
		tempOutput.add(String.format(MESSAGE_END_DATE_FOR_OCCURRENCE_EDIT, editOccurrenceIndex,
				originalEndDate, editEndDate));
	}

	private void outputEndDateAddedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_END_DATE_FOR_ALL_OCCURRENCES_ADD, editEndDate));
	}
	
	private void outputEndDateEditedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_END_DATE_FOR_ALL_OCCURRENCES_EDIT, editEndDate));
	}

	// END TIME
	private void outputEndTimeAddedMessage() {
		tempOutput.add(String.format(MESSAGE_END_TIME_ADD, editEndTime, editTask.getTitle()));
	}

	private void outputEndTimeEditedMessage() {
		tempOutput.add(String.format(MESSAGE_END_TIME_EDIT, originalEndTime, editEndTime));
	}

	private void outputEndTimeOccurrenceAddedMessage() {
		tempOutput.add(String.format(MESSAGE_END_TIME_FOR_OCCURRENCE_ADD, editEndTime,
				editOccurrenceIndex));
	}
	
	private void outputEndTimeOccurrenceEditedMessage() {
		tempOutput.add(String.format(MESSAGE_END_TIME_FOR_OCCURRENCE_EDIT, editOccurrenceIndex,
				originalEndTime, editEndTime));
	}

	private void outputEndTimeAddedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_END_TIME_FOR_ALL_OCCURRENCES_ADD, editEndTime));
	}
	
	private void outputEndTimeEditedForAllOccurrencesMessage() {
		tempOutput.add(String.format(MESSAGE_END_TIME_FOR_ALL_OCCURRENCES_EDIT, editEndTime));
	}

	private void outputIntervalEditedMessage() {
		tempOutput.add(MESSAGE_INTERVAL_EDIT);
	}

	// Combines all the output strings into 1 string
	private void concatenateOutput() {
		if (tempOutput.isEmpty()) {
			output.add(MESSAGE_NO_EDIT);
		} else {
			String concatOutput = "";
			for (int i = 0; i < tempOutput.size(); i++) {
				concatOutput = concatOutput.concat(tempOutput.get(i));
				if (i != tempOutput.size() - 1) {
					concatOutput = concatOutput.concat("\n");
				}
			}

			output.add(concatOutput.trim());
		}
	}

	// ------------------------- GETTERS -------------------------

	public TaskObject getOriginalTask() {
		return originalTask;
	}

	public TaskObject getEditTask() {
		return editTask;
	}

	public int getEditTaskIndex() {
		return editTaskIndex;
	}

	public int getEditOccurrenceIndex() {
		return editOccurrenceIndex;
	}

	public String getOriginalTitle() {
		return originalTitle;
	}

	public LocalDateTime getOriginalStartDateTime() {
		return originalStartDateTime;
	}

	public LocalDateTime getOriginalEndDateTime() {
		return originalEndDateTime;
	}

	public Interval getOriginalInterval() {
		return originalInterval;
	}

	public boolean getIsEditTitle() {
		return isEditTitle;
	}

	public boolean getIsEditStartDateAndTime() {
		return isEditStartDate || isEditStartTime;
	}

	public boolean getIsEditStartDate() {
		return isEditStartDate;
	}

	public boolean getIsEditStartTime() {
		return isEditStartTime;
	}

	public boolean getIsEditEndDateAndTime() {
		return isEditEndDate || isEditEndTime;
	}

	public boolean getIsEditEndDate() {
		return isEditEndDate;
	}

	public boolean getIsEditEndTime() {
		return isEditEndTime;
	}

	public boolean getIsEditAll() {
		return isEditAll;
	}

	public boolean getIsEditSingleOccurrence() {
		return isEditSingleOccurrence;
	}

	public boolean getIsExceptionThrown() {
		return isExceptionThrown;
	}
	
}
```
###### \src\logic\edit\EditTest.java
``` java

package logic.edit;
import static org.junit.Assert.*;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import common.CommandObject;
import common.LocalDateTimePair;
import common.TaskObject;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class EditTest {
	
	private static ArrayList<TaskObject> testList = new ArrayList<TaskObject> ();
	private static ArrayList<String> actualOutput = new ArrayList<String>();
	private static ArrayList<String> correctOutput = new ArrayList<String>();
	private ArrayList<LocalDateTimePair> testTimings = new ArrayList<LocalDateTimePair>();
	private ArrayList<LocalDateTimePair> testTimingsTwo = new ArrayList<LocalDateTimePair>();
	
	private CommandObject testCommandObject;
	private TaskObject testTaskObject;
	
	// Test tasks
	TaskObject one = new TaskObject("Study hard for finals", 
			LocalDateTime.of(LocalDate.parse("2016-05-25"), LocalTime.parse("09:00")), 
			"deadline", "incomplete", 1);
	TaskObject two = new TaskObject("Find internship in Germany", 
			LocalDateTime.of(LocalDate.parse("2016-12-31"), LocalTime.parse("23:59")),
			"deadline", "incomplete", 2);
	TaskObject three = new TaskObject("Travel Eastern Europe", "floating", "incomplete", 3);
	TaskObject four = new TaskObject("CS2106 lecture", 
			LocalDateTime.of(LocalDate.parse("2016-12-01"), LocalTime.parse("14:00")),
			LocalDateTime.of(LocalDate.parse("2017-05-04"), LocalTime.parse("16:00")), 
			"event", "incomplete", 4);
	TaskObject five = new TaskObject("CS2103 v0.2", 
			LocalDateTime.of(LocalDate.parse("2017-03-24"), LocalTime.parse("19:00")), 
			"deadline", "incomplete", 5);
	TaskObject six = new TaskObject("SSS1207 CA2", 
			LocalDateTime.of(LocalDate.parse("2016-03-31"), LocalTime.parse("23:59")), 
			"deadline", "incomplete", 6);
	TaskObject seven = new TaskObject("Spring break", 
			LocalDateTime.of(LocalDate.parse("2001-01-11"), LocalTime.parse("00:00")),
			LocalDateTime.of(LocalDate.parse("2016-05-06"), LocalTime.parse("23:59")), 
			"event", "incomplete", 7);
	TaskObject eight = new TaskObject("Overseas paradise", 
			LocalDateTime.of(LocalDate.parse("2012-01-31"), LocalTime.parse("22:24")), 
			LocalDateTime.of(LocalDate.parse("2013-11-29"), LocalTime.parse("17:00")), 
			"event", "complete", 8);
	TaskObject nine = new TaskObject("Hiking trip", 
			LocalDateTime.of(LocalDate.parse("2014-07-11"), LocalTime.parse("16:00")), 
			LocalDateTime.of(LocalDate.parse("2016-07-15"), LocalTime.parse("17:00")), 
			"event", "incomplete", 9);
	TaskObject ten = new TaskObject("Confinement", 
			LocalDateTime.of(LocalDate.parse("2012-02-14"), LocalTime.parse("08:00")),
			LocalDateTime.of(LocalDate.parse("2012-02-21"), LocalTime.parse("12:00")), 
			"event", "incomplete", 10);
	TaskObject eleven = new TaskObject("CS2107 presentation", "floating", "incomplete", 11);
	TaskObject twelve = new TaskObject("Europe trip", "floating", "incomplete", 12);
	
	@Test // Populate the task list
	public void populate() {
		
		// To populate the taskDateTimes array based on the start and end date time
		one.addToTaskDateTimes();
		two.addToTaskDateTimes();
		three.addToTaskDateTimes();
		four.addToTaskDateTimes();
		five.addToTaskDateTimes();
		six.addToTaskDateTimes();
		seven.addToTaskDateTimes();
		eight.addToTaskDateTimes();
		nine.addToTaskDateTimes();
		ten.addToTaskDateTimes();
		eleven.addToTaskDateTimes();
		twelve.addToTaskDateTimes();
		
		testList.add(one);
		testList.add(two);
		testList.add(three);
		testList.add(four);
		testList.add(five);
		testList.add(six);
		testList.add(seven);
		testList.add(eight);
		testList.add(nine);
		testList.add(ten);
		// Tests for editing between categories
		testList.add(eleven);
		testList.add(twelve);
		
		// Tests for editing recurrence events
		LocalDateTime startOne = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("16:00"));
		LocalDateTime endOne = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("18:00"));
		LocalDateTime startTwo = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("16:00"));
		LocalDateTime endTwo = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("18:00"));
		LocalDateTime startThree = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("16:00"));
		LocalDateTime endThree = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("18:00"));
		LocalDateTime startFour = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("16:00"));
		LocalDateTime endFour = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("18:00"));
		testTimings.add(new LocalDateTimePair(startOne, endOne));
		testTimings.add(new LocalDateTimePair(startTwo, endTwo));
		testTimings.add(new LocalDateTimePair(startThree, endThree));
		testTimings.add(new LocalDateTimePair(startFour, endFour));
		
		testList.add(new TaskObject("CS2103 lecture", startOne, endOne, "event", "incomplete", 13, true, testTimings));
		testList.add(new TaskObject("CS2103 lecture", startOne, endOne, "event", "incomplete", 14, true, testTimings));
		testList.add(new TaskObject("CS2103 lecture", startOne, endOne, "event", "incomplete", 15, true, testTimings));

		LocalDateTime startFive = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("21:00"));
		LocalDateTime endFive = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("23:00"));
		LocalDateTime startSix = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("21:00"));
		LocalDateTime endSix = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("23:00"));
		LocalDateTime startSeven = LocalDateTime.of(LocalDate.parse("2016-04-22"), LocalTime.parse("21:00"));
		LocalDateTime endSeven = LocalDateTime.of(LocalDate.parse("2016-04-22"), LocalTime.parse("23:00"));
		testTimingsTwo.clear();
		testTimingsTwo.add(new LocalDateTimePair(startFive, endFive));
		testTimingsTwo.add(new LocalDateTimePair(startSix, endSix));
		testTimingsTwo.add(new LocalDateTimePair(startSeven, endSeven));
		
		testList.add(new TaskObject("Soccer match", startFive, endFive, "event", "incomplete", 16, true, testTimingsTwo));
		testList.add(new TaskObject("Soccer match", startFive, endFive, "event", "incomplete", 17, true, testTimingsTwo));
		testList.add(new TaskObject("Soccer match", startFive, endFive, "event", "incomplete", 18, true, testTimingsTwo));
		testList.add(new TaskObject("Soccer match", startFive, endFive, "event", "incomplete", 19, true, testTimingsTwo));
		
	}
	
	
	@Test // Test edit for title + start date + start time
	public void testA() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-07-11"), LocalTime.parse("10:00"));
		testTaskObject = new TaskObject("Reservist", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 9);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Title edited from 'Hiking trip' to 'Reservist'. \n"
				+ "Start date edited from '2014-07-11' to '2016-07-11'. \n"
				+ "Start time edited from '16:00' to '10:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}

	@Test // Test edit for start date + start time
	public void testB() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-03-24"), LocalTime.parse("11:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 5);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Date edited from '2017-03-24' to '2016-03-24'. \n"
				+ "Time edited from '19:00' to '11:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for start date + start time, but with same old and new start date, so only start time should be edited
	public void testC() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-12-31"), LocalTime.parse("18:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 2);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Time edited from '23:59' to '18:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	
	@Test // Test edit for start date + start time, but with same old and new start time, so only start date should be edited
	public void testD() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-04-25"), LocalTime.parse("09:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 1);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Date edited from '2016-05-25' to '2016-04-25'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for start date + end date
	public void testE() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.MAX);
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.MAX);
		testTaskObject = new TaskObject("", testStartDateTime, testEndDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 4);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Start date edited from '2016-12-01' to '2016-04-01'. \n"
				+ "End date edited from '2017-05-04' to '2016-04-01'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for start time
	public void testF() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.MAX, LocalTime.parse("16:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 6);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Time edited from '23:59' to '16:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for title + start time
	public void testG() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.MAX, LocalTime.parse("10:00"));
		testTaskObject = new TaskObject("Army", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 8);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Title edited from 'Overseas paradise' to 'Army'. \n"
				+ "Start time edited from '22:24' to '10:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for title
	public void testH() {
		testTaskObject = new TaskObject("Travel Eastern Europe and Iceland", "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 3);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Title edited from 'Travel Eastern Europe' to 'Travel Eastern Europe and Iceland'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for title + start date
	public void testI() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-01-11"), LocalTime.MAX);
		testTaskObject = new TaskObject("AY2016/17 Sem 2", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 7);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Title edited from 'Spring break' to 'AY2016/17 Sem 2'. \n"
				+ "Start date edited from '2001-01-11' to '2016-01-11'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for title + start date + start time + end date + end time
	public void testJ() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-01-05"), LocalTime.parse("14:00"));
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2016-01-09"), LocalTime.parse("13:00"));
		testTaskObject = new TaskObject("HK trip", testStartDateTime, testEndDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 10);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Title edited from 'Confinement' to 'HK trip'. \n"
				+ "Start date edited from '2012-02-14' to '2016-01-05'. \n" 
				+ "Start time edited from '08:00' to '14:00'. \n"
				+ "End date edited from '2012-02-21' to '2016-01-09'. \n"
				+ "End time edited from '12:00' to '13:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for modifying floating -> deadline - adding a start date and time
	public void testK() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-04-18"), LocalTime.parse("09:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 11);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Added date '2016-04-18' to task 'CS2107 presentation'. \n"
				+ "Added time '09:00' to task 'CS2107 presentation'.");
		
		String actualCategory = testEdit.getEditTask().getCategory();
		String correctCategory = "deadline";
		
		assertEquals(actualCategory, correctCategory);
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
	
	@Test // Test edit for modifying floating -> event - adding a start & end date and time
	public void testL() {
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-06-18"), LocalTime.parse("10:00"));
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2016-08-08"), LocalTime.parse("20:00"));
		testTaskObject = new TaskObject("", testStartDateTime, testEndDateTime, "", "", -1);		
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 12);
				
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Added start date '2016-06-18' to task 'Europe trip'. \n"
				+ "Added start time '10:00' to task 'Europe trip'. \n"
				+ "Added end date '2016-08-08' to task 'Europe trip'. \n"
				+ "Added end time '20:00' to task 'Europe trip'.");
		
		String actualCategory = testEdit.getEditTask().getCategory();
		String correctCategory = CATEGORY_EVENT;
		
		assertEquals(actualCategory, correctCategory);
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();

		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 12);
		
	}
	
	@Test // Test edit for recurrence event - edit start date of first occurrence
	public void testM() {
		// 1st assert - check output
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-03-24"), LocalTime.MAX);
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 13);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("Start date edited from '2016-03-25' to '2016-03-24'.");

		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings; only the first date should be modified
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTiming = actualTimings.get(0).getStartDateTime();
		LocalDateTime correctFirstTiming = LocalDateTime.of(LocalDate.parse("2016-03-24"), LocalTime.parse("16:00"));
		LocalDateTime actualSecondTiming = actualTimings.get(1).getStartDateTime();
		LocalDateTime correctSecondTiming = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("16:00"));
		LocalDateTime actualThirdTiming = actualTimings.get(2).getStartDateTime();
		LocalDateTime correctThirdTiming = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("16:00"));
		LocalDateTime actualFourthTiming = actualTimings.get(3).getStartDateTime();
		LocalDateTime correctFourthTiming = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("16:00"));
		
		assertEquals(actualFirstTiming, correctFirstTiming);
		assertEquals(actualSecondTiming, correctSecondTiming);
		assertEquals(actualThirdTiming, correctThirdTiming);
		assertEquals(actualFourthTiming, correctFourthTiming);
	}
	
	
	@Test // Test edit for recurrence event - edit start times for all occurrences
	public void testN() {
		// 1st assert - check output
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.MAX, LocalTime.parse("14:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1, true, new ArrayList<LocalDateTimePair>());
		testTaskObject.setIsEditAll(true);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 14);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("All start times edited to '14:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTiming = actualTimings.get(0).getStartDateTime();
		LocalDateTime correctFirstTiming = LocalDateTime.of(LocalDate.parse("2016-03-24"), LocalTime.parse("14:00"));
		LocalDateTime actualSecondTiming = actualTimings.get(1).getStartDateTime();
		LocalDateTime correctSecondTiming = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("14:00"));
		LocalDateTime actualThirdTiming = actualTimings.get(2).getStartDateTime();
		LocalDateTime correctThirdTiming = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("14:00"));
		LocalDateTime actualFourthTiming = actualTimings.get(3).getStartDateTime();
		LocalDateTime correctFourthTiming = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("14:00"));
		
		assertEquals(actualFirstTiming, correctFirstTiming);
		assertEquals(actualSecondTiming, correctSecondTiming);
		assertEquals(actualThirdTiming, correctThirdTiming);
		assertEquals(actualFourthTiming, correctFourthTiming);
		
	}
	
	@Test // Test edit for recurrence event - edit end time for 1 occurrence
	public void testO() {
		// 1st assert - check output
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.MAX, LocalTime.parse("23:59"));
		testTaskObject = new TaskObject("", LocalDateTime.MAX, testEndDateTime, "", "", -1);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 15);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("End time edited from '18:00' to '23:59'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTiming = actualTimings.get(0).getEndDateTime();
		LocalDateTime correctFirstTiming = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("23:59"));
		LocalDateTime actualSecondTiming = actualTimings.get(1).getEndDateTime();
		LocalDateTime correctSecondTiming = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("18:00"));
		LocalDateTime actualThirdTiming = actualTimings.get(2).getEndDateTime();
		LocalDateTime correctThirdTiming = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("18:00"));
		LocalDateTime actualFourthTiming = actualTimings.get(3).getEndDateTime();
		LocalDateTime correctFourthTiming = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("18:00"));
		
		assertEquals(actualFirstTiming, correctFirstTiming);
		assertEquals(actualSecondTiming, correctSecondTiming);
		assertEquals(actualThirdTiming, correctThirdTiming);
		assertEquals(actualFourthTiming, correctFourthTiming);
		
	}
	
	@Test // Test edit for recurrence event - edit end time for all occurrences
	public void testP() {
		// 1st assert - check output
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.MAX, LocalTime.parse("23:59"));
		testTaskObject = new TaskObject("", LocalDateTime.MAX, testEndDateTime, "", "", -1, true, new ArrayList<>()); // BOOLEAN FLAG SET TO TRUE
		testTaskObject.setIsEditAll(true);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 15);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("All end times edited to '23:59'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTiming = actualTimings.get(0).getEndDateTime();
		LocalDateTime correctFirstTiming = LocalDateTime.of(LocalDate.parse("2016-03-25"), LocalTime.parse("23:59"));
		LocalDateTime actualSecondTiming = actualTimings.get(1).getEndDateTime();
		LocalDateTime correctSecondTiming = LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("23:59"));
		LocalDateTime actualThirdTiming = actualTimings.get(2).getEndDateTime();
		LocalDateTime correctThirdTiming = LocalDateTime.of(LocalDate.parse("2016-04-08"), LocalTime.parse("23:59"));
		LocalDateTime actualFourthTiming = actualTimings.get(3).getEndDateTime();
		LocalDateTime correctFourthTiming = LocalDateTime.of(LocalDate.parse("2016-04-15"), LocalTime.parse("23:59"));
		
		assertEquals(actualFirstTiming, correctFirstTiming);
		assertEquals(actualSecondTiming, correctSecondTiming);
		assertEquals(actualThirdTiming, correctThirdTiming);
		assertEquals(actualFourthTiming, correctFourthTiming);
		
	}
	
	@Test // // Test edit for recurrence event - edit start date and time for all occurrences
	public void testQ() {
		// 1st assert - check output
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2016-03-31"), LocalTime.parse("08:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1, true, new ArrayList<>()); // BOOLEAN FLAG SET TO TRUE
		testTaskObject.setIsEditAll(true);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 16);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("All start dates edited to '2016-03-31'. \n"
				+ "All start times edited to '08:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTiming = actualTimings.get(0).getStartDateTime();
		LocalDateTime actualSecondTiming = actualTimings.get(1).getStartDateTime();
		LocalDateTime actualThirdTiming = actualTimings.get(2).getStartDateTime();
		LocalDateTime correctTiming = LocalDateTime.of(LocalDate.parse("2016-03-31"), LocalTime.parse("08:00"));
		
		assertEquals(actualFirstTiming, correctTiming);
		assertEquals(actualSecondTiming, correctTiming);
		assertEquals(actualThirdTiming, correctTiming);
		
	}
	
	@Test // Test edit for recurrence event - edit end date and time for all occurrences
	public void testR() {
		// 1st assert - check output
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2016-12-31"), LocalTime.parse("22:22"));
		testTaskObject = new TaskObject("", LocalDateTime.MAX, testEndDateTime, "", "", -1, true, new ArrayList<>()); // BOOLEAN FLAG SET TO TRUE
		testTaskObject.setIsEditAll(true);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 17);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("All end dates edited to '2016-12-31'. \n"
				+ "All end times edited to '22:22'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTiming = actualTimings.get(0).getEndDateTime();
		LocalDateTime actualSecondTiming = actualTimings.get(1).getEndDateTime();
		LocalDateTime actualThirdTiming = actualTimings.get(2).getEndDateTime();
		LocalDateTime correctTiming = LocalDateTime.of(LocalDate.parse("2016-12-31"), LocalTime.parse("22:22"));
		
		assertEquals(actualFirstTiming, correctTiming);
		assertEquals(actualSecondTiming, correctTiming);
		assertEquals(actualThirdTiming, correctTiming);
		
	}
	
	@Test // Test edit for recurrence event - edit start date and end date for all occurrences
	public void testS() {
		// 1st assert - check output
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2011-11-11"), LocalTime.MAX);
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2011-11-11"), LocalTime.MAX);
		testTaskObject = new TaskObject("", testStartDateTime, testEndDateTime, "", "", -1, true, new ArrayList<>()); // BOOLEAN FLAG SET TO TRUE
		testTaskObject.setIsEditAll(true);
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 18);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, -1);
		actualOutput = testEdit.run();
		correctOutput.add("All start dates edited to '2011-11-11'. \n"
				+ "All end dates edited to '2011-11-11'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTimingStart = actualTimings.get(0).getStartDateTime();
		LocalDateTime actualFirstTimingEnd = actualTimings.get(0).getEndDateTime();
		LocalDateTime actualSecondTimingStart = actualTimings.get(1).getStartDateTime();
		LocalDateTime actualSecondTimingEnd = actualTimings.get(1).getEndDateTime();
		LocalDateTime actualThirdTimingStart = actualTimings.get(2).getStartDateTime();
		LocalDateTime actualThirdTimingEnd = actualTimings.get(2).getEndDateTime();
		LocalDateTime correctTimingStart = LocalDateTime.of(LocalDate.parse("2011-11-11"), LocalTime.parse("08:00"));
		LocalDateTime correctTimingEnd = LocalDateTime.of(LocalDate.parse("2011-11-11"), LocalTime.parse("22:22"));

		assertEquals(actualFirstTimingStart, correctTimingStart);
		assertEquals(actualFirstTimingEnd, correctTimingEnd);
		assertEquals(actualSecondTimingStart, correctTimingStart);
		assertEquals(actualSecondTimingEnd, correctTimingEnd);
		assertEquals(actualThirdTimingStart, correctTimingStart);
		assertEquals(actualThirdTimingEnd, correctTimingEnd);
		
	}
	
	@Test // Test edit for single occurrence - edit start date and time of 2nd occurrence
	public void testTA() {
		// 1st assert - check output
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2007-12-01"), LocalTime.parse("09:00"));
		testTaskObject = new TaskObject("", testStartDateTime, "", "", -1, false, new ArrayList<>());
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 2);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, 19);
		actualOutput = testEdit.run();
		correctOutput.add("Start date of occurrence 2 edited from '2011-11-11' to '2007-12-01'. \n" 
				+ "Start time of occurrence 2 edited from '08:00' to '09:00'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualSecondTimingStart = actualTimings.get(1).getStartDateTime();
		LocalDateTime correctSecondTimingStart = LocalDateTime.of(LocalDate.parse("2007-12-01"), LocalTime.parse("09:00"));
		
		assertEquals(actualSecondTimingStart, correctSecondTimingStart);
	}
	
	@Test // Test edit for single occurrence - edit end date of 1st occurrence
	public void testTB() {
		// 1st assert - check output
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2020-12-22"), LocalTime.MAX);
		testTaskObject = new TaskObject("", LocalDateTime.MAX, testEndDateTime, "", "", -1, false, new ArrayList<>());
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 1);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, 19);
		actualOutput = testEdit.run();
		correctOutput.add("End date of occurrence 1 edited from '2011-11-11' to '2020-12-22'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualFirstTimingEnd = actualTimings.get(0).getEndDateTime();
		LocalDateTime correctFirstTimingEnd = LocalDateTime.of(LocalDate.parse("2020-12-22"), LocalTime.parse("22:22"));
		
		assertEquals(actualFirstTimingEnd, correctFirstTimingEnd);
	}
	
	@Test // Test edit for single occurrence - edit start and end date and time of 3rd occurrence
	public void testTC() {
		// 1st assert - check output
		LocalDateTime testStartDateTime = LocalDateTime.of(LocalDate.parse("2050-02-14"), LocalTime.parse("19:33"));
		LocalDateTime testEndDateTime = LocalDateTime.of(LocalDate.parse("2050-02-14"), LocalTime.parse("19:34"));
		testTaskObject = new TaskObject("", testStartDateTime, testEndDateTime, "", "", -1, false, new ArrayList<>());
		testCommandObject = new CommandObject(INDEX_EDIT, testTaskObject, 3);
		
		Edit testEdit = new Edit(testCommandObject, testList, testList, 19);
		actualOutput = testEdit.run();
		correctOutput.add("Start date of occurrence 3 edited from '2011-11-11' to '2050-02-14'. \n"
				+ "Start time of occurrence 3 edited from '08:00' to '19:33'. \n"
				+ "End date of occurrence 3 edited from '2011-11-11' to '2050-02-14'. \n"
				+ "End time of occurrence 3 edited from '22:22' to '19:34'.");
		
		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
		
		// 2nd assert - check timings
		TaskObject editedTask = testEdit.getEditTask();
		ArrayList<LocalDateTimePair> actualTimings = editedTask.getTaskDateTimes();
		LocalDateTime actualThirdTimingStart = actualTimings.get(2).getStartDateTime();
		LocalDateTime actualThirdTimingEnd = actualTimings.get(2).getEndDateTime();

		LocalDateTime correctThirdTimingStart = LocalDateTime.of(LocalDate.parse("2050-02-14"), LocalTime.parse("19:33"));
		LocalDateTime correctThirdTimingEnd = LocalDateTime.of(LocalDate.parse("2050-02-14"), LocalTime.parse("19:34"));
		
		assertEquals(actualThirdTimingStart, correctThirdTimingStart);
		assertEquals(actualThirdTimingEnd, correctThirdTimingEnd);
	}
}
```
###### \src\logic\Exit.java
``` java

package logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Logger;

import common.AtfLogger;
import common.TaskObject;
import storage.FileStorage;
import storage.IStorage;

public class Exit {

	static Logger logger = AtfLogger.getLogger();
	
	private ArrayList<TaskObject> taskList;

	public Exit(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}

	public void run() {
		saveToExternalFile();
		System.exit(0);
	}

	public void saveToExternalFile() {
		IStorage storage = FileStorage.getInstance();
		try {
			storage.save(taskList);
			logger.info("saved tasks before exiting");
		} catch (IOException e) {
			logger.warning("did not save tasks properly");
		}
	}
}
```
###### \src\logic\Logic.java
``` java

	/**
	 * Constructor called by Undo/Redo. This is a secondary logic class which only performs one operation
	 * before being deactivated.
	 * 
	 * @param taskList
	 *            The default taskList storing all the tasks
	 * @param undoList
	 *            The deque of CommandObjects which stores all undo actions
	 * @param redoList
	 *            The deque of CommandObjects which stores all redo actions
	 */
	public Logic(ArrayList<TaskObject> taskList, Deque<CommandObject> undoList,
			Deque<CommandObject> redoList) {
		this.taskList = taskList;
		this.undoList = undoList;
		this.redoList = redoList;
		this.lastOutputTaskList = taskList;
	}

	/**
	 * Main processing component of AdultTaskFinder. All user inputs will be passed through this command,
	 * where the internal logic of the software will process the command and react accordingly.
	 * 
	 * @param userInput
	 *            String input that is obtained from UI component. 
	 */
	public void run(String userInput) {
		try {
			setUserInput(userInput);
			CommandObject commandObj = callParser();
			parseCommandObject(commandObj, false, false);
			TimeOutput.setTimeOutputForGui(taskList);
		} catch (Exception e) {
			output.clear();
			output.add(MESSAGE_FAILED_PROCESSING);
		}
	}
	
	// ---------------------------- INITIAL PRE-PROCESSING OF TASK LIST ----------------------------

```
###### \src\logic\Logic.java
``` java
		
	// Sets the starting task ID value. This value should be larger than the current largest task ID 
	// value in the task list so as to avoid overlap.
	private void setStartingTaskId() {
		int largestTaskId = 1;
		for (int i = 0; i < taskList.size(); i++) {
			int id = taskList.get(i).getTaskId();
			if (id > largestTaskId) {
				largestTaskId = id;
			}
		}
		this.taskId = largestTaskId + 1;
	}

```
###### \src\logic\Logic.java
``` java
	
	// ------------------------------- MAIN PROCESSING OF USER INPUT -------------------------------
	
	/**
	 * Calls Parser to parse the user input.
	 * 
	 * @return CommandObject containing information on the task to be manipulated, as well as the command to
	 *         execute
	 */
	private CommandObject callParser() throws Exception {
		Parser parser = new Parser(userInput, taskId);
		taskId++;
		return parser.run();
	}

	/**
	 * Calls the CommandFacade class and passes all relevant arguments. CommandFacade class will be
	 * responsible for parsing the CommandObject and calling the appropriate function. All the lists (task
	 * list, undo list, redo list, last output task list, output) in Logic are subsequently updated with the
	 * values from the CommandFacade class.
	 * 
	 * @param commandObj
	 *            CommandObject obtained from parsing the user input, will be used in the CommandFacade
	 *            object to process changes to AdultTaskFinder
	 * @param isUndoAction
	 *            Boolean variable denoting if the method is called as a result of an undo command
	 * @param isRedoAction
	 *            Boolean variable denoting if the method is called as a result of a redo command
	 */
	public void parseCommandObject(CommandObject commandObj, boolean isUndoAction, boolean isRedoAction) {
		if (!(isUndoAction || isRedoAction)) {
			commandObj.setLastSearchedIndex(lastSearchedIndex);
		}
		CommandFacade commandFacade = new CommandFacade(taskList, undoList, redoList, lastOutputTaskList,
				commandObj, isUndoAction, isRedoAction);
		commandFacade.run();
		updateLists(commandFacade);
	}

	// Retrieves the updated lists from the CommandFacade class and updates the corresponding lists in Logic
	private void updateLists(CommandFacade commandFacade) {
		setTaskList(commandFacade.getTaskList());
		setUndoList(commandFacade.getUndoList());
		setRedoList(commandFacade.getRedoList());
		setLastOutputTaskList(commandFacade.getLastOutputTaskList());
		setOutput(commandFacade.getOutput());
		setTaskDateTimeOutput(commandFacade.getTaskDateTimeOutput());
		setLastSearchedIndex(commandFacade.getLastSearchedIndex());
		setSortedIndex(commandFacade.getSortedIndex());
	}

	// ---------------------------- GETTERS AND SETTERS ----------------------------

	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}

	public Deque<CommandObject> getUndoList() {
		return undoList;
	}

	public Deque<CommandObject> getRedoList() {
		return redoList;
	}

	public ArrayList<String> getOutput() {
		return output;
	}

	public ArrayList<TaskObject> getLastOutputTaskList() {
		return lastOutputTaskList;
	}

	public ArrayList<String> getTaskDateTimeOutput() {
		return taskDateTimeOutput;
	}

	public int getLastSearchedIndex() {
		return lastSearchedIndex;
	}
	
	public int getSortedIndex() {
		return sortedIndex;
	}

	public void setTaskList(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}

	public void setUndoList(Deque<CommandObject> undoList) {
		this.undoList = undoList;
	}

	public void setRedoList(Deque<CommandObject> redoList) {
		this.redoList = redoList;
	}

	public void setLastOutputTaskList(ArrayList<TaskObject> newLastOutputTaskList) {
		this.lastOutputTaskList = newLastOutputTaskList;
	}

	public void setOutput(ArrayList<String> newOutput) {
		this.output = newOutput;
	}

	public void setLastSearchedIndex(int lastSearchedIndex) {
		this.lastSearchedIndex = lastSearchedIndex;
	}
	
	public void setSortedIndex(int sortedIndex) {
		this.sortedIndex = sortedIndex;
	}

	public void setUserInput(String newUserInput) {
		this.userInput = newUserInput;
	}

	public void setTaskDateTimeOutput(ArrayList<String> taskDateTimeOutput) {
		this.taskDateTimeOutput = taskDateTimeOutput;
	}
}
```
###### \src\logic\LogicTest.java
``` java

package logic;

import static org.junit.Assert.*;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class LogicTest {
	
	private static Logic logic = new Logic();
	
	@Test // Test delete all - also helps to delete any previous tasks
	public void testAA() {
		logic.run("delete all");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("All tasks deleted. Undo and redo lists are cleared.");
		
		assertEquals(logic.getOutput(), expectedOutput);
		assertEquals(true, logic.getTaskList().isEmpty());
		assertEquals(true, logic.getUndoList().isEmpty());
		assertEquals(true, logic.getRedoList().isEmpty());
		assertEquals(true, logic.getLastOutputTaskList().isEmpty());
	}
	
	@Test // Test add non-recurring
	public void testAB() {
		logic.run("add CS2103 v0.5");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: CS2103 v0.5. ");
		
		assertEquals(logic.getOutput(), expectedOutput);
		assertEquals(1, logic.getTaskList().size());
		assertEquals(1, logic.getUndoList().size());
		assertEquals(0, logic.getRedoList().size());
		assertEquals(1, logic.getLastOutputTaskList().size());
	}
	
	@Test // Test edit
	public void testAC() {
		logic.run("edit 1 by 15/4");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Added date '2016-04-15' to task 'CS2103 v0.5'.");
		
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getTaskList().size());
		assertEquals(2, logic.getUndoList().size());
		assertEquals(0, logic.getRedoList().size());
		assertEquals(1, logic.getLastOutputTaskList().size());
	}
	
	@Test // Test undo
	public void testAD() {
		logic.run("undo");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Edit undone.");
		
		assertEquals(logic.getOutput(), expectedOutput);
	}
	
	@Test // Test add recurring
	public void testAE() {
		logic.run("add event every saturday from 1500hrs to 1800hrs for 6 weeks");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Recurring task added: event. ");
		
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getTaskList().size());
		assertEquals(2, logic.getLastOutputTaskList().size());
		assertEquals(6, logic.getTaskList().get(0).getTaskDateTimes().size());
	}
	
```
###### \src\logic\mark\Done.java
``` java

	protected boolean changeStatus() {
		try {
			for (int i = 0; i < taskList.size(); i++) {
				TaskObject task = taskList.get(i);
				if (task.getTaskId() == taskIdToMark) {
					originalTask.setTaskObject(task);
					originalTimings.addAll(task.getTaskDateTimes());

					taskName = task.getTitle();
					statusBeforeChange = task.getStatus();
					markedTask = task;
					checkCurrentStatus(STATUS_COMPLETED);
					setMostRecentlyMarkedTaskId(markedTask.getTaskId());

					if (task.getIsRecurring()) {
						changeStatusForRecurringTask(task);
						logger.log(Level.INFO, "marked a recurring task as done");
					} else {
						task.setStatus(STATUS_COMPLETED);
						logger.log(Level.INFO, "marked a non-recurring task as done");
					}

					originalTask.setTaskDateTimes(originalTimings);
					return true;
				}
			}
			logger.log(Level.WARNING, "failed to mark task as completed");
			return false;
		} catch (MarkException e) {
			logger.log(Level.WARNING, "task to be marked already has that status");
			createErrorOutput(e.getMarkExceptionMessage());
			isExceptionThrown = true;
			return false;
		}
	}

```
###### \src\logic\mark\Incomplete.java
``` java

	@Override
	protected boolean changeStatus() {
		for (int i = 0; i < taskList.size(); i++) {
			TaskObject task = taskList.get(i);
			if (task.getTaskId() == taskIdToMark) {

				originalTask.setTaskObject(task);
				originalTimings.addAll(task.getTaskDateTimes());

				taskName = task.getTitle();
				statusBeforeChange = task.getStatus();

				try {
					task.setTaskObject(markTaskObj); // if markTaskObj is not null, this is an undo function
					statusBeforeChange = STATUS_COMPLETED;

					if (markTaskObj.getIsRecurring() && markTaskObj.getTaskDateTimes().size() > 1) {
						deleteSplitTaskFromTaskList(); // deletes the split task that had been created upon
														// mark as done
					}
					logger.log(Level.INFO, "Undo-incomplete processed");
				} catch (NullPointerException e) {
					if (task.getStartDateTime().isAfter(LocalDateTime.now())) {
						task.setStatus(STATUS_INCOMPLETE);
						createOutput(STATUS_INCOMPLETE);
						logger.log(Level.INFO, "Status changed to \'incomplete\'");
					} else {
						task.setStatus(STATUS_OVERDUE);
						createOutput(STATUS_OVERDUE);
						logger.log(Level.INFO, "Status changed to \'overdue\'");
					}
					isExceptionThrown = true;
				}

				return true;
			}
		}
		return false;
	}

	private void createOutput(String status) {
		if (status.equals(STATUS_INCOMPLETE)) {
			String text = String.format(MESSAGE_INCOMPLETE, taskName);
			output.add(text);
		} else if (status.equals(STATUS_OVERDUE)) {
			String text = String.format(MESSAGE_INCOMPLETE_OVERDUE, taskName);
			output.add(text);
		}
	}

	// ==============================================================================
	/**
	 * Checks all tasks with status overdue on whether they are actually incomplete. Called after performing
	 * an edit function.
	 * 
	 * @param taskList
	 *            List of tasks stored in AdultTaskFinder
	 */
	public static void markAllIncompleteTasks(ArrayList<TaskObject> taskList) {
		for (int i = 0; i < taskList.size(); i++) {
			if (!taskList.get(i).getIsRecurring()) {
				if (taskList.get(i).getCategory().equals(CATEGORY_DEADLINE)
						|| taskList.get(i).getCategory().equals(CATEGORY_EVENT)) {
					if (taskList.get(i).getStatus().equals(STATUS_OVERDUE)) {
						if (taskList.get(i).getStartDateTime().isAfter(LocalDateTime.now())) {
							taskList.get(i).setStatus(STATUS_INCOMPLETE);
							logger.info("marked a non recurring overdue task as incomplete");
						}
					}
				}
			}
		}
	}

}
```
###### \src\logic\search\Search.java
``` java

package logic.search;

import logic.display.Display;
import logic.exceptions.SearchException;
import logic.timeoutput.TimeOutput;
import common.TaskObject;
import common.CommandObject;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Level;

import static logic.constants.Strings.*;

/**
 * Creates a Search object which facilitates the finding of tasks matching the search strings. Search is a
 * subclass of Display. <br>
 * <br>
 * 
 * Search can be implemented in 6 ways: <br>
 * 1. Search by title <br>
 * - searches for tasks where the title contains the search keyword <br>
 * 2. Search by date <br>
 * - searches for tasks where the due date matches the search date (for deadlines) or if the date falls
 * between the start and end date (for events) <br>
 * 3. Search by time <br>
 * - searches for tasks where the time matches the search time (for deadlines) or if the time falls between
 * the start and end dates AND times (for events), i.e. for an event "overseas camp 5jan-9jan 12pm-8pm", a
 * search of '7jan 4pm' will return this event but a search of '1jan 4pm' will not <br>
 * - search-by-time requires a search-by-date as well 4. Search by category <br>
 * - searches for tasks where the category matches the search category <br>
 * 5. Search by status <br>
 * - searches for tasks where the status matches the search status; mainly used to view all completed tasks
 * <br>
 * 6. Search by index <br>
 * - searches for a specific index and returns all dates and times that are linked to this index if it is a
 * recurring task
 * 
 * @author ChongYan, RuiBin
 *
 */

public class Search extends Display {

	private CommandObject commandObj;
	private TaskObject taskObj;
	private ArrayList<TaskObject> taskList;
	private ArrayList<TaskObject> lastOutputTaskList;
	// Contains a list of the match results
	private ArrayList<TaskObject> matchedTasks = new ArrayList<TaskObject>();
	// Contains the output to be returned to UI
	private ArrayList<String> output = new ArrayList<String>();
	// Contains the output for the list of dates and times (only for recurring tasks)
	private ArrayList<String> taskDateTimeOutput = new ArrayList<String>();
	// Contains a list of the search parameters
	private ArrayList<String> searchParametersList = new ArrayList<String>();

	// Search keywords
	private String searchTitle = "";
	private LocalDate searchDate = LocalDate.MAX;
	private LocalTime searchTime = LocalTime.MAX;
	private String searchCategory = "";
	private String searchStatus = "";
	private int searchIndex = -1;
	// Boolean checks for the search keywords
	boolean isSearchTitle = false;
	boolean isSearchDate = false;
	boolean isSearchTime = false;
	boolean isSearchCategory = false;
	boolean isSearchStatus = false;
	boolean isSearchIndex = false;

	/**
	 * Constructor for a Search object
	 * 
	 * @param commandObj
	 *            Contains all the search information input by the user
	 * @param taskList
	 *            Contains all tasks in the task list
	 * @param lastOutputTaskList
	 *            Contains the list of tasks currently being displayed in the UI to the user
	 */

	public Search(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList) {
		this.commandObj = commandObj;
		this.taskObj = commandObj.getTaskObject();
		this.searchIndex = commandObj.getIndex();
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;
	}

	/**
	 * Overrides Display's run(). <br>
	 * Sets the boolean checks to determine which search implementation is to be called, then proceeds to
	 * process the search.
	 */
	public ArrayList<String> run() {
		setSearchInformation();
		processSearch();
		setOutput();

		return output;
	}

	/**
	 * Retrieves values from the data objects and sets the boolean checks accordingly.
	 */
	private void setSearchInformation() {
		try {
			searchTitle = taskObj.getTitle().toLowerCase();
			if (!searchTitle.equals("")) {
				isSearchTitle = true;
			}
			searchDate = taskObj.getStartDateTime().toLocalDate();
			if (!searchDate.equals(LocalDate.MAX)) {
				isSearchDate = true;
			}
			searchTime = taskObj.getStartDateTime().toLocalTime();
			if (!searchTime.equals(LocalTime.MAX)) {
				isSearchTime = true;
			}
			searchCategory = taskObj.getCategory();
			if (!searchCategory.equals("")) {
				isSearchCategory = true;
			}
			searchStatus = taskObj.getStatus();
			if (!searchStatus.equals("")) {
				isSearchStatus = true;
			}
			searchIndex = commandObj.getIndex();
			if (searchIndex != -1) {
				isSearchIndex = true;
			}
		} catch (NullPointerException e) {
			logger.log(Level.WARNING, "Error setting search information");
			createErrorOutput(MESSAGE_SETTING_SEARCH_INFORMATION_ERROR);
		}

		// printSearchInformation();
	}

	/**
	 * Processes the search based on the boolean checks. The matchedTasks list initially contains the entire
	 * task list and is gradually filtered based on the searches. The searchedParameters list is also updated
	 * accordingly.
	 */
	private void processSearch() {
		matchedTasks = taskList;

		try {
			if (isSearchTitle) {
				matchedTasks = searchByTitle(matchedTasks);
				searchParametersList.add(searchTitle);
			}
			if (isSearchDate) {
				matchedTasks = searchByDate(matchedTasks);
				searchParametersList.add(searchDate.toString());
			}
			if (isSearchTime) {
				matchedTasks = searchByTime(matchedTasks);
				searchParametersList.add(searchTime.toString());
			}
			if (isSearchCategory) {
				matchedTasks = searchByCategory(matchedTasks);
				searchParametersList.add(searchCategory);
			}
			if (isSearchStatus) {
				matchedTasks = searchByStatus(matchedTasks);
				searchParametersList.add(searchStatus);
			}
			if (isSearchIndex) {
				searchByIndex();
			}
		} catch (SearchException e) {
			logger.log(Level.WARNING, "Search exception thrown");
			createErrorOutput(e.getSearchExceptionMessage());
		}
	}

	// ------------------------------- SEARCH FUNCTIONS -------------------------------

	// Searches the task list based on the titles of the task
	private ArrayList<TaskObject> searchByTitle(ArrayList<TaskObject> list) {
		ArrayList<TaskObject> match = new ArrayList<TaskObject>();
		String[] splitSearchKeyword = searchTitle.split(" ");
		assert (splitSearchKeyword.length > 0);

		if (splitSearchKeyword.length == 1) {
			searchKeywordIsOneWord(list, match);
		} else {
			searchKeywordIsMoreThanOneWord(list, match);
		}

		return match;
	}

	/*
	 * If search keyword contains only one word, check for the tasks where there is a word in the title that
	 * begins or ends with the sequence of search characters.
	 */
	private void searchKeywordIsOneWord(ArrayList<TaskObject> list, ArrayList<TaskObject> match) {
		for (int i = 0; i < list.size(); i++) {
			// Gets the title of one task and splits it up into the individual words
			String taskTitle = list.get(i).getTitle().toLowerCase();
			assert (taskTitle.length() > 0);
			String[] splitTaskTitle = taskTitle.split(" ");
			boolean isMatch = false;

			int j = 0;
			while (j < splitTaskTitle.length && !isMatch) {
				String word = splitTaskTitle[j].trim(); // removes any potential whitespace
				if (word.startsWith(searchTitle) || word.endsWith(searchTitle)) {
					match.add(list.get(i));
					isMatch = true;
				}
				j++;
			}
		}
	}

	/*
	 * First checks if the title contains the entire keyword. If not, it then breaks down the search keyword
	 * into individual words and checks if the title contains all of these individual words.
	 */
	private void searchKeywordIsMoreThanOneWord(ArrayList<TaskObject> list, ArrayList<TaskObject> match) {
		for (int i = 0; i < list.size(); i++) {
			String taskTitle = list.get(i).getTitle().toLowerCase();
			assert (taskTitle.length() > 0);
			String[] splitTaskTitle = taskTitle.split(" ");

			if (taskTitle.contains(searchTitle)) {
				match.add(list.get(i));
			} else {
				String[] splitSearchKeyword = searchTitle.split(" ");
				boolean[] splitSearchKeywordCheck = new boolean[splitSearchKeyword.length];
				Arrays.fill(splitSearchKeywordCheck, false);

				// Checks if each individual word in the search keyword is present in the task title
				for (int j = 0; j < splitSearchKeyword.length; j++) {
					// Checks through all individual words in the title of this task
					for (int k = 0; k < splitTaskTitle.length; k++) {
						if (splitSearchKeyword[j].equals(splitTaskTitle[k])) {
							splitSearchKeywordCheck[j] = true;
						}
					}
				}

				if (isBooleanArrayAllTrue(splitSearchKeywordCheck)) {
					match.add(list.get(i));
				}
			}
		}
	}

	private boolean isBooleanArrayAllTrue(boolean[] arr) {
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == false) {
				return false;
			}
		}
		return true;
	}

	/*
	 * Finds all tasks that have the same start/end date as the search date, or if the search date falls
	 * between the start and end dates (only for events).
	 */
	private ArrayList<TaskObject> searchByDate(ArrayList<TaskObject> list) {
		ArrayList<TaskObject> match = new ArrayList<TaskObject>();

		for (int i = 0; i < list.size(); i++) {
			LocalDate taskStartDate = list.get(i).getStartDateTime().toLocalDate();
			LocalDate taskEndDate = list.get(i).getEndDateTime().toLocalDate();

			if (list.get(i).getCategory().equals(CATEGORY_EVENT)) {
				if ((searchDate.isAfter(taskStartDate) && searchDate.isBefore(taskEndDate))
						|| searchDate.isEqual(taskStartDate) || searchDate.isEqual(taskEndDate)) {
					// if the search date is within the start and end dates of this event
					match.add(list.get(i));
				}
			} else if (list.get(i).getCategory().equals(CATEGORY_DEADLINE)) {
				if (searchDate.isEqual(taskStartDate) || searchDate.isEqual(taskEndDate)) {
					match.add(list.get(i));
				}
			}
		}

		return match;
	}

	/*
	 * Search-by-time is only valid if there is a search-by-date as well. Finds all tasks that have the same
	 * start/end time as the search time, or if the search time falls between the start and end times AND
	 * dates (only for events).
	 */
	private ArrayList<TaskObject> searchByTime(ArrayList<TaskObject> list) throws SearchException {
		// Throws a SearchException if there is no search date
		if (!isSearchDate) {
			SearchException e = new SearchException(isSearchDate);
			throw e;
		}

		list = searchByDate(list); // Does a search-by-date first

		ArrayList<TaskObject> match = new ArrayList<TaskObject>();

		for (int i = 0; i < list.size(); i++) {
			LocalTime taskStartTime = list.get(i).getStartDateTime().toLocalTime();
			LocalTime taskEndTime = list.get(i).getEndDateTime().toLocalTime();

			if (list.get(i).getCategory().equals(CATEGORY_EVENT)) {
				if ((searchTime.isAfter(taskStartTime) && searchTime.isBefore(taskEndTime))
						|| searchTime.equals(taskStartTime) || searchTime.equals(taskEndTime)) {
					match.add(list.get(i));
				}
			} else {
				if (searchTime.equals(taskStartTime) || searchTime.equals(taskEndTime)) {
					match.add(list.get(i));
				}
			}
		}

		return match;
	}

	// Finds all tasks where the category is similar to the search category
	private ArrayList<TaskObject> searchByCategory(ArrayList<TaskObject> list) {
		ArrayList<TaskObject> match = new ArrayList<TaskObject>();

		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).getCategory().equals(searchCategory)) {
				match.add(list.get(i));
			}
		}

		return match;
	}

	// Finds all tasks where the status matches the search status
	private ArrayList<TaskObject> searchByStatus(ArrayList<TaskObject> list) {
		ArrayList<TaskObject> match = new ArrayList<TaskObject>();

		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).getStatus().equals(searchStatus)) {
				match.add(list.get(i));
			}
		}

		return match;

	}

```
###### \src\logic\search\Search.java
``` java

	private void generateSearchParametersOutput() {
		String searchParameters = "";

		for (int i = 0; i < searchParametersList.size(); i++) {
			searchParameters = searchParameters.concat("\'" + searchParametersList.get(i) + "\'");

			// To handle the fencepost problem
			if (i != searchParametersList.size() - 1) {
				searchParameters = searchParameters.concat(", ");
			}
		}

		output.add(String.format(MESSAGE_SEARCH_PARAMETERS, searchParameters));
	}

	private void createErrorOutput(String message) {
		output.add(message);
	}

	/* FOR DEBUG
	private void printSearchInformation() {
		System.out.println("search title = " + searchTitle);
		System.out.println("search date = " + searchDate);
		System.out.println("search time = " + searchTime);
		System.out.println("search category = " + searchCategory);
		System.out.println("search status = " + searchStatus);
		System.out.println("search index = " + searchIndex);
		System.out.println("isSearchTitle = " + isSearchTitle);
		System.out.println("isSearchDate = " + isSearchDate);
		System.out.println("isSearchTime = " + isSearchTime);
		System.out.println("isSearchCategory = " + isSearchCategory);
		System.out.println("isSearchStatus = " + isSearchStatus);
		System.out.println("isSearchIndex = " + isSearchIndex);
		System.out.println();
	}*/

	// ------------------------- GETTERS -------------------------

	public ArrayList<TaskObject> getMatchedTasks() {
		return matchedTasks;
	}

	public ArrayList<String> getOutput() {
		return output;
	}

	public int getSearchIndex() {
		return searchIndex;
	}

	/*
	 * Branch here because search-by-index will not call the superclass Display and the lastOutputTaskList
	 * will not be updated
	 */
	public ArrayList<TaskObject> getLastOutputTaskList() {
		if (!super.getLastOutputTaskList().isEmpty()) {
			return super.getLastOutputTaskList();
		}

		return lastOutputTaskList;
	}

	public ArrayList<String> getTaskDateTimeOutput() {
		return taskDateTimeOutput;
	}
}
```
###### \src\logic\search\SearchTest.java
``` java

package logic.search;

import static org.junit.Assert.assertEquals;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import common.TaskObject;
import common.CommandObject;
import common.LocalDateTimePair;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;

import static logic.constants.Index.*;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class SearchTest {

	private static ArrayList<TaskObject> testList = new ArrayList<TaskObject>();
	private ArrayList<LocalDateTimePair> testTimings = new ArrayList<LocalDateTimePair>();
	private ArrayList<LocalDateTimePair> testTimingsTwo = new ArrayList<LocalDateTimePair>();

	TaskObject one = new TaskObject("Buy new washing machine",
			LocalDateTime.of(LocalDate.parse("2016-06-04"), LocalTime.parse("15:30")), "deadline",
			"incomplete", 1);
	TaskObject two = new TaskObject("Army",
			LocalDateTime.of(LocalDate.parse("2012-01-31"), LocalTime.parse("12:00")),
			LocalDateTime.of(LocalDate.parse("2013-11-29"), LocalTime.parse("12:00")), "event", "complete",
			2);
	TaskObject three = new TaskObject("Army reservist",
			LocalDateTime.of(LocalDate.parse("2016-05-09"), LocalTime.parse("12:00")),
			LocalDateTime.of(LocalDate.parse("2016-11-08"), LocalTime.parse("18:30")), "event", "incomplete",
			3);
	TaskObject four = new TaskObject("Go to the army shop", "floating", "incomplete", 4);
	TaskObject five = new TaskObject("SSS1207 CA2",
			LocalDateTime.of(LocalDate.parse("2016-03-31"), LocalTime.parse("16:00")), "deadline", "complete",
			5);
	TaskObject six = new TaskObject("CS2106 Assignment 2",
			LocalDateTime.of(LocalDate.parse("2016-04-01"), LocalTime.parse("18:00")), "deadline", "complete",
			6);
	TaskObject seven = new TaskObject("Dinner and Dance",
			LocalDateTime.of(LocalDate.parse("2016-04-02"), LocalTime.parse("19:00")),
			LocalDateTime.of(LocalDate.parse("2016-04-02"), LocalTime.parse("22:00")), "event", "complete",
			7);

	LocalDateTime startOne = LocalDateTime.of(LocalDate.parse("2017-03-25"), LocalTime.parse("16:00"));
	LocalDateTime endOne = LocalDateTime.of(LocalDate.parse("2017-03-25"), LocalTime.parse("18:00"));
	LocalDateTime startTwo = LocalDateTime.of(LocalDate.parse("2017-04-01"), LocalTime.parse("16:00"));
	LocalDateTime endTwo = LocalDateTime.of(LocalDate.parse("2017-04-01"), LocalTime.parse("18:00"));
	LocalDateTime startThree = LocalDateTime.of(LocalDate.parse("2017-04-08"), LocalTime.parse("16:00"));
	LocalDateTime endThree = LocalDateTime.of(LocalDate.parse("2017-04-08"), LocalTime.parse("18:00"));
	LocalDateTime startFour = LocalDateTime.of(LocalDate.parse("2017-04-15"), LocalTime.parse("16:00"));
	LocalDateTime endFour = LocalDateTime.of(LocalDate.parse("2017-04-15"), LocalTime.parse("18:00"));
	LocalDateTimePair pairOne = new LocalDateTimePair(startOne, endOne);
	LocalDateTimePair pairTwo = new LocalDateTimePair(startTwo, endTwo);
	LocalDateTimePair pairThree = new LocalDateTimePair(startThree, endThree);
	LocalDateTimePair pairFour = new LocalDateTimePair(startFour, endFour);
	TaskObject eight = new TaskObject("CS2103 lecture", startOne, endFour, "event", "incomplete", 13, true,
			testTimings);
	
	LocalDateTime startFive = LocalDateTime.of(LocalDate.parse("2016-05-01"), LocalTime.MAX);
	LocalDateTime startSix = LocalDateTime.of(LocalDate.parse("2016-06-01"), LocalTime.MAX);
	LocalDateTime startSeven = LocalDateTime.of(LocalDate.parse("2016-07-01"), LocalTime.MAX);
	LocalDateTimePair pairFive = new LocalDateTimePair(startFive, LocalDateTime.MAX);
	LocalDateTimePair pairSix = new LocalDateTimePair(startSix, LocalDateTime.MAX);
	LocalDateTimePair pairSeven = new LocalDateTimePair(startSeven, LocalDateTime.MAX);
	TaskObject nine = new TaskObject("Take IPPT", startFive, startSeven, "deadline", "incomplete", 14, true,
			testTimingsTwo);
	
	
	@Test
	public void populate() {

		// Adding test values
		testList.add(one);
		testList.add(two);
		testList.add(three);
		testList.add(four);
		testList.add(five);
		testList.add(six);
		testList.add(seven);

		testTimings.add(pairOne);
		testTimings.add(pairTwo);
		testTimings.add(pairThree);
		testTimings.add(pairFour);
		testList.add(eight);
		
		testTimingsTwo.add(pairFive);
		testTimingsTwo.add(pairSix);
		testTimingsTwo.add(pairSeven);
		testList.add(nine);
	}

	@Test // Search by title, where search keyword is 1 word
	public void testAA() {
		// Adding expected output
		ArrayList<TaskObject> actualMatchedTasks = new ArrayList<TaskObject>();
		ArrayList<String> expectedMatchedTasksTitles = new ArrayList<String>();
		expectedMatchedTasksTitles.add(two.getTitle());
		expectedMatchedTasksTitles.add(three.getTitle());
		expectedMatchedTasksTitles.add(four.getTitle());

		// Getting actual output
		TaskObject test = new TaskObject("army");
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();
		actualMatchedTasks = testSearch.getMatchedTasks();

		assertEquals(3, actualMatchedTasks.size());
		assertEquals(expectedMatchedTasksTitles.get(0), actualMatchedTasks.get(0).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(1), actualMatchedTasks.get(1).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(2), actualMatchedTasks.get(2).getTitle());
	}

	@Test // Search by title, where search keyword is >1 word
	public void testAB() {
		// Adding expected output
		ArrayList<TaskObject> actualMatchedTasks = new ArrayList<TaskObject>();
		ArrayList<String> expectedMatchedTasksTitles = new ArrayList<String>();
		expectedMatchedTasksTitles.add(seven.getTitle());

		// Getting actual output
		TaskObject test = new TaskObject("dinner dance");
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();
		actualMatchedTasks = testSearch.getMatchedTasks();

		assertEquals(1, actualMatchedTasks.size());
		assertEquals(expectedMatchedTasksTitles.get(0), actualMatchedTasks.get(0).getTitle());
	}

	@Test // Search by date
	public void testB() {
		// Adding expected output
		ArrayList<TaskObject> actualMatchedTasks = new ArrayList<TaskObject>();
		ArrayList<String> expectedMatchedTasksTitles = new ArrayList<String>();
		expectedMatchedTasksTitles.add(two.getTitle());

		// Getting actual output
		TaskObject test = new TaskObject(LocalDateTime.of(LocalDate.parse("2012-01-31"), LocalTime.MAX));
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();
		actualMatchedTasks = testSearch.getMatchedTasks();

		assertEquals(1, actualMatchedTasks.size());
		assertEquals(expectedMatchedTasksTitles.get(0), actualMatchedTasks.get(0).getTitle());
	}

	@Test // Search by time without search by date (should not work)
	public void testC() {
		// Getting actual output
		TaskObject test = new TaskObject(LocalDateTime.of(LocalDate.MAX, LocalTime.parse("12:00")));
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();

		// Output should be the SearchException message
		assertEquals("Search by time requires a search by date as well.", testSearch.getOutput().get(0));
	}

	@Test // Search by time, but now with date (should work)
	public void testD() {
		// Adding expected output
		ArrayList<TaskObject> actualMatchedTasks = new ArrayList<TaskObject>();
		ArrayList<String> expectedMatchedTasksTitles = new ArrayList<String>();
		expectedMatchedTasksTitles.add(three.getTitle());

		// Getting actual output
		TaskObject test = new TaskObject(
				LocalDateTime.of(LocalDate.parse("2016-05-09"), LocalTime.parse("12:00")));
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();
		actualMatchedTasks = testSearch.getMatchedTasks();

		assertEquals(1, actualMatchedTasks.size());
		assertEquals(expectedMatchedTasksTitles.get(0), actualMatchedTasks.get(0).getTitle());
	}

	@Test // Search by category
	public void testE() {
		// Adding expected output
		ArrayList<TaskObject> actualMatchedTasks = new ArrayList<TaskObject>();
		ArrayList<String> expectedMatchedTasksTitles = new ArrayList<String>();
		expectedMatchedTasksTitles.add(one.getTitle());
		expectedMatchedTasksTitles.add(five.getTitle());
		expectedMatchedTasksTitles.add(six.getTitle());

		// Getting actual output
		TaskObject test = new TaskObject("", "deadline", "", -1);
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();
		actualMatchedTasks = testSearch.getMatchedTasks();

		assertEquals(4, actualMatchedTasks.size());
		assertEquals(expectedMatchedTasksTitles.get(0), actualMatchedTasks.get(0).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(1), actualMatchedTasks.get(1).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(2), actualMatchedTasks.get(2).getTitle());
	}

	@Test // Search by index for recurring event
	public void testFA() {
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, new TaskObject(), 8), testList,
				testList);
		testSearch.run();

		assertEquals(5, testSearch.getTaskDateTimeOutput().size());
		assertEquals("Displaying recurrence timings for task 8.", testSearch.getOutput().get(0));
		assertEquals("Timings for CS2103 lecture:", testSearch.getTaskDateTimeOutput().get(0));
		assertEquals("1. from 16:00 to 18:00 \non 25/03/17", testSearch.getTaskDateTimeOutput().get(1));
		assertEquals("2. from 16:00 to 18:00 \non 01/04/17", testSearch.getTaskDateTimeOutput().get(2));
		assertEquals("3. from 16:00 to 18:00 \non 08/04/17", testSearch.getTaskDateTimeOutput().get(3));
		assertEquals("4. from 16:00 to 18:00 \non 15/04/17", testSearch.getTaskDateTimeOutput().get(4));
	}
	
	@Test // Search by index for recurring deadline
	public void testFB() {
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, new TaskObject(), 9), testList,
				testList);
		testSearch.run();

		assertEquals(4, testSearch.getTaskDateTimeOutput().size());
		assertEquals("Displaying recurrence timings for task 9.", testSearch.getOutput().get(0));
		assertEquals("Timings for Take IPPT:", testSearch.getTaskDateTimeOutput().get(0));
		assertEquals("1. by 01/05/16", testSearch.getTaskDateTimeOutput().get(1));
		assertEquals("2. by 01/06/16", testSearch.getTaskDateTimeOutput().get(2));
		assertEquals("3. by 01/07/16", testSearch.getTaskDateTimeOutput().get(3));
	}
	
	@Test // Search by index for normal event
	public void testFC() {
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, new TaskObject(), 2), testList,
				testList);
		testSearch.run();
		
		assertEquals(2, testSearch.getTaskDateTimeOutput().size());
		assertEquals("Task 2 has no recurrence timings to be displayed.", testSearch.getOutput().get(0));
		
	}
	
	@Test // Search by index for normal deadline
	public void testFD() {
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, new TaskObject(), 5), testList,
				testList);
		testSearch.run();
		
		assertEquals(2, testSearch.getTaskDateTimeOutput().size());
		assertEquals("Task 5 has no recurrence timings to be displayed.", testSearch.getOutput().get(0));
		
	}


	@Test // Test for out of bounds index
	public void testFE() {
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, new TaskObject(), 20),
				testList, testList);
		testSearch.run();

		assertEquals("No such task index found.", testSearch.getOutput().get(0));
	}
	
	@Test // Search by status
	public void testG() {
		// Adding expected output
		ArrayList<TaskObject> actualMatchedTasks = new ArrayList<TaskObject>();
		ArrayList<String> expectedMatchedTasksTitles = new ArrayList<String>();
		expectedMatchedTasksTitles.add(two.getTitle());
		expectedMatchedTasksTitles.add(five.getTitle());
		expectedMatchedTasksTitles.add(six.getTitle());
		expectedMatchedTasksTitles.add(seven.getTitle());

		// Getting actual output
		TaskObject test = new TaskObject("", "", "complete", -1);
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();
		actualMatchedTasks = testSearch.getMatchedTasks();

		assertEquals(4, actualMatchedTasks.size());
		assertEquals(expectedMatchedTasksTitles.get(0), actualMatchedTasks.get(0).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(1), actualMatchedTasks.get(1).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(2), actualMatchedTasks.get(2).getTitle());
		assertEquals(expectedMatchedTasksTitles.get(3), actualMatchedTasks.get(3).getTitle());
	}
	
	@Test // Search with no results found
	public void testH() {
		TaskObject test = new TaskObject("randomest", "", "", -1);
		Search testSearch = new Search(new CommandObject(INDEX_SEARCH_DISPLAY, test), testList, testList);
		testSearch.run();

		assertEquals(0, testSearch.getMatchedTasks().size());
		assertEquals("No results found for the specified parameters.", testSearch.getOutput().get(0));
	}
}
```
###### \src\logic\undoredo\Redo.java
``` java

package logic.undoredo;

import java.util.ArrayList;
import java.util.Deque;
import java.util.NoSuchElementException;
import java.util.logging.Level;

import common.CommandObject;
import common.TaskObject;
import logic.Logic;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

/**
 * The Redo class is a child class of the UndoRedo class.
 * The first CommandObject in the redo list ArrayDeque is "popped" and a secondary Logic class is created to 
 * process the operation.
 * 
 * @param taskList ArrayList containing all tasks
 * @param undoList Deque containing all undo tasks
 * @param redoList Deque containing all redo tasks
 * @author RuiBin
 */

public class Redo extends UndoRedo {
	
	private Logic secondaryLogic;
	
	public Redo(ArrayList<TaskObject> taskList, Deque<CommandObject> undoList, Deque<CommandObject> redoList) {
		super(taskList, undoList, redoList);
	}
	
	public ArrayList<String> run() {
		if (redoList.isEmpty()) {
			output.add(MESSAGE_REDO_LIST_EMPTY);
		} else {
			try {
				CommandObject commandObj = redoList.pop();
				
				secondaryLogic = new Logic(taskList, undoList, redoList);
				secondaryLogic.parseCommandObject(commandObj, false, true);
				logger.log(Level.INFO, "Redo CommandObject processed in secondary Logic class");
				
				output.add(String.format(MESSAGE_REDO, getRedoneCommandType(commandObj)));
			} catch (NoSuchElementException e) {
				logger.log(Level.WARNING, "Redo error");
				output.add(MESSAGE_REDO_ERROR);
			}
		}
		
		return output;
	}
	
	private String getRedoneCommandType(CommandObject commandObj) {
		int commandType = commandObj.getCommandType();
		assert (commandType == INDEX_ADD || commandType == INDEX_DELETE || commandType == INDEX_EDIT ||
				commandType == INDEX_COMPLETE || commandType == INDEX_INCOMPLETE);
		
		switch (commandType) {
			case INDEX_ADD :
				return "Add";
			case INDEX_DELETE :
				return "Delete";
			case INDEX_EDIT :
				return "Edit";
			case INDEX_COMPLETE :
			case INDEX_INCOMPLETE :
				return "Status change";
			default :
				return "";
		}
	}
	
	public Logic getLogic() {
		return secondaryLogic;
	}
}
```
###### \src\logic\undoredo\Undo.java
``` java

package logic.undoredo;

import java.util.ArrayList;
import java.util.Deque;
import java.util.NoSuchElementException;
import java.util.logging.*;

import common.CommandObject;
import common.TaskObject;
import logic.Logic;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

/**
 * The Undo class is a child class of the UndoRedo class.
 * The first CommandObject in the undo list ArrayDeque is "popped" and a secondary Logic class is created to 
 * process the operation.
 * 
 * @param taskList ArrayList containing all tasks
 * @param undoList Deque containing all undo tasks
 * @param redoList Deque containing all redo tasks
 * @author RuiBin
 */

public class Undo extends UndoRedo {

	private Logic secondaryLogic;
	
	public Undo(ArrayList<TaskObject> taskList, Deque<CommandObject> undoList, Deque<CommandObject> redoList) {
		super(taskList, undoList, redoList);
	}
	
	public ArrayList<String> run() {
		if (undoList.isEmpty()) {
			output.add(MESSAGE_UNDO_LIST_EMPTY);
		} else {
			try {
				CommandObject commandObj = undoList.pop();
				
				secondaryLogic = new Logic(taskList, undoList, redoList);
				secondaryLogic.parseCommandObject(commandObj, true, false);
				logger.log(Level.INFO, "Undo CommandObject processed in secondary Logic class");
				
				output.add(String.format(MESSAGE_UNDO, getUndoneCommandType(commandObj)));
			} catch (NoSuchElementException e) {
				logger.log(Level.WARNING, "Undo error");
				output.add(MESSAGE_UNDO_ERROR);
			}
		}
		
		return output;
	}
	
	private String getUndoneCommandType(CommandObject commandObj) {
		int commandType = commandObj.getCommandType();
		assert (commandType == INDEX_ADD || commandType == INDEX_DELETE || commandType == INDEX_EDIT ||
				commandType == INDEX_COMPLETE || commandType == INDEX_INCOMPLETE);
		
		switch (commandType) {
			case INDEX_ADD :
				return "Delete";
			case INDEX_DELETE :
				return "Add";
			case INDEX_EDIT :
				return "Edit";
			case INDEX_COMPLETE :
			case INDEX_INCOMPLETE :
				return "Status change";
			default :
				return "";
		}
	}
	
	public Logic getLogic() {
		return secondaryLogic;
	}
}
```
###### \src\logic\undoredo\UndoRedo.java
``` java

package logic.undoredo;

import java.util.ArrayList;
import java.util.Deque;
import java.util.logging.*;

import common.CommandObject;
import common.TaskObject;

import static logic.constants.Index.*;

/**
 * The UndoRedo class is a parent class of the Undo and Redo classes.
 * The run method reads in the command type and then calls the corresponding child class.
 * The list of undo/redo operations are:
 * 1. Add <-> Delete
 * 2. Edit <-> Edit
 * 3. Incomplete <-> Complete
 * 
 * @param taskList ArrayList containing all tasks
 * @param undoList Deque containing all undo tasks
 * @param redoList Deque containing all redo tasks
 * @author RuiBin
 */

public class UndoRedo {

	protected static final Logger logger = Logger.getLogger(UndoRedo.class.getName());
	
	private Undo undo;
	private Redo redo;
	
	protected ArrayList<TaskObject> taskList;
	protected Deque<CommandObject> undoList;
	protected Deque<CommandObject> redoList;
	protected ArrayList<String> output = new ArrayList<String>();

	public UndoRedo(ArrayList<TaskObject> taskList, Deque<CommandObject> undoList, Deque<CommandObject> redoList) {
		this.taskList = taskList;
		this.undoList = undoList;
		this.redoList = redoList;
	}
	
	public ArrayList<String> run(int commandType) {
		assert (commandType == INDEX_UNDO || commandType == INDEX_REDO);

		if (commandType == INDEX_UNDO) {
			undo = new Undo(taskList, undoList, redoList);
			output = undo.run();
		} else if (commandType == INDEX_REDO) {
			redo = new Redo(taskList, undoList, redoList);
			output = redo.run();
		}
		
		return output;
	}
	
	// ---------------------------------- GETTERS ---------------------------------- 
	
	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}
	
	public Deque<CommandObject> getUndoList() {
		return undoList;
	}
	
	public Deque<CommandObject> getRedoList() {
		return redoList;
	}
	
	public ArrayList<String> getOutput() {
		return output;
	}
	
	public Undo getUndo() {
		return undo;
	}
	
	public Redo getRedo() {
		return redo;
	}
}
```
###### \src\logic\undoredo\UndoRedoTest.java
``` java

package logic.undoredo;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import common.CommandObject;
import common.TaskObject;
import logic.Logic;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;
import static org.junit.Assert.*;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class UndoRedoTest {

	private static ArrayList<TaskObject> taskList = new ArrayList<TaskObject>();
	private static Deque<CommandObject> undoList = new ArrayDeque<CommandObject>();
	private static Deque<CommandObject> redoList = new ArrayDeque<CommandObject>();
	
	@Test
	public void populate() {
		TaskObject taskOne = new TaskObject("CS2106 Assignment 1", LocalDateTime.of(LocalDate.parse("2016-03-11"), LocalTime.parse("18:00")),
				"deadline", "completed", 1);
		CommandObject cmdOne = new CommandObject(INDEX_ADD, taskOne, 1);
		
		//TaskObject taskTwo = new TaskObject("Find internship", "floating", "incomplete", 2);
		CommandObject cmdTwo = new CommandObject(INDEX_DELETE, new TaskObject(), 1);
		
		TaskObject origTaskThree = new TaskObject("CS2103 Finals", LocalDateTime.of(LocalDate.parse("2016-04-25"), LocalTime.parse("07:00")),
				LocalDateTime.of(LocalDate.parse("2016-04-25"), LocalTime.parse("11:00")), "event", "incomplete", 3);
		origTaskThree.updateTaskDateTimesArray();
		TaskObject editTaskThree = new TaskObject("CS2103 Finals", LocalDateTime.of(LocalDate.parse("2016-04-25"), LocalTime.parse("09:00")),
				LocalDateTime.of(LocalDate.parse("2016-04-25"), LocalTime.parse("11:00")), "event", "incomplete", 3);
		CommandObject cmdThree = new CommandObject(INDEX_EDIT, editTaskThree, 1);
		
		taskList.add(origTaskThree);
		undoList.add(cmdOne);
		undoList.add(cmdTwo);
		undoList.add(cmdThree);

	}
	
	@Test // Test undo-delete (i.e. add)
	public void testA() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		undoRedo.run(INDEX_UNDO);
		
		Logic logic = undoRedo.getUndo().getLogic();
		ArrayList<String> actualOutput = logic.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: CS2106 Assignment 1. Task added is overdue.");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(2, logic.getTaskList().size());
		assertEquals(2, logic.getUndoList().size());
		assertEquals(1, logic.getRedoList().size());
	}
	
	@Test // Test undo-add (i.e. delete)
	public void testB() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		undoRedo.run(INDEX_UNDO);

		Logic logic = undoRedo.getUndo().getLogic();
		ArrayList<String> actualOutput = logic.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task deleted: CS2106 Assignment 1");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(1, logic.getTaskList().size());
		assertEquals(1, logic.getUndoList().size());
		assertEquals(2, logic.getRedoList().size());
	}
	
	@Test // Test undo-edit
	public void testC() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		undoRedo.run(INDEX_UNDO);

		Logic logic = undoRedo.getUndo().getLogic();
		ArrayList<String> actualOutput = logic.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Start time edited from '07:00' to '09:00'.");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(1, logic.getTaskList().size());
		assertEquals(0, logic.getUndoList().size());
		assertEquals(3, logic.getRedoList().size());
	}
	
	@Test // Test redo-edit
	public void testD() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		undoRedo.run(INDEX_REDO);

		Logic logic = undoRedo.getRedo().getLogic();
		ArrayList<String> actualOutput = logic.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Start time edited from '09:00' to '07:00'.");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(1, logic.getTaskList().size());
		assertEquals(1, logic.getUndoList().size());
		assertEquals(2, logic.getRedoList().size());
	}
	
	@Test // Test redo-delete (i.e. add)
	public void testE() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		undoRedo.run(INDEX_REDO);

		Logic logic = undoRedo.getRedo().getLogic();
		ArrayList<String> actualOutput = logic.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: CS2106 Assignment 1. Task added is overdue.");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(2, logic.getTaskList().size());
		assertEquals(2, logic.getUndoList().size());
		assertEquals(1, logic.getRedoList().size());
	}
	
	@Test // Test redo-add (i.e. delete)
	public void testF() {
		UndoRedo undoRedo = new UndoRedo(taskList, undoList, redoList);
		undoRedo.run(INDEX_REDO);

		Logic logic = undoRedo.getRedo().getLogic();
		ArrayList<String> actualOutput = logic.getOutput();
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task deleted: CS2106 Assignment 1");
		
		assertEquals(expectedOutput, actualOutput);
		assertEquals(1, logic.getTaskList().size());
		assertEquals(3, logic.getUndoList().size());
		assertEquals(0, logic.getRedoList().size());
	}
	
}
```
