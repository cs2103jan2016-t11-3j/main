# A0125003A
###### \src\parser\AddParser.java
``` java
package parser;

import common.TaskObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class is a child class of the CommandParser. It takes in the string input from the user
 * and splits it into "task" and "date-time". Task is set in the AddParser object while the 
 * datetime is parsed into the DateTimeParser. Sets all newly created task as "incomplete"by 
 * default.
 * 
 * @author sylvesterchin
 *
 */

public class AddParser extends CommandParser {
	private TaskObject taskObject = new TaskObject();
	
	/**
	 * This method will take in the command and allocate the correct information
	 * to task/date/time.
	 * 
	 * @param input    
	 * 				string input from user.
	 * @throws Exception 
	 */
	public TaskObject process(String input) throws Exception {
		setTask(input);
		setTaskObject();
		return taskObject;
	}
	
	/**
	 * This method will split string into task and date-time. Calls DateTimeParser 
	 * for date-time string and sets task in AddParser class.
	 * 
	 * @param input
	 * 				same input as process() method. not null.
	 * @throws Exception
	 */
	private void setTask(String input) throws Exception {
		Pattern dateTimePattern = Pattern.compile(Constants.REGEX_DATE_TIME_IDENTIFIER);
		Matcher matcher = dateTimePattern.matcher(input);
		
		String identifier = null;
		
		//recognises date-time string and extracts to identifier
		if (matcher.find()) {
			identifier = getTrimmedString(input ,matcher.start(), matcher.end());
			input = getTrimmedString(input, 0, matcher.start());
		}
		
		if (identifier != null) {
			DateTimeParser dtp = new DateTimeParser();
			taskObject = dtp.parse(identifier, true);
        }
		
		_task = input;
	}

	private void setTaskObject() {
		taskObject.setTitle(_task);
		taskObject.setStatus("incomplete");
	}
 	
 	
	
 	//------------GETTERS---------------
	//for testing purposes
 	public String getTask() {
 		return _task;
 	}

	@Override
	public int getIndex() {
		// TODO Auto-generated method stub
		return 0;
	}
}
```
###### \src\parser\CommandParser.java
``` java
package parser;

import common.TaskObject;
import java.time.LocalDateTime;

/**
 * This class is an abstract class that is the parent class for
 * AddParser, EditParser and SearchParser. Contains task, StartDateTime
 * and EndDateTime as well as some basic methods that all 3 child will
 * need to call. 
 * 
 * @author sylvesterchin
 *
 */
public abstract class CommandParser {
	
	protected String _task = "";
	protected LocalDateTime _startDateTime = LocalDateTime.MAX;
	protected LocalDateTime _endDateTime = LocalDateTime.MAX;
	
	/**
	 * This method processes the input string and returns a task object with attributes
	 * filled.
	 * 
	 * @param input
	 * 				user's input. non-null string. 
	 * @return
	 * 				post processing task object with non-null attribute.
	 * @throws Exception
	 */
	public abstract TaskObject process(String input) throws Exception;
	
	/**
	 * This method returns the index for editing. Only used by EditParser.
	 * 
	 * @return
	 * 				integer that represents the index number of task to be edited.
	 */
	public abstract int getIndex();
	
	protected String getTrimmedString(String input, int startIndex, int endIndex) {
		return input.substring(startIndex, endIndex).trim();
	}
	
}
```
###### \src\parser\Constants.java
``` java
package parser;

/**
 * This class contains all the constant regular expressions that the parser will use.
 * Regular expression allows for flexibility for the use when entering expressions and
 * reduce the amount of if-else in the command parser.  
 * 
 * @author sylvesterchin
 *
 */
public class Constants {
	public static final String REGEX_WS = "\\s";
	
	/*--------------------Command Keywords-------------------------------------------------------*/
	public static final String REGEX_PARSER_ADD = "(?i)^(add)";
	public static final String REGEX_PARSER_SEARCH = "(?i)^(view|search|find|filter|display)";
    public static final String REGEX_PARSER_EDIT = "(?i)^(edit|update)";
    public static final String REGEX_PARSER_DELETE = "(?i)^(delete)";
    public static final String REGEX_PARSER_UNDO = "(?i)^(undo)";
    public static final String REGEX_PARSER_REDO = "(?i)^(redo)";
    public static final String REGEX_PARSER_HELP = "(?i)^(help)";
    public static final String REGEX_PARSER_SAVE = "(?i)^(save)";
    public static final String REGEX_PARSER_EXIT = "(?i)^(exit|quit)";
    public static final String REGEX_PARSER_DONE = "(?i)^(done|(complete)(d)?|(finish)(ed)?)";
    public static final String REGEX_PARSER_NOTDONE = "(?i)^(undone|incomplete)";
    public static final String REGEX_PARSER_LOAD = "(?i)^(load)";
    
    /*--------------------Command Index----------------------------------------------------------*/
	public static final int INDEX_ADD = 1;
	public static final int INDEX_SEARCH = 2;
	public static final int INDEX_EDIT = 3;
	public static final int INDEX_DELETE = 4;
	public static final int INDEX_UNDO = 5;
	public static final int INDEX_REDO = 6;
	public static final int INDEX_SAVE = 7;
	public static final int INDEX_EXIT = 8;
	public static final int INDEX_HELP = 9;	
	public static final int INDEX_DONE = 10;
	public static final int INDEX_NOTDONE = 11;
	public static final int INDEX_LOAD = 12;
	
	/*--------------------Month Value------------------------------------------------------------*/
	public static final int VALUE_JAN = 1;
	public static final int VALUE_FEB = 2;
	public static final int VALUE_MAR = 3;
	public static final int VALUE_APR = 4;
	public static final int VALUE_MAY = 5;
	public static final int VALUE_JUN = 6;
	public static final int VALUE_JUL = 7;
	public static final int VALUE_AUG = 8;
	public static final int VALUE_SEPT = 9;
	public static final int VALUE_OCT = 10;
	public static final int VALUE_NOV = 11;
	public static final int VALUE_DEC = 12;
	
	/*--------------------Month String ----------------------------------------------------------*/
	public static final String MONTH_1_1 = "january";
	public static final String MONTH_1_2 = "jan";
	public static final String MONTH_2_1 = "february";
	public static final String MONTH_2_2 = "feb";
	public static final String MONTH_3_1 = "march";
	public static final String MONTH_3_2 = "mar";
	public static final String MONTH_4_1 = "april";
	public static final String MONTH_4_2 = "apr";
	public static final String MONTH_5_1 = "may";
	public static final String MONTH_6_1 = "june";
	public static final String MONTH_6_2 = "jun";
	public static final String MONTH_7_1 = "july";
	public static final String MONTH_7_2 = "jul";
	public static final String MONTH_8_1 = "august";
	public static final String MONTH_8_2 = "aug";
	public static final String MONTH_9_1 = "september";
	public static final String MONTH_9_2 = "sept";
	public static final String MONTH_10_1 = "october";
	public static final String MONTH_10_2 = "oct";
	public static final String MONTH_11_1 = "november";
	public static final String MONTH_11_2 = "nov";
	public static final String MONTH_12_1 = "december";
	public static final String MONTH_12_2 = "dec";
	
	public static final String DAY_1 = "monday";
	public static final String DAY_2 = "tuesday";
	public static final String DAY_3 = "wednesday";
	public static final String DAY_4 = "thursday";
	public static final String DAY_5 = "friday";
	public static final String DAY_6 = "saturday";
	public static final String DAY_7 = "sunday";
	
	public static final String FREQ_DAILY = "DAILY";
	public static final String FREQ_WEEKLY = "WEEKLY";
	public static final String FREQ_MONTHLY = "MONTHLY";
	public static final String FREQ_YEARLY = "YEARLY";
	
	
	public enum TaskType {
        floating, deadline, event, recurring;
    }
	
	/*---------------------Regular Expressions for Dates-----------------------------------------*/
	public static final String REGEX_DAY_NUMBER = "((?i)0?[1-9]|[12][\\d]|3[01])(st|th|nd|rd)?";
	public static final String REGEX_DAY_ONLYNUMBER = "((?i)0?[1-9]|[12][\\d]|3[01])";
	public static final String REGEX_DAYS_TEXT = "((?i)(mon)(day)?|"
            + "(tue)(s)?(day)?|" + "(wed)(nesday)?|" + "(thu)(r)?(s)?(day)?|" //edit this shit
            + "(fri)(day)?|" + "(sat)(urday)?|" + "(sun)(day)?)";
	public static final String REGEX_MONTHS_NUMBER = "(0?[1-9]|1[0-2])";
	public static final String REGEX_MONTHS_TEXT = "((?i)(jan)(uary)?|"
            + "(feb)(ruary)?|" + "(mar)(ch)?|" + "(apr)(il)?|" + "(may)|"
            + "(jun)(e)?|" + "(jul)(y)?|" + "(aug)(ust)?|" + "(sep)(t)(ember)?|"
            + "(oct)(ober)?|" + "(nov)(ember)?|" + "(dec)(ember)?)";
	public static final String REGEX_YEAR = "((19|20)?\\d\\d)";
    public static final String REGEX_DATE_ATTRIBUTES = "(?i)((day)(s)?|"
            + "(week|wk)(s)?|" + "(month|mth)(s)?|" + "(year|yr))(s)?";

    /*--------------------Regular Expressions for Time-------------------------------------------*/
	public static final String REGEX_TIME_HHMM = "(?i)[0-2][0-9][.-:]?[0-5][\\d]([h]([r][s]?))";
    public static final String REGEX_TIME_AMPM = "((?i)0?[1-9]|1[0-2])[.-:]?([0-5][0-9])?[ -:]?([a|p][m])";
    	//has to have am or pm, dont care!
    	//removed space btw HH and MM . added fullstop btw hh n mm
    public static final String REGEX_TIME_ATTRIBUTES = "(?i)(sec|second)(s)?|" 
    		+ "(min|minutes)(s)?|" + "(hour|hr)(s)?";
    
    /*--------------------Regular Expressions for Date Formats-----------------------------------*/
	public static final String REGEX_COMBINED_DATE_DDMMYYYY = REGEX_DAY_ONLYNUMBER
            + "[-./]" + REGEX_MONTHS_NUMBER + "[-./]?" + REGEX_YEAR + "?";
    public static final String REGEX_COMBINED_DATE_DDMONTHYYYY = REGEX_DAY_NUMBER
            + "[-./ ]?" + REGEX_MONTHS_TEXT + "[-./ ]?" + REGEX_YEAR + "?";
	
    /*--------------------Regular Expressions for Dates & Time formats---------------------------*/
    public static final String REGEX_TIME_FORMAT = "(" + REGEX_TIME_HHMM
            + "|" + REGEX_TIME_AMPM + ")";
    public static final String REGEX_DATE_FORMAT = "("
            + REGEX_COMBINED_DATE_DDMMYYYY + "|"
            + REGEX_COMBINED_DATE_DDMONTHYYYY + ")";
    public static final String REGEX_DATETIME_FORMAT = "(("
            + REGEX_DATE_FORMAT + "(,?[ ]" + REGEX_TIME_FORMAT + ")?)|("
            + REGEX_TIME_FORMAT + "(,?[ ]" + REGEX_DATE_FORMAT + ")?))";
    
    /*--------------------Regular Expressions for Relative Dates---------------------------------*/
    public static final String REGEX_RELATIVE_DATE_0 = "(?i)(today|tonight)";
    public static final String REGEX_RELATIVE_DATE_1 = "(?i)(tmr|tomorrow)";
    public static final String REGEX_RELATIVE_DATE_2 = "(?i)((next|this) ("
            + REGEX_DATE_ATTRIBUTES + "|" + REGEX_DAYS_TEXT + "))";
    public static final String REGEX_RELATIVE_DATE_3 = "(\\d+ "
            + REGEX_DATE_ATTRIBUTES + " (?i)(later|before|after|from now))";
    public static final String REGEX_RELATIVE_DATE_ALL = "(" + REGEX_RELATIVE_DATE_0 + "|"
            + REGEX_RELATIVE_DATE_1 + "|" + REGEX_RELATIVE_DATE_2 
            + "|" + REGEX_RELATIVE_DATE_3 +")";
    public static final String REGEX_RELATIVE_DATETIME = "(" + "(" + REGEX_TIME_FORMAT + " )?" 
            + REGEX_RELATIVE_DATE_ALL + "( " + REGEX_TIME_FORMAT + ")?" + ")";
    
    public static final String REGEX_RELATIVE_TIME_1 = "("
            + REGEX_TIME_ATTRIBUTES + " (?i)(later|before|after|from now))";
    
    /*--------------------Deadline Expression----------------------------------------------------*/
    public static final String REGEX_DEADLINE_IDENTIFIER = "(?i)(by|before) " + "("
            + REGEX_DATETIME_FORMAT + "|" + REGEX_RELATIVE_DATETIME + ")";
    public static final String REGEX_POINT_TASK_IDENTIFIER = "(?i)(on|at) " + "("
            + REGEX_DATETIME_FORMAT + "|" + REGEX_RELATIVE_DATETIME + ")";
    
    /*--------------------Event Expression-------------------------------------------------------*/
    public static final String REGEX_EVENT_COMPONENT = "(" + REGEX_DATETIME_FORMAT + "|" 
    		+ REGEX_RELATIVE_DATETIME + ")";
    public static final String REGEX_EVENT_IDENTIFIER_1 = "(?i)(from) " +  REGEX_EVENT_COMPONENT 
    			+ " to " + REGEX_EVENT_COMPONENT;
    public static final String REGEX_EVENT_IDENTIFIER = "(?i)(from) "
    + "(" + REGEX_DATETIME_FORMAT + "|" +  REGEX_RELATIVE_DATETIME + ")"
    + " to " + "(" + REGEX_DATETIME_FORMAT + "|" +  REGEX_RELATIVE_DATETIME + ")";

    
    /*--------------------Recurring Task Expression----------------------------------------------*/
    public static final String REGEX_RECURRING_INTERVAL_EVERYDAY = "(?i)(everyday)";
    public static final String REGEX_RECURRING_INTERVAL = "(?i)(every)[ 0-9]* ("
    		+ REGEX_DATE_ATTRIBUTES + "|" + REGEX_TIME_ATTRIBUTES + "|" + REGEX_DAYS_TEXT 
    		+ "(" + "( and | & | n )?(, )?( , )?(,)?" + REGEX_DAYS_TEXT + ")*" + ")";
    public static final String REGEX_RECURRING_INTERVAL2 = "(" + REGEX_RECURRING_INTERVAL + "|" 
    		+ REGEX_RECURRING_INTERVAL_EVERYDAY + ")";
    public static final String REGEX_RECURRING_START = "(" + REGEX_DATETIME_FORMAT + "|"
    		+ REGEX_DEADLINE_IDENTIFIER + "|" + REGEX_EVENT_IDENTIFIER + "|" 
    		+ REGEX_POINT_TASK_IDENTIFIER + ")?";
    public static final String REGEX_RECURRING_FOR = "(?i)(for) " + "[\\d]+ " 
    		+ "(" + REGEX_DATE_ATTRIBUTES + "|" + "(time|times))";
    public static final String REGEX_RECURRING_UNTIL = "(?i)(until) (" 
    		+ REGEX_DATETIME_FORMAT + "|" + REGEX_RELATIVE_DATE_ALL + ")";
    public static final String REGEX_RECURRING_TASK_IDENTIFIER = "(" + REGEX_RECURRING_INTERVAL 
    		+ "|" + REGEX_RECURRING_INTERVAL_EVERYDAY + ")" + "( " + REGEX_RECURRING_START + ")?" 
    		+ "( " + REGEX_RECURRING_UNTIL + "| " + REGEX_RECURRING_FOR + ")?";
    
    /*--------------------Task Identifier Expression---------------------------------------------*/
    public static final String REGEX_TASK_IDENTIFIER = "(?i)(by|before|every|on|at|from|to)";
    public static final String REGEX_TASK_IDENTIFIER_2 = "(?i)(by|before|every|on|at|from)";//today tomorrow
    public static final String REGEX_TASK_IDENTIFIER_3 = "(?i)(by|before|every|on|from|to)";//saturday
    public static final String REGEX_TASK_IDENTIFIER_4 = "(?i)(by|before|every|from|to)";//monday
    public static final String REGEX_TASK_IDENTIFIER_5 = "(?i)(by|before|on|at|from|to)";
    public static final String REGEX_TASK_IDENTIFIER_6 = "(?i)(by|before|every|at|from)";//tonight 
    
    /*--------------------DateTime Identifier Expression-----------------------------------------*/
    public static final String REGEX_DATE_TIME_IDENTIFIER = "("
            + REGEX_DEADLINE_IDENTIFIER + "|" + REGEX_EVENT_IDENTIFIER + "|"
            + REGEX_POINT_TASK_IDENTIFIER + "|"
            + REGEX_RECURRING_TASK_IDENTIFIER + ")$"; //checks end of string
    
    /*--------------------EDIT DateTime Identifier Expression------------------------------------*/
    public static final String REGEX_EDIT_DATE_TIME_IDENTIFIER = "(" 
			+ REGEX_DATE_TIME_IDENTIFIER + "|" + REGEX_DATETIME_FORMAT +")$";
    
    /*--------------------Overall Identifier Expression------------------------------------*/
    public static final String REGEX_FINAL = "(" + REGEX_DATE_TIME_IDENTIFIER + "|" 
    		+ REGEX_RELATIVE_DATE_ALL + "|" + REGEX_RELATIVE_TIME_1 + ")$";
    
    /*--------------------SEARCH DateTime Identifier Expression----------------------------------*/
    public static final String REGEX_EDIT_STARTEND = "(?i)(start|end)";
    public static final String REGEX_SEARCH = "(" + REGEX_FINAL + "|"
    		+ REGEX_DATETIME_FORMAT + "|" + REGEX_DAYS_TEXT + ")";
    public static final String REGEX_SEARCH2 = "(" + REGEX_RECURRING_INTERVAL + "|"+ REGEX_FINAL + "|"
    		+ "(" + REGEX_DATETIME_FORMAT  + "( " + REGEX_EDIT_STARTEND + ")?)"+ ")$";

	//changeable default year.
	public static final int DEFAULT_YEAR = 2016;	
}
```
###### \src\parser\DateParser.java
``` java
package parser;

import java.time.format.DateTimeFormatter;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.temporal.TemporalAdjusters;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import parser.exceptions.InvalidDateFormatException;

/**
 * This class focuses on breaking down a string for date into the relevant components
 * it takes in a date input with varying degree of flexibility, 
 * in dd/mm/yy or number-month-year format.
 * 
 * @author sylvesterchin
 * 
 */

public class DateParser {
	private int day = -1;
	private int month = -1;
	private int year = -1;
	private int date = -1;
	private int standardDateLength = 8;
	private int yearMultiplier = 10000;
	private int monthMultiplier = 100;
	private int monthLimit = 12;
	private int dayLimit = 31;
	private int yearFormatter = 2000;
	
	private String dateString;
	private LocalDate dateObject = LocalDate.MAX;
	
	/**
	 * This method takes in a string input returns LocalDate to the datetimeparser.
	 * 
	 * @param input    
	 * 				date string that is in the format.
	 * @throws Exception 
	 */
	public void parseDate(String input) throws Exception {
		if (!input.isEmpty()) {
			input = preprocess(input);
			processDate(input);
			setDates();	
		}
	}
	
	// ================================
	// First Level of Abstraction
	// ================================
	
	/**
	 * This method returns the input in lower case and redundant white spaces removed.
	 * 
	 * @param input
	 * 				general string, in upper or lower case.
	 * @return
	 */
    private String preprocess(String input) {
        return input.toLowerCase().trim();
    }
	
    /**
	 * This method further processes the input from date-time-parser.
	 * 
	 * format types include
	 * 1. dd-Month-yyyy format:  3rd june 2013 
	 * 2. ddmmyyy format:        4/5-5/6
	 * 3. relative date format:  next monday
	 * 
	 * @param input
	 * 				date input from user, not null.
	 * @throws Exception 
	 */
	private void processDate(String input) throws Exception {
		boolean hasAlphabets = input.matches(".*[a-zA-Z]+.*");
	    if (hasAlphabets) {
	        processWithAlphabets(input);
	    } else {
	        processWithoutAlphabets(input);
	    }
	}
	
	/**
	 * This method sets the LocalDate for the object by cleaning up minor format differences
	 * and forming yyyyMMdd string. It passes date in string format to setDateObject method 
	 * for setting the LocalDate value
	 * @throws Exception 
	 */
	private void setDates() throws Exception {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("uuuu-MM-dd");
		
		if (year < 100 && year != -1) {
			year = yearFormatter + year;
		} else if (year == -1) {
			year = Constants.DEFAULT_YEAR;
		}
		
		if (day > dayLimit || month > monthLimit) {
			throw new Exception("Invalid Date");
		} else if (day != -1 && month != -1 && year != -1) {
			date = day + month * monthMultiplier + year * yearMultiplier;
		}
		
		dateString = Integer.toString(date); //now insert the damn dashes
		dateString = addDashes(dateString);
		setDateObject(dateString, dateFormatter);
	}
	
	// ================================
	// Second Level of Abstraction
	// ================================
	
	/**
	 * This method will take in dates without alphabets, such as 
	 * dates in the dd/mm/yyyy format and process it accordingly.
	 * 
	 * @param input
	 * 				date in dd/mm/yyyy format, not null.
	 * @throws Exception
	 */
	private void processWithoutAlphabets(String input) throws Exception {
	    if (hasSymbolSeparator(input)) {
            setSymbolSeparatedDate(input);
        } else {
            throw new InvalidDateFormatException(input);
        }
    }

	/**
	 * This method will identify the date format of the input and process it
	 * accordingly.
	 * 
	 * @param input
	 * 				date string in either relative or ddMonthyyyy format. not null.
	 * @throws Exception
	 */
    private void processWithAlphabets(String input) throws Exception {
	    if (hasMonth(input)) {
            setMonth(input);
            input = removeMonth(input);
            splitStringAndProcess(input);
        } else if (isRelative(input)) { 
            processRelativeDate(input);
        } else {
	        throw new InvalidDateFormatException(input);
	    }
    }
    
    /**
	 * This method adds dashes into the date string to convert it into yyyy-MM-dd format.
	 * 
	 * @param input   
	 * 				date string in yyyyMMdd format.
	 * 				e.g. 20140529
	 * @return 
	 * 				string in yyyy-MM-dd format.
	 * 				e.g. 2014-05-29
	 */
	private String addDashes(String input) {
		if (input.length() == standardDateLength) {
			String year, month, day;
			year = input.substring(0,4);
			month = input.substring(4,6);
			day = input.substring(6);
			return year + "-" + month + "-" + day;	
		} else {
			return "";
		}
	}
	
	//if already set due to relative date, the method will not set the date again
	private void setDateObject(String input, DateTimeFormatter dateFormatter) {
		if (dateObject == LocalDate.MAX && !input.isEmpty()) {
			dateObject = LocalDate.parse(input, dateFormatter);
		}
	}
		

	// ================================
	// Third Level of Abstraction
	// ================================
    
    //this method checks if the date is in dd/mm/yy format.
  	private boolean hasSymbolSeparator(String input) {
  		if (input.contains("/") || input.contains(".") || input.contains("-") ) {
  			return true;
  		} else {
  			return false;
  		}
  	}
  	
  	/**
	 * This method will set the day, month and year for inputs with in dd/mm/yy format.
	 * 
	 * @param input  
	 * 				input by user for one date, in dd/mm/yyyy format.
	 * @throws Exception 
	 */
	private void setSymbolSeparatedDate(String input) throws Exception {
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		for (String temp : input.split("[.-/]")) {
			temp = temp.replaceAll(" ", "");
			temp = temp.replaceAll("[a-zA-Z]+", "");
			int tempInt = Integer.parseInt(temp);
			list.add(tempInt);
		}
		
		if (list.size() != 1) {
			day = list.get(0);
			month = list.get(1);
			
			if (list.size() == 3) {
				year = list.get(2);
			}	
		} else {
			throw new Exception("Invalid Date");
		}
	}
    
	/**
	 * This method checks if the string contains keywords for any of the months.
	 * 
	 * @param input    
	 * 				string element in array list representing one date. non null.
	 * @return
	 * 				boolean true if input contains any of the 12 months
	 * 
	 */
	private boolean hasMonth(String input) {
		Pattern dateTimePattern = Pattern.compile(Constants.REGEX_MONTHS_TEXT);
		Matcher matcher = dateTimePattern.matcher(input);
		return matcher.find();
	}
	
	//this method will allocate relevant integer to month variable.
	private void setMonth(String input) {
			month = setMonthInDateProcessor(input);
	}
	
	//method removes all the characters in the date.
	private String removeMonth(String input) {
		return input.replaceAll("[a-zA-Z]+", " ");
	}
	
	/**
	 * This method will split a date into the day, month and year.
	 * 
	 * @param input   
	 * 				date input by the user without the month. non null.
	 */
	private void splitStringAndProcess(String input) {
		ArrayList<String> templist = new ArrayList<String>();
		int _day = -1, _year = -1;
		input = preprocess(input);
		
		for (String temp : input.split("\\s+")) {
			temp = temp.replaceAll("[a-zA-Z]+", "");
			templist.add(temp);
		}
		
		//set the day n year according to the filled elements of the array.
		if (templist.size() == 2) {
			_day = Integer.parseInt(templist.get(0));
			_year = Integer.parseInt(templist.get(1));
		} else if (templist.size() == 1) {
			_day = Integer.parseInt(templist.get(0));
		}
		//set attributes.
		day = _day;
		year = _year;
	}
	
    /**
	 * This method checks if the input string is a relative date.
	 * 
	 * @param input   
	 * 				date string, not null.
	 * @return boolean   
	 * 				true,if the date string is a relative date.
	 */
	private boolean isRelative(String input) {
		if (input.matches(Constants.REGEX_RELATIVE_DATE_ALL) || input.matches(Constants.REGEX_DAYS_TEXT)
				|| input.matches(Constants.REGEX_RECURRING_INTERVAL_EVERYDAY)) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * This method will set date object for relative date inputs such as today, tmr, next week.
	 * 
	 * @param input
	 * 				non-null string that is a relative date, such as "today" or "next fri".
	 * @throws Exception 
	 */
	private void processRelativeDate(String input) throws Exception {
		input = preprocess(input);
		if (input.matches(Constants.REGEX_RELATIVE_DATE_0) 
				|| input.matches(Constants.REGEX_RECURRING_INTERVAL_EVERYDAY)) {
				dateObject = LocalDate.now();
		} else if (input.matches(Constants.REGEX_RELATIVE_DATE_1)) {
				dateObject = LocalDate.now().plusDays(1);
		} else if (input.matches("("+"(next )"+ Constants.REGEX_DAYS_TEXT+")")) {
			setDateNextWeek(input);
		} else if (input.matches("("+"(this )"+ Constants.REGEX_DAYS_TEXT+")")) {
			setDateThisWeek(input);
		} else if (input.matches("next " + "(week|wk)(s)?")) {
			dateObject = LocalDate.now().plusWeeks(1);
		} else if (input.matches(Constants.REGEX_DAYS_TEXT)) {
			setDateToComingDayOfWeek(input);
		}
	}
	
	// ================================
	// Fourth Level of Abstraction
	// ================================

	/**
	 * This method will return the corresponding month's integer value.
	 * 
	 * @param month
	 * 				month input in string format, non-null.
	 */
	private int setMonthInDateProcessor(String month) {
		month = month.toLowerCase();
		if (month.contains(Constants.MONTH_1_1) || month.contains(Constants.MONTH_1_2)) {
			return Constants.VALUE_JAN;
		} else if (month.contains(Constants.MONTH_2_1) || month.contains(Constants.MONTH_2_2)) {
			return Constants.VALUE_FEB;
		} else if (month.contains(Constants.MONTH_3_1) || month.contains(Constants.MONTH_3_2)) {
			return Constants.VALUE_MAR;
		} else if (month.contains(Constants.MONTH_4_1) || month.contains(Constants.MONTH_4_2)) {
			return Constants.VALUE_APR;
		} else if (month.contains(Constants.MONTH_5_1)) {
			return Constants.VALUE_MAY;
		} else if (month.contains(Constants.MONTH_6_1) || month.contains(Constants.MONTH_6_2)) {
			return Constants.VALUE_JUN;
		} else if (month.contains(Constants.MONTH_7_1) || month.contains(Constants.MONTH_7_2)) {
			return Constants.VALUE_JUL;
		} else if (month.contains(Constants.MONTH_8_1) || month.contains(Constants.MONTH_8_2)) {
			return Constants.VALUE_AUG;
		} else if (month.contains(Constants.MONTH_9_1) || month.contains(Constants.MONTH_9_2)) {
			return Constants.VALUE_SEPT;
		} else if (month.contains(Constants.MONTH_10_1) || month.contains(Constants.MONTH_10_2)) {
			return Constants.VALUE_OCT;
		} else if (month.contains(Constants.MONTH_11_1) || month.contains(Constants.MONTH_11_2)) {
			return Constants.VALUE_NOV;
		} else if (month.contains(Constants.MONTH_12_1) || month.contains(Constants.MONTH_12_2)) {
			return Constants.VALUE_DEC;
		} else {
			return -1;
		}
	}
	
	/**
	 * This method will set the date object to the next nearest day that 
	 * the input specifies.
	 * 
	 * @param input
	 * 				non-null string which is a day from Monday to Sunday.
	 * @throws InvalidDateFormatException
	 */
	private void setDateToComingDayOfWeek(String input) throws InvalidDateFormatException {
	    input = processDayOfWeek(input);
	    dateObject = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.valueOf(input))); 
	}
	
	/**
	 * This method will set the date object to the day as specified by the input
	 * on the following week.
	 * 
	 * @param input
	 * 				non-null string which contains a day from Monday to Sunday.
	 * @throws InvalidDateFormatException
	 */
	private void setDateNextWeek(String input) throws InvalidDateFormatException {
		input = input.replaceAll("next", "").trim();
        input = processDayOfWeek(input);
        dateObject = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.valueOf(input)));
        int set = dateObject.getDayOfWeek().getValue();
        int now = LocalDate.now().getDayOfWeek().getValue();
        if (set > now ) {
            dateObject = dateObject.plusWeeks(1);
        }
	}
	
	/**
	 * This method will set the date object to the day as specified by the input
	 * in this week.
	 * 
	 * @param input
	 * 				non-null string which contains a day from Monday to Sunday.
	 * @throws Exception
	 */
	private void setDateThisWeek(String input) throws Exception {
		input = input.replaceAll("this", "").trim();
		input = processDayOfWeek(input);
		int set = DayOfWeek.valueOf(input).getValue();
        int now = LocalDate.now().getDayOfWeek().getValue();
        if (set < now ) {
        	dateObject = LocalDate.now().with(TemporalAdjusters.previous(DayOfWeek.valueOf(input)));
            //throw new Exception(input + " is over this week. Did you mean next " + input + "?");
        } else if (set > now) {
            dateObject = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.valueOf(input)));
        }
	}
	
	@SuppressWarnings("unused")
    private LocalDate setStartofNextWeek() {
		LocalDate date = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		return date;
	}
	
	// ================================
	// Fifth Level of Abstraction
	// ================================
	
	/**
	 * This method will read the day of week and return the day-of-week in
	 * correct format.
	 * 
	 * @param dayOfWeek
	 * 				string input representing the day of the week. E.g. monday.
	 * @return
	 * 				day-of-the-week in upper case, similar to LocalDate.getDayOfWeek output.
	 * @throws InvalidDateFormatException
	 */
	private String processDayOfWeek(String dayOfWeek) throws InvalidDateFormatException {
        dayOfWeek = preprocess(dayOfWeek);
        if (Constants.DAY_1.contains(dayOfWeek)) {
        	dayOfWeek = Constants.DAY_1;
        } else if (Constants.DAY_2.contains(dayOfWeek)) {
        	dayOfWeek =  Constants.DAY_2;
        } else if (Constants.DAY_3.contains(dayOfWeek)) {
        	dayOfWeek =  Constants.DAY_3;
        } else if (Constants.DAY_4.contains(dayOfWeek)) {
        	dayOfWeek =  Constants.DAY_4;
        } else if (Constants.DAY_5.contains(dayOfWeek)) {
        	dayOfWeek =  Constants.DAY_5;
        } else if (Constants.DAY_6.contains(dayOfWeek)) {
        	dayOfWeek =  Constants.DAY_6;
        } else if (Constants.DAY_7.contains(dayOfWeek)) {
        	dayOfWeek =  Constants.DAY_7;
        } else {
            throw new InvalidDateFormatException(dayOfWeek);
        }
        return dayOfWeek.toUpperCase();
    }
	
	/**
	 * Getter method for testing purposes
	 * 
	 * @return LocalDate object
	 */
	public LocalDate getDateObject() {
		return dateObject;
	}
	
	//method used to reset all dates for testing
	public void resetDate() {
		day = -1;
		month = -1;
		year = -1;
		
		date = -1;
		dateObject = LocalDate.MAX;
	}
}
```
###### \src\parser\DateTimeParser.java
``` java
package parser;

import common.AtfLogger;
import common.TaskObject;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import parser.Constants.TaskType;


/**
 * This class is the facade class that hides the DateParser and TimeParser from the 
 * CommandParsers. Its main functionality is to:
 * a) split string into date and time to be parsed into DateParser and TimeParser respectively
 * b) recognise recurring tasks and process the interval and terminal date-time
 * c) set LocalDateTime variables in TaskObject to be returned to CommandParser
 * 
 * Does nothing if no recognizable tasktype is parsed in.
 * 
 * @author sylvesterchin
 *
 */
public class DateTimeParser {
	private LocalDate startDate = LocalDate.MAX;
	private LocalDate endDate = LocalDate.MAX;
	private LocalTime startTime = LocalTime.MAX;
	private LocalTime endTime = LocalTime.MAX;
	private LocalDate untilDate = LocalDate.MAX;
	private LocalTime untilTime = LocalTime.MAX;
	
	private LocalDateTime startDateTime = LocalDateTime.MAX;
	private LocalDateTime endDateTime = LocalDateTime.MAX;
	private LocalDateTime untilDateTime = LocalDateTime.MAX;
	
	private TaskObject TO = new TaskObject();
	
	TaskType tasktype;
	
	private static Logger logger = AtfLogger.getLogger();
	
	/**
	 * This method is the only method that CommandParser will access. It parses 
	 * date and time as well as sets LocalDateTime.
	 * 
	 * @param input
	 * 				user's input consisting only date-time components. not null.
	 * @param isForAdd
	 * 				boolean to signify if called by AddParser
	 * @return
	 * 				task object with LocalDateTime and Interval object filled
	 * @throws Exception
	 */
	public TaskObject parse(String input, boolean isForAdd) throws Exception {
		parseDateTime(input, isForAdd);
		setLocalDateTime(isForAdd, tasktype);
		return TO;
	}
	
	// ================================
	// First Level of Abstraction
	// ================================
	
	/**
	 * This method will take in string containing date and time, then splitting it into the date and time
	 * separately for parsing through DateParser and TimeParser.
	 * 
	 * @param input      
	 * 			user input in string format
	 * @param isForAdd   
	 * 			boolean to indicate if command is for the add parser
	 * @throws Exception 
	 */
	private void parseDateTime(String input, boolean isForAdd) throws Exception {
		if (isForAdd) {
			parseDateTimeForAdd(input);
		} else {
			parseDateTimeOthers(input);
		}
	}
	
	/**
	 * This method will set appropriate localdatetime for the task object
	 * if the task is an event without end date, start date will be used
	 * 
	 * @param isForAdd  
	 * 				boolean show if the task is for an add command
	 * @param task      
	 * 				task type (deadline, event, floating)
	 */
	private void setLocalDateTime(boolean isForAdd, TaskType task) {
		if (isForAdd) {
			if (startDate.equals(LocalDate.MAX) 
					&& task.toString().equals(Constants.TaskType.deadline.toString())) {
				startDate = LocalDate.now();
			}
			
			if (task.toString().equals(Constants.TaskType.event.toString()) 
					&& endDate.equals(LocalDate.MAX)) { 
				if (startDate.equals(LocalDate.MAX)) {
					startDate = LocalDate.now();
				}
				endDate = startDate;
			}
			
			if (startTime.isAfter(endTime)) {
				System.out.println("hi");
				endDate = endDate.plusDays(1);
			}
			
			if (task.toString() == "event") {
				endDateTime = LocalDateTime.of(endDate, endTime);
			}
		}
		//setting the startdatetime and enddatetime
		endDateTime = LocalDateTime.of(endDate, endTime);
		startDateTime = LocalDateTime.of(startDate, startTime);
		TO.setStartDateTime(startDateTime);
		TO.setEndDateTime(endDateTime);
	}
	
	// ================================
	// Second Level of Abstraction
	// ================================
	
	
	/**
	 * This method will parse date time string according to its task type.
	 * 
	 * @param input   
	 * 			user's input in a string format.
	 * @throws Exception 
	 */
	private void parseDateTimeOthers(String input) throws Exception {
		tasktype = getTaskType(input);
		
		//separate stuff for different task types
		switch(tasktype) {
		case event :
			String startOfEvent = "", endOfEvent = "";
			Pattern split = Pattern.compile(" to ");
			Matcher matcher = split.matcher(input);
			if (matcher.find()) {
				startOfEvent = getTrimmedString(input, 0, matcher.start());
				endOfEvent = getTrimmedString(input, matcher.end(), input.length());
			}
			
			separateDateTime(startOfEvent, "start");
			separateDateTime(endOfEvent, "end");
			break;
		case recurring :
			TO.setIsRecurring(true);
			recur(input);
			break;
		case deadline :
		default :
			if(input.contains("to")) {
				endDateTime = startDateTime;
			}
			separateDateTime(input, "start");
			break;
		}
	}
	
	
	/**
	 * This method will parse date time string according to its task type.
	 * 
	 * @param input   
	 * 			user's input in a string format
	 * @throws Exception 
	 */
	private void parseDateTimeForAdd(String input) throws Exception {
		tasktype = getTaskType(input);
		
		//separate stuff for different task types
		switch(tasktype) {
		case event:
			String temp1 = "", temp2 = "";
			Pattern split = Pattern.compile(" to ");
			Matcher matcher = split.matcher(input);
			if (matcher.find()) {
				temp1 = getTrimmedString(input, 0, matcher.start());
				temp2 = getTrimmedString(input, matcher.end(), input.length());
			}
			
			separateDateTime(temp1, "start");
			separateDateTime(temp2, "end");
			break;
		case deadline:
			separateDateTime(input, "start");
			break;
		case recurring:
			TO.setIsRecurring(true);
			recur(input);
			break;
		default:
			break;
		}
	}
	
	// ================================
	// Third Level of Abstraction
	// ================================
	
	/**
	 * This method will split string into the StartDateTime, interval and limiter components of a recurring task identifier
	 * Limiter refers to an "until" or "for" restriction to specify the expiry of the task
	 * 
	 * @param input
	 * 				string input for recurring tasks with interval, StartDateTime and a limiter
	 * @throws Exception
	 */
	private void recur(String input) throws Exception {
		String intervalString = "";
		String forstring = "";
		
		input = extractUntilLimiter(input);
		
		forstring = extractForLimiter(input);
		input = input.replaceFirst(forstring, "");
		
		intervalString = extractInterval(input, forstring);
		
		if (startDate == LocalDate.MAX) { // checks for startdatetime without date
			getStartDateFromInterval(intervalString);
		}
	}

	/**
	 * This method will take in string and identify regular expressions for time
	 * and date. 
	 * 
	 * Creates DateParser object and TimeParser object to parse date and time respectively.
	 * 
	 * @param input	
	 * 			user's input containing date and time.
	 * 			e.g. 7pm 9 june, tmr 9am
	 * @param isStart
	 * 			type of time/date the user's input will be stored, either as start, end or until.
	 * @throws Exception 
	 */
	private void separateDateTime(String input, String type) throws Exception {
		input = input.replaceFirst("until", "").trim();
		input = input.replaceFirst("from", "").trim();
		
		Pattern time = Pattern.compile(Constants.REGEX_TIME_FORMAT);
		Matcher timeMatcher = time.matcher(input);
		DateParser DP = new DateParser();
		TimeParser TP = new TimeParser();
		
		String _date = "", _time = "";
		
		if (timeMatcher.find()) {
			logger.log(Level.INFO, "Time format found");
			_time = getTrimmedString(input, timeMatcher.start(), timeMatcher.end());
			_date = input.replaceAll(_time, "").trim();
			if (_date.matches("(start|end)")) {
				type = _date;
				_date = ""; 
			}
		} else {
			logger.log(Level.INFO, "Time format NOT found");
			_date = input;
		}
		processParallel(DP, TP, _date, _time);
		setDateTime(type, DP, TP);
	}
	
	/**
	 * This method checks string to identify the task type
	 * 
	 * @param input    
	 * 			user's input in string format
	 * 			e.g. by tmr 6pm (deadline)
	 * @return         
	 * 			appropriate task type for the input 
	 */
	private TaskType getTaskType(String input) {
		if (input.matches(Constants.REGEX_DEADLINE_IDENTIFIER)) {
			logger.log(Level.INFO, "Deadline recognised");
			return TaskType.deadline;
		} else if (input.matches(Constants.REGEX_EVENT_IDENTIFIER)) {
			logger.log(Level.INFO, "Event recognised");
			return TaskType.event;
		} else if (input.matches(Constants.REGEX_POINT_TASK_IDENTIFIER)) {
			logger.log(Level.INFO, "Deadline recognised");
			return TaskType.deadline;
		} else if (input.matches(Constants.REGEX_RECURRING_TASK_IDENTIFIER)) {
			logger.log(Level.INFO, "Recurring recognised");
			return TaskType.recurring;
		} else {
			logger.log(Level.INFO, "Floating recognised");
			return TaskType.floating;
		}
	}
	
	// ================================
	// Fourth Level of Abstraction
	// ================================
	
	/**
	 * This method searches for the regular expression representing end date for
	 * recurring tasks that starts with "until".
	 * 
	 * @param input
	 * 				string for recurring tasks input. not null.
	 * @return
	 * 				remaining string without until-string. not null.
	 * @throws Exception
	 */
	private String extractUntilLimiter(String input) throws Exception {
		String untilstring;
		Pattern until = Pattern.compile(Constants.REGEX_RECURRING_UNTIL);
		Matcher untilMatcher = until.matcher(input);
		if (untilMatcher.find()) {
			untilstring = getTrimmedString(input, untilMatcher.start(), input.length());
			separateDateTime(untilstring, "until"); //only run this if its until
			input = input.replaceFirst(untilstring, "");
			untilDateTime = LocalDateTime.of(untilDate, untilTime); //only run this if its until
		}
		return input;
	}

	/**
	 * This method searches for the regular expression representing end date for 
	 * recurring tasks that starts with "for".
	 * 
	 * @param input
	 * 				 string for recurring tasks input. not null.
	 * @param forstring
	 * 				for-string, contains "for" keyword and regular expression for number of intervals. 
	 * 				null value here returns unchanged input
	 * @return
	 * 				remaining string without for-string, not null
	 */
	private String extractForLimiter(String input) {
		String forstring = "";
		Pattern multiplier = Pattern.compile(Constants.REGEX_RECURRING_FOR);
		Matcher forMatcher = multiplier.matcher(input);
		if (forMatcher.find()) {
			forstring = getTrimmedString(input, forMatcher.start(), input.length());
		}
		return forstring;
	}
	
	/**
	 * This method extracts interval string from input. parses start date time string to process start date.
	 * calls parseFor to process forstring's count and interval. 
	 * 
	 * @param input
	 * 				non-null string containing interval and StartDateTime
	 * @param forstring
	 * 				"for" limiter. null if original input has no "for" limit specified
	 * @return
	 * 				interval string containing number and frequency of task. not null
	 * @throws Exception
	 */
	private String extractInterval(String input, 
			String forstring) throws Exception {
		String intervalString = "";
		Pattern interval = Pattern.compile(Constants.REGEX_RECURRING_INTERVAL2);
		Matcher intervalMatcher = interval.matcher(input);
		if (intervalMatcher.find()) {
			intervalString = getTrimmedString(input, intervalMatcher.start(), intervalMatcher.end());
			input = input.replaceFirst(intervalString, "").trim();
			parseInterval(intervalString);
			if (!input.isEmpty()) {
				parseDateTime(input,true);
			}
			
			if (!forstring.isEmpty()) {
				parseFor(forstring);	
			}
		}
		return intervalString;
	}

	
	/**
	 * This method will use the frequency from interval to obtain start date
	 * if user does not input the start date.
	 * 
	 * @param input  
	 * 			frequency from the user's input
	 * 			e.g. every 2 tuesday
	 * @throws Exception 
	 */
	private void getStartDateFromInterval(String input) throws Exception {
		String _freq = "";
		
		_freq = readFirstDayFromInterval(input);
		_freq = cleanString(_freq);
		
		DateParser DP = new DateParser();
		if (_freq.matches(Constants.REGEX_DAYS_TEXT) 
				|| _freq.matches(Constants.REGEX_RECURRING_INTERVAL_EVERYDAY)) {
			DP.parseDate(_freq);
		}

		startDate = DP.getDateObject();

		if (startDate.equals(LocalDate.MAX)) {
			startDate = LocalDate.now();
		}
 	
		if (tasktype.equals(TaskType.event)) {
			endDate = DP.getDateObject();
		}
	}
	
	//extract string and trims out whitespace
	private String getTrimmedString(String input, int startIndex, int endIndex) {
		return input.substring(startIndex, endIndex).trim();
	}
	
	
	private void setDateTime(String type, DateParser DP, TimeParser TP) {
		if (type.matches("start")) {
			startTime = TP.getTimeObject();
			startDate = DP.getDateObject();
		} else if (type.matches("until")) {
			untilTime = TP.getTimeObject();
			untilDate = DP.getDateObject();
		} else {
			endTime = TP.getTimeObject();
			endDate = DP.getDateObject();
		}
	}
	
	// ================================
	// Sixth Level of Abstraction
	// ================================
	
	private void processParallel(DateParser DP, TimeParser TP, String _date,
			String _time) throws Exception {
		_time = cleanString(_time);
		_date = cleanString(_date);
		DP.parseDate(_date);
		TP.processTime(_time);
	}
	
	// ================================
	// Fifth Level of Abstraction
	// ================================
	
	/**
	 * This method breaks down string into the interval and frequency to be stored in
	 * task object's interval object.
	 * 
	 * @param input      
	 * 			interval and frequency from user's input 
	 * 			e.g. every 5 weeks
	 * @throws Exception
	 */
	private void parseInterval(String input) throws Exception {
		input = input.replaceFirst("every","").trim();
		String _freq = "";
		int _interval = 1;
		if (input.contains("and") || input.contains("&") || input.contains(",")) {
			setDaysInWeek(input);
			_freq = "week";
		} else if (input.contains(" ")) { //assuming interval then frequency 
			String[] interval = input.split(" ");
			_interval = Integer.parseInt(interval[0]);
			_freq = interval[1];
		} else {
			_freq = input;
		}
		setInterval(_interval, _freq);
	}
	
	/**
	 * This method calculates count for the recurring tasks to be repeated
	 * 
	 * @param input
	 * 				contains number of repetition (integer, after parsing) 
	 * 				and length of each occurrence (string)
	 * @throws Exception
	 */
	private void parseFor(String input) throws Exception {//for x weeks
		int numberOf = 0, multiplier = 1, count = 0;
		String forFreq = "";
		String[] temp = input.split(" ");
		
		if (hasNumber(temp[1])) {
			numberOf = Integer.parseInt(temp[1]);
			forFreq = temp[2];
		} else {
			throw new Exception("Invalid count");
		}
		
		if (!forFreq.matches("times")) {
			multiplier = getMultiplier(forFreq, TO.getInterval().getFrequency());	
		}
		
		count = multiplier * numberOf / TO.getInterval().getTimeInterval();
		TO.getInterval().setCount(count);
	}
	
	/**
	 * This method will look for the first day in the interval string that corresponds
	 * to a day of the week.
	 * 
	 * @param input 
	 * 				interval string. non null.
	 * @return
	 * 				returns day-of=the-week or "everyday" to be parsed by DateParser
	 */
	private String readFirstDayFromInterval(String input) {
		String _freq;
		if (!input.matches(Constants.REGEX_RECURRING_INTERVAL_EVERYDAY)) {
			input = input.replaceFirst("every","").trim();
			if (input.contains(" ") && hasNumber(input)) {
				//single day in interval
				String[] interval = input.split(" ");
				_freq = interval[1];
			} else if (input.contains(" ")) {
				//multiple days in interval
				_freq = getNextNearestDayInInterval();
			} else {
				//single day in interval
				_freq = input;
			}
		} else {
			//user input "everyday"
			_freq = input;
		}
		return _freq;
	}
	
	/**
	 * This method removes keywords for identifying task. It takes into account for 
	 * special exceptions such as today, monday and words containing identifier keywords.
	 * 
	 * @param input
	 * 				any general string. non-null.
	 * @return
	 */
	private String cleanString(String input) {
		input = input.replaceAll("[,]+", "").trim();
		if (input.contains("today") || input.contains("tomorrow")) {
			return input.replaceAll(Constants.REGEX_TASK_IDENTIFIER_2, "").trim(); //trim specially
		} else if (input.contains("tonight")) {
			return input.replaceAll(Constants.REGEX_TASK_IDENTIFIER_6, "").trim(); //trim specially
		} else if (input.contains("saturday") || input.contains("sat")) {
			input = input.replaceAll(Constants.REGEX_TASK_IDENTIFIER_3, "").trim();
			if (input.startsWith("at")) {
				return input.replaceFirst("at", "").trim();
			}
			return input;
		} else if (input.contains("mon") || input.contains("monday")) {
			input = input.replaceAll(Constants.REGEX_TASK_IDENTIFIER_4, "").trim();
			if (input.startsWith("on")) {
				return input.replaceFirst("on", "").trim();
			}
			return input;
		} else if (input.contains(Constants.REGEX_RECURRING_INTERVAL_EVERYDAY)) {
			return input.replaceAll(Constants.REGEX_TASK_IDENTIFIER_5,"").trim();
		} else {
			return input.replaceAll(Constants.REGEX_TASK_IDENTIFIER, "").trim();	
		}
	}
	
	// ================================
	// Sixth Level of Abstraction
	// ================================
	
	/**
	 * This method sets byDay array in interval object according to the days that are present
	 * 
	 * @param input
	 * 				string containing days which the task falls on. not null 
	 * 
	 */
	private void setDaysInWeek(String input) { //monday and tuesday ??
		input = input.toLowerCase();
		
		if (input.contains("mon") || input.contains("monday")) {
			TO.getInterval().setByDay(1);
		}
		if (input.contains("tue") || input.contains("tues") 
				|| input.contains("tuesday")) {
			TO.getInterval().setByDay(2);
		}
		if (input.contains("wed") || input.contains("wednesday")) {
			TO.getInterval().setByDay(3);
		} 
		if (input.contains("thur") || input.contains("thurs") 
				|| input.contains("thursday")) {
			TO.getInterval().setByDay(4);
		} 
		if (input.contains("fri") || input.contains("friday")) {
			TO.getInterval().setByDay(5);
		}
		if (input.contains("sat") || input.contains("saturday")) {
			TO.getInterval().setByDay(6);
		}
		if (input.contains("sun") || input.contains("sunday")) {
			TO.getInterval().setByDay(7);
		}
	}
	
	private void setInterval(int interval, String frequency) throws Exception {
		frequency = getFormattedFrequency(frequency);
		TO.getInterval().setTimeInterval(interval);
		TO.getInterval().setFrequency(frequency);
		TO.getInterval().setUntil(untilDateTime);
	}
	
	/**
	 * This method checks if the string starts with a number.
	 * 
	 * @param input
	 * 				date input with interval such as a day of the week, "weeks" or "months" 
	 * 				with integer in front as a multiplier
	 * @return
	 */
	private boolean hasNumber(String input) {
		String[] interval = input.split(" ");
		if (interval[0].matches("[\\d]+")) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * This method returns multiplier for calculating the task's interval count
	 * for example, every day for 1 month will return 30 as there are 30 days in a month on average.
	 * 
	 * @param forInput
	 * 				date frequency such as weeks or months. not null
	 * @param intervalInput
	 * 				date frequency such as weeks or months, not null
	 * @return
	 * 				multiplier (integer) based on the relationship between intervalinput and forinput
	 * @throws Exception
	 */
	private int getMultiplier(String forInput, String intervalInput) throws Exception {
		forInput = getFormattedFrequency(forInput);
		if (forInput.matches(Constants.FREQ_DAILY) 
				&& intervalInput.matches(Constants.FREQ_DAILY)) {
			return 1;
		} else if (forInput.matches(Constants.FREQ_WEEKLY) 
				&& intervalInput.matches(Constants.FREQ_DAILY)) {
			return 7;
		} else if (forInput.matches(Constants.FREQ_MONTHLY) 
				&& intervalInput.matches(Constants.FREQ_DAILY)) {
			return 31; //or 30?
		} else if (forInput.matches(Constants.FREQ_YEARLY) 
				&& intervalInput.matches(Constants.FREQ_DAILY)) {
			return 365;
		} else if (forInput.matches(Constants.FREQ_WEEKLY) 
				&& intervalInput.matches(Constants.FREQ_WEEKLY)) {
			return 1;
		} else if (forInput.matches(Constants.FREQ_MONTHLY) 
				&& intervalInput.matches(Constants.FREQ_WEEKLY)) {
			return 4;
		} else if (forInput.matches(Constants.FREQ_MONTHLY) 
				&& intervalInput.matches(Constants.FREQ_MONTHLY)) {
			return 1;
		} else if (forInput.matches(Constants.FREQ_YEARLY) 
				&& intervalInput.matches(Constants.FREQ_MONTHLY)) {
			return 12;
		} else if (forInput.matches(Constants.FREQ_YEARLY) 
				&& intervalInput.matches(Constants.FREQ_YEARLY)) {
			return 1;
		} else {
			throw new Exception("Invalid date input, recurrence larger than interval"); 
		}
		
	}
	
	/**
	 * This method searches for the next available day in the week that the user entered 
	 * in the interval.
	 * 
	 * @return
	 * 				day of the week in string format. not null. 
	 */
	private String getNextNearestDayInInterval() {
		int start = 0;
		int now = LocalDate.now().getDayOfWeek().getValue();
		
		for (int i = now; i < TO.getInterval().getByDayArray().length ; i++) {
			if (TO.getInterval().getByDayArray()[i] == 1) {
				start = i;
				break;
			}
			start = i;
		}

		if (start == 7 && TO.getInterval().getByDayArray()[7] == 0) {
			//get from behind the now
			for (int i = 1; i < now ; i++) {
				if (TO.getInterval().getByDayArray()[i] == 1) {
					start = i;
					break;
				}
			}
		}
		return getDayInWeek(start);
	}

	// ================================
	// Seventh Level of Abstraction
	// ================================
	
	/**
	 * This method returns corresponding date to a given number from 1 - 7.
	 * 
	 * @param index
	 * 				number of the day in the week (1 - monday, 2 - tuesday, etc)
	 * @return
	 * 				returns corresponding day in string. not null.
	 */
	private String getDayInWeek(int index) {
		if (index == 1) {
			return Constants.DAY_1;
		} else if (index == 2) {
			return Constants.DAY_2;
		} else if (index == 3) {
			return Constants.DAY_3;
		} else if (index == 4) {
			return Constants.DAY_4;
		} else if (index == 5) {
			return Constants.DAY_5;
		} else if (index == 6) {
			return Constants.DAY_6;
		} else if (index == 7) {
			return Constants.DAY_7;
		} else {
			return "";
		}
	}
	
	/**
	 * This method returns the frequency type based on input string, in standardised format.
	 * 
	 * @param frequency
	 * 				frequency extracted from interval. non-null. e.g. years, days, etc.
	 * @return
	 * 				frequency of occurence in string. not null. 
	 */
	private String getFormattedFrequency(String frequency) {
		if (frequency.matches(Constants.REGEX_DAYS_TEXT)
				|| frequency.matches("(week|wk)(s)?")) {
			frequency = Constants.FREQ_WEEKLY;
		} else if (frequency.matches("(year|yr)(s)?")) {
			frequency = Constants.FREQ_YEARLY;
		} else if (frequency.matches(Constants.REGEX_MONTHS_TEXT) 
				|| frequency.matches("(month|mth)(s)?")) {
			frequency = Constants.FREQ_MONTHLY;
		} else if (frequency.matches("(day)(s)?")) {
			frequency = Constants.FREQ_DAILY;
		}
		return frequency;
	}
	
	//Getter methods for testing purposes.
	public LocalDateTime getStartDateTime() {
		return startDateTime;
	}
	
	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}
}
```
###### \src\parser\EditParser.java
``` java
package parser;

import common.TaskObject;
import java.time.LocalDateTime;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * This class is the child class of CommandParser. It's public method, process(), will
 * split the string into two components, "task" and "date-time" if either are present. 
 * EditParser will call DateTimeParser to process the DateTime string. EditParser will 
 * also identify the index for the task to be edited. 
 * 
 * @author sylvesterchin
 */
public class EditParser extends CommandParser {

	private TaskObject TO = new TaskObject();

	private int _index = -1;
	
	/**
	 * This method will take in the string from the parser and break down its component, 
	 * determining if it is a task, time or date edit.
	 * 
	 * @param input
	 * 				user's input for editing task in the list. non-null. contains index number and
	 * 				attributes to edit
	 * 				
	 * @throws Exception 
	 */
	public TaskObject process(String input) throws Exception {
		convertToArray(input); //change this to extract index
		input = cleanString(input);
		
		Pattern dateTimePattern = Pattern.compile(Constants.REGEX_SEARCH2);
		Matcher matcher = dateTimePattern.matcher(input);
		
		String identifier = null;
		
		if (matcher.find()) {
			identifier = getTrimmedString(input ,matcher.start(), matcher.end());
			input = getTrimmedString(input, 0, matcher.start());
		}
		
		if (identifier != null) {
			DateTimeParser dtp = new DateTimeParser();
			TO = dtp.parse(identifier, false);
        }
		
		_task = input;
		setTaskObject();
		return TO;
	}
	
	private void setTaskObject() {
		TO.setTitle(_task);
	}
	
	/**
	 * This method will convert instruction into string array list
	 * and remove the "edit" and number.
	 * 
	 * @param input
	 * 				string for edit command. non-null.
	 */
	private void convertToArray(String input) {
		int index = 0;
		index = input.indexOf(" ");
		if (index != -1) {
			_index = Integer.parseInt(input.substring(0, index));	
		} else {
			_index = Integer.parseInt(input);
		}
	}
	
	/**
	 * This method will re-form the command that the user input
	 * without "edit" and the index number.
	 * 
	 * @param input
	 * 				string input for editing. non null.
	 * 				
	 */
	private String cleanString(String input) { //remove the number
		if (input.matches("[\\d]+")) {
			return "";
		}
		input = input.replaceFirst("[\\d]+ ", "").trim();
		return input;
	}

	//Getter methods for testing purposes
	public String getTask() {
		return _task;
	}

	public void setTask(String task) {
		_task = task;
	}

	public LocalDateTime getStartDateTime() {
		return _startDateTime;
	}
	
	public LocalDateTime getEndDateTime() {
		return _endDateTime;
	}
	
	/**
	 * This method returns index of task to be edited to parser, 
	 */
	public int getIndex() {
		return _index;
	}
}
```
###### \src\parser\Parser.java
``` java
package parser;

import common.AtfLogger;
import common.CommandObject;
import common.TaskObject;

import java.time.LocalDateTime;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * This class takes in the user's input and processes it, identifying the command type
 * and details of the command to exeucute.
 *  
 * This class will be the only class from the parser component which interacts
 * with the logic. Logic will initialise a parser object with the command and 
 * unique taskID and call run(). 
 * 
 * Parser will call the relevant method to process the command which the user has input. 
 * 
 * @author sylvesterchin
 *
 */
public class Parser {
	public CommandObject CO = new CommandObject();
	public TaskObject TO = new TaskObject();
	private static Logger logger = AtfLogger.getLogger();
	private String _command;
	private int _taskId;
	
	/**
	 * This is the general constructor for testing purposes.
	 */
	public Parser() {
	}
	
	/**
	 * This method constructs the parser object and assigns the command and a internally 
	 * system generated taskID.
	 * 
	 * @param command  
	 * 				user's input into the system of String type.
	 * @param taskId   
	 * 				system generated ID.
	 */
	public Parser(String command, int taskId) {
		_command = command;
		_taskId = taskId;
	}
	
	/**
	 * This method runs the methods to process the command and returns command object
	 * to Logic.
	 * 
	 * @return CO 
	 * 				command object that contains task description and task object
	 * @throws Exception 
	 */
	public CommandObject run() throws Exception {
		allocate(_command);
		return CO;
	}
	
	/**
	 * This method reads string and trigger the relevant method to process string's information
	 * using a set of if-else conditions to check for task-related keywords. If keywords are absent, 
	 * it will be processed as a search.
	 * 
	 * @param command  
	 * 				user's input to the program, not null.
	 * @throws Exception 
	 */
	public void allocate(String command) throws Exception {
		assert(!command.isEmpty()); //ensure command is a proper string
		
		command = command.trim();
		
		if (isMatch(Constants.REGEX_PARSER_EXIT, command)) {
			logger.log(Level.INFO, "Exit command called.");
			CO.setCommandType(Constants.INDEX_EXIT);
		} else if (isMatch(Constants.REGEX_PARSER_HELP, command)) {
			parseHelp(command);
		} else if (command.matches(Constants.REGEX_PARSER_UNDO)) {
			logger.log(Level.INFO, "Undo command called.");
			CO.setCommandType(Constants.INDEX_UNDO);
		} else if (isMatch(Constants.REGEX_PARSER_REDO, command)) {
			logger.log(Level.INFO, "Redo command called.");
			CO.setCommandType(Constants.INDEX_REDO);
		} else if (isMatch(Constants.REGEX_PARSER_EDIT, command)) {
			parseEdit(command);
		} else if (isMatch(Constants.REGEX_PARSER_SAVE, command)) {
			parseSave(command);
		} else if (isMatch(Constants.REGEX_PARSER_DELETE, command)) {
			parseDelete(command);
		} else if (isMatch(Constants.REGEX_PARSER_ADD, command)) {
			parseAdd(command);
		} else if (isMatch(Constants.REGEX_PARSER_DONE, command)) {
			parseDone(command);
		} else if (isMatch(Constants.REGEX_PARSER_NOTDONE, command)) {
			parseNotDone(command);
		} else if (isMatch(Constants.REGEX_PARSER_SEARCH, command)) {
			parseSearch(command);
		} else if (isMatch(Constants.REGEX_PARSER_LOAD, command)) {
			parseLoad(command);
		} else {
			parseSearch(command);
		}
  	}
	
	// ================================
	// First Level of Abstraction
	// ================================
	
	private boolean isMatch(String input, String command) {
		Pattern dateTimePattern = Pattern.compile(input);
		Matcher matcher = dateTimePattern.matcher(command);
		return matcher.find();
	}
	
	/**
	 * This method returns help index to CommandObject and a search term if present.
	 *  
	 * @param command
	 * 				string input that represents a help command.
	 */
	private void parseHelp(String command) {
		logger.log(Level.INFO, "Help command called.");
		CO.setCommandType(Constants.INDEX_HELP);
		command = command.replaceFirst("(?i)(help )", "");
		TO.setTitle(command);
		CO.setTaskObject(TO);
	}
	
	/**
	 * This method sets command type and index of the task to be marked as done.
	 * 
	 * @param  command
	 * 				string input that represent a done command.
	 */
	private void parseDone(String command) {
		int temp = command.indexOf(" ");
		if (temp != -1) {
			logger.log(Level.INFO, "Done command called.");
			CO.setCommandType(Constants.INDEX_DONE);
			command = command.substring(temp + 1);
			temp = Integer.parseInt(command);
			CO.setIndex(temp);	
		} else {
			logger.log(Level.INFO, "Search command called.");
			CO.setCommandType(Constants.INDEX_SEARCH);
			TO.setStatus("completed");
			CO.setTaskObject(TO);
		}
	}
	
	/**
	 * This method sets command type and index of task to be marked as incomplete.
	 * 
	 * @param command
	 * 				string input that represents a not-done command.
	 */
	private void parseNotDone(String command) {
		logger.log(Level.INFO, "Not-done command called.");
		int temp = command.indexOf(" ");
		if (temp != -1) {
			CO.setCommandType(Constants.INDEX_NOTDONE);
			command = command.substring(temp + 1);
			temp = Integer.parseInt(command);
			CO.setIndex(temp);	
		} else {
			CO.setCommandType(Constants.INDEX_SEARCH);
			TO.setStatus("incomplete");
			CO.setTaskObject(TO);
		}
	}
	
	/**
	 * This method sets command type, index of task to edit and attributes to edit.
	 * 
	 * @param command   
	 * 				user's input for the system, such as "edit 5 6pm start".
	 * @throws Exception 
	 */
	private void parseEdit(String command) throws Exception {
		logger.log(Level.INFO, "Edit command called.");
		CO.setCommandType(Constants.INDEX_EDIT);
		boolean isEditAllRecurring = false;
		
		if (command.toLowerCase().startsWith("edit all") 
				|| command.toLowerCase().startsWith("update all")) {
			System.out.println(command);
			command = command.replaceFirst("(?i)((edit|update) all)", "").trim();
			isEditAllRecurring = true;
		} else {
			command = command.replaceFirst(Constants.REGEX_PARSER_EDIT, "").trim();
		}
		
		CommandParser EP = new EditParser();
		TO = EP.process(command);
		
		if (isEditAllRecurring) {
			TO.setIsRecurring(true);
			TO.setIsEditAll(true);
		}
		
		CO.setTaskObject(TO);
		CO.setIndex(EP.getIndex());
	}
	
	/**
	 * This method sets command type and creates task object with details keyed in by user.
	 * 
	 * @param command   
	 * 				string input that represents an add command.
	 * @throws Exception 
	 */
	private void parseAdd(String command) throws Exception {
		logger.log(Level.INFO, "Add command called.");
		CO.setCommandType(Constants.INDEX_ADD);
		CommandParser AP = new AddParser();
		command = command.replaceFirst(Constants.REGEX_PARSER_ADD, "").trim();
		TO = AP.process(command);
		TO.setTaskId(_taskId);
		setCategory();
		CO.setTaskObject(TO);
	}
	
	/**
	 * This method sets command type and creates task object with details entered by user 
	 * for search purpose.
	 * 
	 * @param command   
	 * 				string input that represents a search command.
	 * @throws Exception 
	 */
	private void parseSearch(String command) throws Exception {
		logger.log(Level.INFO, "Search command called.");
		CO.setCommandType(Constants.INDEX_SEARCH);
		CommandParser SP = new SearchParser();

		// if there is no search keyword, set TaskObject values to null/-1
		if (command.indexOf(" ") == -1 && isMatch(Constants.REGEX_PARSER_SEARCH,command)) {
			TO.setStartDateTime(LocalDateTime.MAX);
			TO.setEndDateTime(LocalDateTime.MAX);
		} else {
			command = command.replaceFirst(Constants.REGEX_PARSER_SEARCH, "").trim();
			TO = SP.process(command);
			CO.setIndex(SP.getIndex());
		}
		CO.setTaskObject(TO);
	}
	
	/**
 	 * This method sets command type for delete commands and keyword "all" if included.
 	 * 
 	 * @param command 
 	 * 				user's input as a string for deleting.
 	 * @throws Exception 
 	 */
	private void parseDelete(String command) throws Exception {
		logger.log(Level.INFO, "Delete command called.");
 		CO.setCommandType(Constants.INDEX_DELETE);
 		int index;
 		index = extractDeleteIndex(command);
 		CO.setIndex(index);
 		if (index > 0 && command.contains("all")) {
 			TO.setIsEditAll(true);
 			TO.setTitle("all");
 		} else if (index == 0 && command.contains("done")) {
 			TO.setStatus("completed");
 		}
 		CO.setTaskObject(TO);	
 	}
	
	/**
 	 * This method sets command type for command object and returns file path.
 	 * 
 	 * @param command 
 	 * 				string input that represents a save command.
 	 * @throws Exception 
 	 */
	private void parseSave(String command) throws Exception {
		logger.log(Level.INFO, "Save command called.");
 		CO.setCommandType(Constants.INDEX_SAVE);
 		String newString;
 		int index = command.indexOf(" ") + 1;
 		if (command.length() > index) {
 			newString = command.substring(index);
 	 		TO.setTitle(newString);
 	 		CO.setTaskObject(TO);	
 		} else {
 			throw new Exception("Filepath missing");
 		}
 	}
	
	/**
	 * This method sets command type for command object and specifies type of load, 
	 * (1) backup or (2) specific file.
	 * 
	 * @param command
	 * 					user input with load command. non-null.
	 * @throws Exception
	 */
	private void parseLoad(String command) throws Exception {
		logger.log(Level.INFO, "Load command called.");
		CO.setCommandType(Constants.INDEX_LOAD);
 		String newString;
 		int index = command.indexOf(" ") + 1;
 		
 		if (command.length() > index) {
 			if (command.contains("backup")) {
 				newString = "backup";
 			} else {
 				newString = command.substring(index);
 			}
 	 		TO.setTitle(newString);
 	 		CO.setTaskObject(TO);	
 		} else {
 			throw new Exception("Filepath missing");
 		}
	}
	
	// ================================
	// Second Level of Abstraction
	// ================================
	
	private void setCategory() {
		if (isFloating()) {
			TO.setCategory(Constants.TaskType.floating.toString());
		} else if (isDeadline()) {
			TO.setCategory(Constants.TaskType.deadline.toString());
		}  else {
			TO.setCategory(Constants.TaskType.event.toString());
		}
	}
	
	private boolean isFloating() {
		if (TO.getEndDateTime().equals(LocalDateTime.MAX) 
				&& TO.getStartDateTime().equals(LocalDateTime.MAX)) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean isDeadline() {
		if (TO.getEndDateTime().equals(LocalDateTime.MAX)) {
			return true;
		} else {
			return false;
		}
	}

 	
 	/**
 	 * This method returns the number that is after the delete command as an integer.
 	 * 
 	 * @param command
 	 * 				string input that represents a delete command.
 	 * @throws Exception 
 	 */
	private int extractDeleteIndex(String command) throws Exception {		
 		String newString;
 		if (command.indexOf(" ") == -1) {
 			//quick delete
 			return -1; 
 		} else if (command.replaceFirst(Constants.REGEX_PARSER_DELETE, "").trim().matches("(?i)(all)")) {
 			TO.setIsEditAll(true); 
 			return 0;
 		} else if (command.replaceFirst(Constants.REGEX_PARSER_DELETE, "").trim().matches("(?i)(done)")) {
 			return 0;
 		} else {
	 		int index = command.indexOf(" ") + 1;
	 		newString = command.substring(index).replaceAll("[a-zA-Z]+", "").trim();
 		} 		
	 	return Integer.parseInt(newString);
 	}
 	
 	//All the getters for testing purposes.
 	
 	public int getCommandType() {
 		return CO.getCommandType();
 	}

 	public String getTask() {
 		return TO.getTitle();
 	}
 	
 	public LocalDateTime getStartDateTime() {
 		return TO.getStartDateTime();
 	}
 	
 	public LocalDateTime getEndDateTime() {
 		return TO.getEndDateTime();
 	}
 	
 	public String getStatus() {
 		return TO.getStatus();
 	}
 	
 	public String getCategory() {
 		return TO.getCategory();
 	}
 	
 	public void resetTaskObj() {
 		TO.resetAttributes();
 	}
 	
 	public int getCommandTask() {
 		return CO.getCommandType();
 	}
}
```
###### \src\parser\SearchParser.java
``` java
package parser;

import common.TaskObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class is a child class of CommandParser. It takes in a string and checks if
 * it is searching for a category, recurring dates, by status or by the standard attributes (
 * task, date and time). Creates a Task Object to be returned to the Parser object. 
 * 
 * @author sylvesterchin
 *
 */
public class SearchParser extends CommandParser {
	private TaskObject TO = new TaskObject();
	private int index = -1;
	
	/**
	 * This method checks if the search command is looking for category, recurring dates, status,
	 * task, date or time and calls the appropriate function.
	 * 
	 * @param input
	 * 				string input for search command, non-null
	 * 				
	 */
	public TaskObject process(String input) throws Exception {
		input = removeSearchKeyword(input);
		if (isSearchByCategory(input)) {
			setCategory(input);
		} else if (isSearchForRecurringDates(input)) {
			setIndex(input);
		} else if (isSearchByStatus(input)) {
			setStatus(input);
		} else {
			searchTaskDateTime(input);
		}
		return TO;
	}

	/**
	 * This method will look for date-time pattern and call the DateTimeParser if needed.
	 * Also, it sets the task description if that is the user's input.
	 * 
	 * @param input
	 * 				string input for search command, non-null
	 * @throws Exception
	 */
	private void searchTaskDateTime(String input) throws Exception {
		Pattern dateTimePattern = Pattern.compile(Constants.REGEX_SEARCH);
		Matcher matcher = dateTimePattern.matcher(input);
		
		String identifier = null;
		
		if (matcher.find()) {
			identifier = getTrimmedString(input ,matcher.start(), input.length());
			input = getTrimmedString(input, 0, matcher.start());
		}
		
		if (identifier != null) {
			DateTimeParser dtp = new DateTimeParser();
			TO = dtp.parse(identifier, false);
		}
		
		_task = input;

		setTaskObject();
	}
	
	private boolean isSearchByStatus(String input) {
		return input.matches("(?i)(done|completed)");
	}
	
	private void setStatus(String input) {
		TO.setStatus("completed");
	}
	
	private boolean isSearchForRecurringDates(String input) {
		return input.matches("[\\d]+");
	}
	
	private void setIndex(String input) {
		index = Integer.parseInt(input);
	}
	
	private boolean isSearchByCategory(String input) {
		return input.matches("(floating|deadline|event)");
	}
	
	private void setCategory(String input) {
		if (input.matches("floating")) {
			TO.setCategory("floating");
		} else if (input.matches("deadline")) {
			TO.setCategory("deadline");
		} else if (input.matches("event")) {
			TO.setCategory("event");	
		}
	}
	
	private void setTaskObject() {
		TO.setTitle(_task);
	}
	
	private String removeSearchKeyword(String input) {
		return input.replaceFirst(Constants.REGEX_PARSER_SEARCH, "").trim();
	}
	
	//Getter for testing purpose
	public String getTask() {
		return _task;
	}

	@Override
	public int getIndex() {
		return index;
	}
}
```
###### \src\parser\TimeParser.java
``` java
package parser;

import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

/**
 * This class's job is to identify the correct time from a user's string input.
 * It recognises time in 2 main formats, hh:mm and hh:mm AM/PM. 
 * 
 * @author sylvesterchin
 *
 */
public class TimeParser {
	private int time = -1;
	private int pmConverter = 1200;
	private int makeInvalid = 9999;
	private int timeFormatter = 100;
	private int midnight = 2400;
	private int standardTimeLength = 4;
	private int pmLowerLimit = 2359;
	private int pmUpperLimit = 2460;
	private int amLowerLimit = 1159;
	private int amUpperLimit = 1260;
	private int invalidLimit = 1259;	
	private String timeString = "";
	private LocalTime timeObject = LocalTime.MAX;
	
	/**
	 * This method takes in the user's input from add/edit/search parser, checks if empty
	 * and processes it into a LocalTime variable.
	 * 
	 *@param input  
	 *				time input from user. null input results in nothing being done
	 *				e.g. 21:59hr, 7.13pm
	 * @throws Exception 
	 */
	public void processTime(String input) throws Exception {
		if (!input.isEmpty()) {
			furtherProcessTime(input);
			createLocalTimeObject();
		}
	}
	
	// ================================
	// First Level of Abstraction
	// ================================
	
	/**
	 * This method will check process the time input by recognizing am/pm/hr
	 * 
	 * @param input   
	 * 				time input from user, non-null string
	 */
	private void furtherProcessTime(String input) {
		if (isAM(input)) {
			setTime(input, false);
		} else if (isPM(input)) {
			setTime(input, true);
		} else if (isHr(input)) {
			setTime(input, false);
		}
	}
	
	/**
	 * This method will convert time from integer format in HHmm to string format in HH:mm 
	 * and create LocalTime object.
	 * 
	 * @throws Exception 
	 */
	private void createLocalTimeObject() throws Exception {
		String minute, hour;
		DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");
		
		if (time < 1000 && time > 99) {
			minute = "0" + Integer.toString(time);
		} else if (time < 1000 && time > 9) {
			minute = "00" + Integer.toString(time);
		} else if (time < 1000 && time < 100) {
			minute = "000" + Integer.toString(time);
		} else {
			minute = Integer.toString(time);
		}
		
		if ((minute.length() == standardTimeLength && time < midnight) || minute.matches("0000")) {
			hour = minute.substring(0, 2);
			minute = minute.substring(2);
			timeString = hour + ":" + minute;
			timeObject = LocalTime.parse(timeString, timeFormatter);	
		} else {
			throw new Exception("Invalid Time");
		}
	}
	
	// ================================
	// Second Level of Abstraction
	// ================================
	
	/**
	 * This method cleans the string and converts to the integer form. 
	 * It will be manipulated into HHMM format.
	 * 
	 * @param input
	 * 				time input in string format. non null. 
	 * @param isPM
	 * 				boolean, true if the time input has "PM" in it
	 */
	private void setTime(String input, boolean isPM) {
		if (input.matches(Constants.REGEX_TIME_HHMM)) {
			input = input.replaceAll("[:!-/a-zA-Z]+", "").trim();
			time = Integer.parseInt(input);
		} else {
			input = input.replaceAll("[:!-/a-zA-Z]+", "");
			input = input.replaceAll(" ", "");
			int _time = 0;
			_time = Integer.parseInt(input);
			time = timeConverter(isPM, _time);	
		}
	}
	
	private boolean isPM(String temp) {
		return temp.contains("pm");
	}

	private boolean isAM(String temp) {
		return temp.contains("am");
	}
	
	private boolean isHr(String temp) {
		return temp.contains("hr") || temp.contains("hour");
	}
	
	// ================================
	// Third Level of Abstraction
	// ================================
	
	/**
	 * This method will convert input time into a number that is within the range of 
	 * 0-2400 if the input is a valid time. 
	 * 
	 * @param isPM
	 * 				boolean to show if the original input had a "pm" marker.
	 * @param _time
	 * 				time input by user. positive, non-null. 
	 * @return
	 */
	private int timeConverter(boolean isPM, int _time) {
		if (_time < timeFormatter) { //converts time to 4 digit format
			_time = _time * timeFormatter;
		}
		
		if (isPM) { //converts timing to correct value
			_time = _time + pmConverter;
			if (_time > pmLowerLimit && _time < pmUpperLimit ) {
				_time = _time - pmConverter;
			}
		} else if (!isPM && _time > amLowerLimit && _time < amUpperLimit) { //only for 12.xxam cases
			_time = _time - pmConverter;
		} else if (!isPM && _time > invalidLimit) {
			_time = _time + makeInvalid; // anything more than 12.59am will be rendered invalid
		}
		return _time;
	}
	
	/**
	 * Getter method for test in JUnit environment.
	 * 
	 * @return 
	 * 				LocalTime variable
	 */
	public LocalTime getTimeObject() {
		return timeObject;
	}
	
	
}
```
###### \src\parsertest\AddParserTest.java
``` java
package parsertest;



import static org.junit.Assert.assertEquals;

import java.time.LocalDateTime;

import org.junit.Test;

import common.TaskObject;
import parser.AddParser;

public class AddParserTest {
	AddParser AP = new AddParser();
	TaskObject TO = new TaskObject();
	
	//--test adding floating task
	//partition for all general string without identifiable date time
	@Test
	public void testA() throws Exception {
		TO = AP.process("buy homework");
		
		//Basic Details
		assertEquals("buy homework", TO.getTitle());
		assertEquals(LocalDateTime.MAX, TO.getStartDateTime());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
		assertEquals("incomplete", TO.getStatus());
	}
	
	//--test adding deadline with date and time
	//all date time format should work if date time parser works, hence
	//it is considered the same test case
	@Test
	public void testB() throws Exception {
		TO = AP.process("buy eggs by next sat 19.13hrs");
		
		//Basic Details
		assertEquals("buy eggs", TO.getTitle());
		assertEquals("2016-04-23T19:13", TO.getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
		assertEquals("incomplete", TO.getStatus());
	}
	
	//--test adding event with date and time
	//all date time format should work if date time parser works, hence
	//it is considered the same test case	
	@Test
	public void testC() throws Exception {
		TO = AP.process("bdae partee from next sun 9am to 10pm");
		
		//Basic Details
		assertEquals("bdae partee", TO.getTitle());
		assertEquals("2016-04-24T09:00", TO.getStartDateTime().toString());
		assertEquals("2016-04-24T22:00", TO.getEndDateTime().toString());
		assertEquals("incomplete", TO.getStatus());
	}
	
	//--test adding recurring deadline with date and time and fixed termination date
	@Test
	public void testD() throws Exception {
		TO = AP.process("dota time every friday at 11pm until 9 may");
		
		//Basic Details
		assertEquals("dota time", TO.getTitle());
		assertEquals("2016-04-15T23:00", TO.getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
		assertEquals("incomplete", TO.getStatus());
		
		//Interval Details
		assertEquals("2016-05-09T23:59:59.999999999", TO.getInterval().getUntil().toString());
		assertEquals("WEEKLY", TO.getInterval().getFrequency());
		assertEquals(1, TO.getInterval().getTimeInterval());
	}
	
	//--test adding recurring deadline with date and time and specified count til termination date
	@Test
	public void testE() throws Exception {
		TO = AP.process("dota time every 2 friday at 11pm for 2 months");
		
		//Basic Details
		assertEquals("dota time", TO.getTitle());
		assertEquals("2016-04-15T23:00", TO.getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
		assertEquals("incomplete", TO.getStatus());

		//Interval Details
		assertEquals(4, TO.getInterval().getCount());
		assertEquals("WEEKLY", TO.getInterval().getFrequency());
		assertEquals(2, TO.getInterval().getTimeInterval());
	}
	
	//--test adding recurring deadline without termination date
	@Test
	public void testF() throws Exception {
		TO = AP.process("dota time every saturday at 11pm");
		
		//Basic Details
		assertEquals("dota time", TO.getTitle());
		assertEquals("2016-04-16T23:00", TO.getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
		assertEquals("incomplete", TO.getStatus());

		//Interval Details
		assertEquals(-1, TO.getInterval().getCount());
		assertEquals("WEEKLY", TO.getInterval().getFrequency());
		assertEquals(1, TO.getInterval().getTimeInterval());
		assertEquals(LocalDateTime.MAX, TO.getInterval().getUntil());
	}
	
	@Test
	public void testG() throws Exception {
		TO = AP.process("dota time every sunday");
		
		//Basic Details
		assertEquals("dota time", TO.getTitle());
		assertEquals("2016-04-17T23:59:59.999999999", TO.getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
		assertEquals("incomplete", TO.getStatus());
		
		//Interval Details
		assertEquals("+999999999-12-31T23:59:59.999999999", TO.getInterval().getUntil().toString());
		assertEquals("WEEKLY", TO.getInterval().getFrequency());
		assertEquals(1, TO.getInterval().getTimeInterval());
	}
}
```
###### \src\parsertest\DateParserTest.java
``` java
package parsertest;

import static org.junit.Assert.assertEquals;
import java.time.LocalDate;
import org.junit.Test;
import parser.DateParser;

public class DateParserTest {

	DateParser DP = new DateParser();
	
	/*POSITIVE VALUE PARTITION CASES*/		
	/*case 1: test ability to read ddmm formats*/
	@Test
	public void testA() throws Exception {	
		DP.parseDate("7/6");
		assertEquals("2016-06-07", DP.getDateObject().toString());
		reset();
	}
	
	/*case 2: test ability to read ddmonthyyyy formats*/
	@Test
	public void testB() throws Exception {
		DP.parseDate("6 june 2014");
		assertEquals("2014-06-06", DP.getDateObject().toString());
		reset();
	}
	
	/*case 3: test ability to read ddmmyyyy formats*/
	@Test
	public void testC() throws Exception {
		DP.parseDate("5/6/16");
		assertEquals("2016-06-05", DP.getDateObject().toString());
		reset();
	}
	
	/*case 4: test ability to read relative dates*/
	@Test
	public void testD() throws Exception {
		DP.parseDate("next friday");
		assertEquals("2016-04-22", DP.getDateObject().toString());
		reset();
	}
	
	/*case 5: boundary value for positive-value partition (31)*/
	@Test
	public void testE() throws Exception {
		DP.parseDate("31 july 2000");
		assertEquals("2000-07-31", DP.getDateObject().toString());
		reset();
	}
	
	/*case 6: boundary value for positive-value partition (31)*/
	@Test
	public void testF() throws Exception {
		DP.parseDate("31/12/2000");
		assertEquals("2000-12-31", DP.getDateObject().toString());
		reset();
	}
	
	/*case 7: reading relative dates*/
	@Test
	public void testG() throws Exception {
		DP.parseDate("sat");
		assertEquals("2016-04-16", DP.getDateObject().toString());
		reset();
		
		DP.parseDate("today");
		assertEquals(LocalDate.now(), DP.getDateObject());
		reset();
		
		DP.parseDate("tonight");
        assertEquals(LocalDate.now(), DP.getDateObject());
        reset();
	}
	
	/*NEGATIVE VALUE TEST CASES*/
	/*case 8: test ability to reject non-symbol separated numbers*/
	@Test(expected = Exception.class)
    public void testH() throws Exception {
	    DP.parseDate("1 11 2012");
	}
	
	/*case 9: ability to reject out of bound dates. boundary being 31*/
	@Test(expected = Exception.class)
    public void testI() throws Exception {
	    DP.parseDate("32 feb 2012");
	}
	
	/*case 10: ability to reject non-conforming relative date formats*/
	@Test(expected = Exception.class)
    public void testJ() throws Exception {
	    DP.parseDate("next next monday");
	}
	
	//method resets the list and dates for testing purposes
	private void reset() {
		DP.resetDate();
	}
}
```
###### \src\parsertest\DateTimeProcessorTest.java
``` java
package parsertest;

import static org.junit.Assert.*;

import java.time.LocalDateTime;

import org.junit.Test;

import common.TaskObject;
import parser.Constants;
import parser.DateTimeParser;

public class DateTimeProcessorTest {
	DateTimeParser DTP = new DateTimeParser();
	TaskObject TO = new TaskObject();
	
	/*case 1: reading deadlines*/
	@Test
	public void testA() throws Exception {
		TO = DTP.parse("by 11 june 9am", true);
		assertEquals("2016-06-11T09:00", TO.getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, TO.getEndDateTime());
	}
	
	/*case 2: reading event*/
	@Test
	public void testB() throws Exception {
		TO = DTP.parse("from 11 jan 9am to next fri 10am", true);
		assertEquals("2016-01-11T09:00", TO.getStartDateTime().toString());
		assertEquals("2016-04-22T10:00", TO.getEndDateTime().toString());
	}
	
	/*case 3: reading recurring event with termination date*/
	@Test
	public void testC() throws Exception {
		TO = DTP.parse("every monday at 8am until 9 may", true);
		assertEquals("2016-04-18T08:00", TO.getStartDateTime().toString());
		assertEquals("2016-05-09T23:59:59.999999999", TO.getInterval().getUntil().toString());
		TO.resetAttributes();
	}
	
	/*case 4: reading recurring event with fixed repetition til termination date*/
	//test for multiple day input
	@Test
	public void testD() throws Exception {
		TO = DTP.parse("every friday, sat and sun at 8am for 10 weeks", true);
        assertEquals(10 ,TO.getInterval().getCount());
        assertEquals(0 ,TO.getInterval().getByDayArray()[1]);
        assertEquals(0 ,TO.getInterval().getByDayArray()[2]);
        assertEquals(0 ,TO.getInterval().getByDayArray()[3]);
        assertEquals(0 ,TO.getInterval().getByDayArray()[4]);
        assertEquals(1 ,TO.getInterval().getByDayArray()[5]);
        assertEquals(1 ,TO.getInterval().getByDayArray()[6]);
        assertEquals(1 ,TO.getInterval().getByDayArray()[7]);
        assertEquals("2016-04-15T08:00", TO.getStartDateTime().toString());
        assertEquals(10, TO.getInterval().getCount());
	}
	
	/*case 5: reading "everyday"*/
	@Test
	public void testE() throws Exception {
		TO = DTP.parse("every friday", true);
		assertEquals("2016-04-15T23:59:59.999999999", TO.getStartDateTime().toString());
		TO.resetAttributes();
	}
	
	/*case 6: test for search input, which do not have keywords*/
	@Test
	public void testF() throws Exception {
		TO = DTP.parse("7pm", false);
        assertEquals("+999999999-12-31T19:00", TO.getStartDateTime().toString());
	}

	/*case 7: test for recurring date with start date in next week*/
	@Test
	public void testG() throws Exception {
		TO = DTP.parse("every monday and wed", true);
        assertEquals("2016-04-18T23:59:59.999999999", TO.getStartDateTime().toString());
	}

}
```
###### \src\parsertest\EditProcessorTest.java
``` java
package parsertest;

import static org.junit.Assert.*;

import org.junit.Test;

import common.TaskObject;
import parser.EditParser;

public class EditProcessorTest {

	EditParser EP = new EditParser();
	TaskObject Tempshit = new TaskObject();
	
	//edit specified time
	@Test
	public void editA() throws Exception {
		Tempshit = EP.process("14 9.13pm end");
		assertEquals("",Tempshit.getTitle());
		assertEquals("+999999999-12-31T23:59:59.999999999", Tempshit.getStartDateTime().toString());
		assertEquals("+999999999-12-31T21:13", Tempshit.getEndDateTime().toString());
		reset();
	}
	
	//edit time
	@Test
	public void editB() throws Exception {
		Tempshit = EP.process("4 by 9.13pm");
		assertEquals("+999999999-12-31T21:13", Tempshit.getStartDateTime().toString());
		assertEquals("+999999999-12-31T23:59:59.999999999", Tempshit.getEndDateTime().toString());
		reset();
	}
	
	//edit task 
	@Test
	public void editC() throws Exception {
		Tempshit = EP.process("4 st3131");
		assertEquals("st3131", Tempshit.getTitle());
		reset();
	}
	
	//edit event date
	@Test
	public void editD() throws Exception {
		Tempshit = EP.process("4 from 8june to 7july");
		assertEquals("2016-06-08T23:59:59.999999999", Tempshit.getStartDateTime().toString());
		assertEquals("2016-07-07T23:59:59.999999999", Tempshit.getEndDateTime().toString());
		reset();
	}
	
	//edit event time
	@Test
	public void editE() throws Exception {
		Tempshit = EP.process("4 from 8am to 9am");
		assertEquals("+999999999-12-31T08:00", Tempshit.getStartDateTime().toString());
		assertEquals("+999999999-12-31T09:00", Tempshit.getEndDateTime().toString());
		reset();
	}
	
	//edit event date time
	@Test
	public void editF() throws Exception {
		Tempshit = EP.process("4 from 8june 8.15am to 7/7 7pm");
		assertEquals("2016-06-08T08:15", Tempshit.getStartDateTime().toString());
		assertEquals("2016-07-07T19:00", Tempshit.getEndDateTime().toString());
		reset();
	}
	
	//edit interval
	@Test
	public void editH() throws Exception {
		Tempshit = EP.process("4 every friday");
		assertEquals(1, Tempshit.getInterval().getTimeInterval());
		assertEquals("WEEKLY", Tempshit.getInterval().getFrequency());
		reset();
	}
	
	//edit with no further inputs
	@Test
	public void editI() throws Exception {
		Tempshit = EP.process("14");
		assertEquals("", Tempshit.getTitle());
		reset();
	}
	
	private void reset() {
		Tempshit.resetAttributes();
	}
}
```
###### \src\parsertest\ParserTest.java
``` java
package parsertest;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import common.CommandObject;
import common.TaskObject;

import java.time.LocalDateTime;

import org.junit.Test;

import parser.Parser;


/**
 * This class contains the JUnit test cases for the parser. It tests the input for all cases.
 * 
 * 
 * @author sylvesterchin
 */
public class ParserTest {
	
	Parser tempParser = new Parser();
	TaskObject task = new TaskObject();
	
	/*ADD COMMAND POSITIVE-VALUE PARTITION*/
	
	//--Test adding of floating task AND test time identifier in recognizing invalid time
	@Test
	public void testAdd1() throws Exception {
		Parser tempParser = new Parser("add homework by 14.29pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, cmd.getCommandType());
		assertEquals("homework by 14.29pm", cmd.getTaskObject().getTitle());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("floating", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding deadline
	@Test
	public void testAdd2() throws Exception {
		Parser tempParser = new Parser("add homework IE2100 by 29.2.16 9am", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, cmd.getCommandType());
		assertEquals("homework IE2100", cmd.getTaskObject().getTitle());
		assertEquals("2016-02-29T09:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding deadline with relative date
	@Test
	public void testAdd3() throws Exception {
		Parser tempParser = new Parser("add homework IE2100 by next tues 9am", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		assertEquals("homework IE2100", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-19T09:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding deadline with relative date without time
	@Test
	public void testAdd4() throws Exception {
		Parser tempParser = new Parser("add homework IE2100 by next mon", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		assertEquals("homework IE2100", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-18T23:59:59.999999999",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	
	//--Test adding deadline with date/time in description
	@Test
	public void testAdd5() throws Exception {
		Parser tempParser = new Parser("add prep 5pm lecture by 29feb 9am", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("prep 5pm lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-02-29T09:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding deadline with time only
	@Test
	public void testAdd6() throws Exception {
		Parser tempParser = new Parser("add prep 5pm lecture by next mon 12.10pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("prep 5pm lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-18T12:10",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding relative day-of-week with time
	@Test
	public void testAdd7() throws Exception {
		Parser tempParser = new Parser("add prep lecture on this sunday 4.10am", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("prep lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-17T04:10",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding event
	@Test
	public void testAdd8() throws Exception {
		Parser tempParser = new Parser("add prep 5pm lecture from 29feb 9am to 8pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("prep 5pm lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-02-29T09:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("2016-02-29T20:00",cmd.getTaskObject().getEndDateTime().toString());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("event", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding recurring deadline with relative start date
	@Test
	public void testAdd9() throws Exception {
		Parser tempParser = new Parser("add 5pm lecture every friday at 4pm until 9june", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("5pm lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-15T16:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("WEEKLY",cmd.getTaskObject().getInterval().getFrequency());
		assertEquals(1,cmd.getTaskObject().getInterval().getTimeInterval());
		assertEquals("2016-06-09T23:59:59.999999999",cmd.getTaskObject().getInterval().getUntil().toString());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding recurring event with relative start date
	@Test
	public void testAdd10() throws Exception {
		Parser tempParser = new Parser("add 5pm lecture every wednesday from 8am to 9am until 9june", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("5pm lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-20T08:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("2016-04-20T09:00",cmd.getTaskObject().getEndDateTime().toString());
		assertEquals("WEEKLY",cmd.getTaskObject().getInterval().getFrequency());
		assertEquals(1,cmd.getTaskObject().getInterval().getTimeInterval());
		assertEquals("2016-06-09T23:59:59.999999999",cmd.getTaskObject().getInterval().getUntil().toString());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("event", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding multiple recurring events with count to limit recurrence
	@Test
	public void testAdd11() throws Exception {
		Parser tempParser = new Parser("add go gym every mon, wed and fri from 8am to 9am for 12 weeks", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		assertEquals("go gym", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-15T08:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("2016-04-15T09:00",cmd.getTaskObject().getEndDateTime().toString());
		assertEquals("WEEKLY",cmd.getTaskObject().getInterval().getFrequency());
		assertEquals(1,cmd.getTaskObject().getInterval().getTimeInterval());
		assertEquals(LocalDateTime.MAX,cmd.getTaskObject().getInterval().getUntil());
		assertEquals(12 ,cmd.getTaskObject().getInterval().getCount());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("event", cmd.getTaskObject().getCategory());
		assertEquals(1 ,cmd.getTaskObject().getInterval().getByDayArray()[1]);
        assertEquals(0 ,cmd.getTaskObject().getInterval().getByDayArray()[2]);
        assertEquals(1 ,cmd.getTaskObject().getInterval().getByDayArray()[3]);
        assertEquals(0 ,cmd.getTaskObject().getInterval().getByDayArray()[4]);
        assertEquals(1 ,cmd.getTaskObject().getInterval().getByDayArray()[5]);
        assertEquals(0 ,cmd.getTaskObject().getInterval().getByDayArray()[6]);
        assertEquals(0 ,cmd.getTaskObject().getInterval().getByDayArray()[7]);
		reset();
	}
	
	//--Test adding recurring task without limit
	@Test
	public void testAdd12() throws Exception {
		Parser tempParser = new Parser("add 5pm lecture every friday at 4pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		
		assertEquals("5pm lecture", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-15T16:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("WEEKLY",cmd.getTaskObject().getInterval().getFrequency());
		assertEquals(1,cmd.getTaskObject().getInterval().getTimeInterval());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding recurring task "everyday"
	@Test
	public void testAdd13() throws Exception {
		Parser tempParser = new Parser("add play dota every sunday at 11pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		assertEquals("play dota", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-17T23:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("WEEKLY",cmd.getTaskObject().getInterval().getFrequency());
		assertEquals(1,cmd.getTaskObject().getInterval().getTimeInterval());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test adding of already passed date
	@Test
	public void testAdd14() throws Exception {
		Parser tempParser = new Parser("add play dota by next mon 11pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(1, tempParser.getCommandType());
		assertEquals("play dota", cmd.getTaskObject().getTitle());
		assertEquals("2016-04-18T23:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		assertEquals("deadline", cmd.getTaskObject().getCategory());
		reset();
	}
	
	//--Test searching for task, date and time together
	@Test
	public void testSearch1() throws Exception {
		Parser tempParser = new Parser("search hi 7/9/2016 7pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals("hi", cmd.getTaskObject().getTitle());
		assertEquals("2016-09-07T19:00", cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching for relative date
	@Test
	public void testSearch2() throws Exception {
		Parser tempParser = new Parser("search next sun", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals("", tempParser.getTask());
		assertEquals("2016-04-24T23:59:59.999999999", cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching without keywords
	@Test
	public void testSearch3() throws Exception {
		Parser tempParser = new Parser("aagadfgad", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());		
		assertEquals("aagadfgad", cmd.getTaskObject().getTitle());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching without keywords for time
	@Test
	public void testSearch4() throws Exception {
		Parser tempParser = new Parser("7.13pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());		
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals("+999999999-12-31T19:13", cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching for task details, to pass back an index when only an integer follows the
	//search keyword
	@Test
	public void testSearch5() throws Exception {
		Parser tempParser = new Parser("search 3", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals(2, cmd.getCommandType());
		assertEquals(3, cmd.getIndex());
		reset();
	}
	
	//--Test searching for double digit indexes
	@Test
	public void testSearch6() throws Exception {
		Parser tempParser = new Parser("search 30", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals(30, cmd.getIndex());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching for task without any parameters
	@Test
	public void testSearch7() throws Exception {
		Parser tempParser = new Parser("view", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching for task without any parameters
	@Test
	public void testSearch8() throws Exception {
		Parser tempParser = new Parser("view done", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals("completed", cmd.getTaskObject().getStatus());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test searching relative date without search keyword
	@Test
	public void testSearch9() throws Exception {
		Parser tempParser = new Parser("next fri", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals(2, cmd.getCommandType());
		assertEquals("2016-04-22T23:59:59.999999999", cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test editing title and time simultaneously
	@Test
	public void testEdit1() throws Exception {
		Parser tempParser = new Parser("edit 2 get task 755pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("get task", cmd.getTaskObject().getTitle());
		assertEquals("+999999999-12-31T19:55", cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test editing timing 
	@Test
	public void testEdit2() throws Exception {
		Parser tempParser = new Parser("edit 2 755pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals("+999999999-12-31T19:55", cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test editing start and end DateTime
	@Test
	public void testEdit3() throws Exception {
		Parser tempParser = new Parser("EDIT 2 from 8 june 755pm to 9 june 9pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals("2016-06-08T19:55",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("2016-06-09T21:00",cmd.getTaskObject().getEndDateTime().toString());
		reset();
	}
	
	//--Test editing timing with "end" keyword
	@Test
	public void testEdit4() throws Exception {
		Parser tempParser = new Parser("edit 2 755pm end", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals("+999999999-12-31T19:55", cmd.getTaskObject().getEndDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		reset();
	}
	
	//--Test editing interval
	@Test
	public void testEdit5() throws Exception {
		Parser tempParser = new Parser("edit 12 every friday", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals(12,cmd.getIndex());
		assertEquals("WEEKLY", tempParser.TO.getInterval().getFrequency());
		assertEquals(1, tempParser.TO.getInterval().getTimeInterval());
		assertEquals("2016-04-15T23:59:59.999999999",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test editing interval
	@Test
	public void testEdit6() throws Exception {
		Parser tempParser = new Parser("edit all 12 by 8am", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals(12,cmd.getIndex());
		assertTrue(cmd.getTaskObject().getIsEditAll());
		assertEquals("+999999999-12-31T08:00",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test editing start and end DateTime
	@Test
	public void testEdit7() throws Exception {
		Parser tempParser = new Parser("EDIT all 2 from 755pm to 9pm", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(3, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals("+999999999-12-31T19:55",cmd.getTaskObject().getStartDateTime().toString());
		assertEquals("+999999999-12-31T21:00",cmd.getTaskObject().getEndDateTime().toString());
		reset();
	}
	
	//--Test saving file as another name
	@Test
	public void testSave() throws Exception {
		Parser tempParser = new Parser("save as C://mac/desktop", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(7, cmd.getCommandType());
		assertEquals("as C://mac/desktop", cmd.getTaskObject().getTitle());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	//--Test marking task as done
	@Test
	public void testDone() throws Exception {
		Parser tempParser = new Parser("done", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("completed", cmd.getTaskObject().getStatus());
		reset();
	}
	
	//--Test marking task as not done
	@Test
	public void testNotDone() throws Exception {
		Parser tempParser = new Parser("incomplete", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(2, cmd.getCommandType());
		assertEquals("", cmd.getTaskObject().getTitle());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		assertEquals("incomplete", cmd.getTaskObject().getStatus());
		reset();
	}
	
	//--Test deleting with "all" keyword
	@Test
	public void testDelete() throws Exception {
		Parser tempParser = new Parser("delete 4 all", 1);
		CommandObject cmd = new CommandObject();
		cmd = tempParser.run();
		assertEquals(4, cmd.getCommandType());
		assertEquals("all", cmd.getTaskObject().getTitle());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getStartDateTime());
		assertEquals(LocalDateTime.MAX, cmd.getTaskObject().getEndDateTime());
		reset();
	}
	
	private void reset() {
		tempParser.resetTaskObj();
	}
}
```
###### \src\parsertest\SearchProcessorTest.java
``` java
package parsertest;

import static org.junit.Assert.*;

import org.junit.Test;

import common.TaskObject;
import parser.SearchParser;

public class SearchProcessorTest {
	SearchParser SP = new SearchParser();
	TaskObject TO = new TaskObject();

	/*case 1: searching for completed tasks*/
	@Test
	public void testA() throws Exception {
		TO = SP.process("view done");
		assertEquals("completed", TO.getStatus());
		assertEquals("", TO.getTitle());
	}
	
	/*case 2: searching by categories*/
	@Test
	public void testB() throws Exception {
		TO = SP.process("search deadline");
		assertEquals("deadline", TO.getCategory());
		
		TO = SP.process("search event");
		assertEquals("event", TO.getCategory());
	}
	
	/*case 3: searching for completed tasks*/
	@Test
	public void testC() throws Exception {
		TO = SP.process("search 8");
		assertEquals("", TO.getTitle());
		assertEquals(8, SP.getIndex());
	}
	
	/*case 3: searching for completed tasks*/
	@Test
	public void testD() throws Exception {
		TO = SP.process("next saturday");
		assertEquals("", TO.getTitle());
		assertEquals("2016-04-23T23:59:59.999999999", TO.getStartDateTime().toString());
	}
}
```
###### \src\parsertest\TimeParserTest.java
``` java
package parsertest;

import static org.junit.Assert.*;

import java.time.LocalTime;
import org.junit.Test;
import parser.TimeParser;

public class TimeParserTest {
	
	private TimeParser TP = new TimeParser();
	boolean thrown;
	
	/*POSITIVE PARTITION*/
	/*case 1: test timeparser ability to read in hhmm(am/pm) format*/
	@Test
	public void testA() throws Exception {
		TP.processTime("8.01pm");
		assertEquals("20:01", TP.getTimeObject().toString());
	}
	
	/*case 2: test timeparser ability to read in hhmm(am/pm) format*/
	@Test
	public void testB() throws Exception {
		TP.processTime("12.01am");
		assertEquals("00:01", TP.getTimeObject().toString());
	}
	
	/*case 3: test timeparser ability to read in hhmm(hr) format*/
	@Test
	public void testC() throws Exception {
		TP.processTime("12:34hrs");
		assertEquals("12:34", TP.getTimeObject().toString());
	}
	
	/*NEGATIVE PARTITION (random number without am/pm/hr)*/
	//case 4: test if exception is thrown on invalid time formats
	@Test(expected = Exception.class)
    public void testD() throws Exception {
		TP.processTime("1415");
	}
	
	//NOTE: overly huge timing will not be recognised by the regex for timing
	//but the backup here will catch for any slips
	
	//case 5: test if exception is thrown for overly huge timing
	@Test(expected = Exception.class)
    public void testE() throws Exception {
		TP.processTime("9999hr");
	}
	
	//case 6: test if exception is thrown for overly huge timing
	@Test(expected = Exception.class)
    public void testF() throws Exception {
		TP.processTime("99.99am");
	}
	
	//case 7: test boundary
	@Test(expected = Exception.class)
    public void testG() throws Exception {
		TP.processTime("13.00am");
	}
}
```
