# A0130622X
###### \bin\GUI\HelpPopup.fxml
``` fxml

<?import javafx.scene.paint.*?>
<?import javafx.scene.effect.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<VBox fx:id="helpPane" alignment="TOP_CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" onKeyPressed="#handleArrowPressed" prefHeight="500.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="GUI.HelpPopupController">
   <children>
      <Label fx:id="manualTitle" alignment="CENTER" contentDisplay="CENTER" onKeyPressed="#handleEscPressed" text="Help Manual" textAlignment="CENTER" textFill="#5e412f">
         <padding>
            <Insets left="10.0" top="10.0" />
         </padding>
         <font>
            <Font name="Agency FB Bold" size="30.0" />
         </font>
      </Label>
      <Label fx:id="userGuideText" alignment="CENTER" prefHeight="22.0" prefWidth="644.0" text="&lt;Left&gt;/&lt;Right&gt; arrow key to change topic, &lt;Esc&gt; to close Manual">
         <font>
            <Font name="Agency FB" size="18.0" />
         </font>
      </Label>
      <Label fx:id="topicLabel" focusTraversable="false">
         <font>
            <Font name="Agency FB Bold" size="20.0" />
         </font>
         <VBox.margin>
            <Insets left="10.0" right="5.0" top="5.0" />
         </VBox.margin>
         <padding>
            <Insets left="10.0" right="5.0" top="5.0" />
         </padding>
      </Label>
      <TextArea fx:id="helpText" editable="false" onKeyPressed="#handleArrowPressed" onKeyReleased="#handleEscPressed" prefHeight="407.0" prefWidth="580.0" wrapText="true" VBox.vgrow="ALWAYS">
         <font>
            <Font name="Agency FB" size="16.0" />
         </font>
         <VBox.margin>
            <Insets bottom="10.0" left="10.0" right="10.0" top="5.0" />
         </VBox.margin>
         <padding>
            <Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
         </padding>
      </TextArea>
      <Label fx:id="pageNumber" alignment="CENTER" prefHeight="45.0" prefWidth="646.0" textAlignment="RIGHT">
         <padding>
            <Insets bottom="5.0" right="12.0" />
         </padding>
         <font>
            <Font name="Agency FB" size="18.0" />
         </font>
      </Label>
   </children>
</VBox>
```
###### \bin\GUI\HelpStyle.css
``` css

#manualTitle {
	-fx-font-family: Ubuntu;
	-fx-font-size: 22;
}

#userGuideText {
	-fx-font-family: Abel;
	-fx-font-size: 16
}

#helpPane {
	-fx-background-image: url('background1.jpg');	
	-fx-background-repeat: no-repeat; 
	-fx-background-size: 100% 100%; 
	-fx-border-radius: 20px;
}

#topicLabel {
	-fx-font-family: Ubuntu;
	-fx-font-size: 17
}

#helpText {
	-fx-background-color: #F0A830; 
	-fx-font-family: Abel;
	-fx-font-size: 16;
}

#pageNumber {
	-fx-font-family: Abel;
	-fx-text-fill: white;
}
```
###### \bin\GUI\MainStyle.css
``` css

#programName {
	-fx-font-size: 30;
	-fx-text-fill: #5e412f;
	-fx-font-family: 'Ubuntu' 	
}

#layout {
	-fx-background-image: url('background4.jpg');	
	-fx-background-repeat: no-repeat; 
	-fx-background-size: 100% 100%; 
	-fx-border-radius: 20px;
}

#taskTable {
	-fx-border-color: #78C0A8; 
	-fx-border-width: 3px; 
	-fx-background-radius: 1.2em; 
	-fx-border-radius: 1.2em;
}

#taskTable .column-header .label {
	-fx-font-weight: bold;
	-fx-font-family: 'Ubuntu Light';
	-fx-text-fill: white;
}

.table-row-cell:selected { 
   -fx-border-color: red;
	-fx-border-width: 1;
}
.table-row-cell:selected .text {
	-fx-fill: black;
}
	
#taskTable .column-header {
	-fx-background-color: #3B8686;
	-fx-border-width: 0.1;
	-fx-border-color: white;
    -fx-effect: innershadow( gaussian, #3B8686, 5, 0, 5, 5 );
}


#indexColumn {
	-fx-alignment: CENTER; 
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
}

#statusColumn {
	-fx-alignment: CENTER; 
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
}
		
#taskColumn {
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
	-fx-alignment: CENTER-LEFT
}

#timeColumn {
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
}

#feedbackBox {
	-fx-background-color: white; 
	-fx-background-radius: 8 8 0 0;
}

#feedbackMessage {
	-fx-font-family: 'Ubuntu';
	-fx-font-size: 15;
	-fx-text-fill: #5e412f;
}

#userInput {
	-fx-background-radius: 0.5em;
	-fx-font-family: 'Abel';
	-fx-font-size: 16;
}

#taskDateList {
	-fx-font-family: 'Abel';
	-fx-font-size: 17; 
	
}

#sidePanel {
	-fx-background-color: white; 
	-fx-background-radius: 10px; 
	-fx-border-color: #78C0A8; 
	-fx-border-radius: 10px;
	-fx-border-width: 3px; 
}

#sidePanel .scroll-bar:vertical .increment-arrow,
#sidePanel .scroll-bar:vertical .decrement-arrow,
#sidePanel .scroll-bar:vertical .increment-button,
#sidePanel .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
}

#recurTitle {
	-fx-alignment: CENTER; 
	-fx-font-size: 17; 
	-fx-font-family: 'Ubuntu';	
	-fx-text-fill: #5e412f;
}

.doneTasks {
	-fx-background-color: lightgray;
}

.undoneTasks {
	-fx-background-color: lightyellow;
}

.overdueTasks {
	-fx-background-color: lightpink;
}

@font-face {
	font-family: Abel;
	src: url(Abel-Regular.ttf);
}

@font-face {
	font-family: 'Ubuntu';
	src: url(Ubuntu-Regular.ttf);
}

@font-face {
	font-family: 'Ubuntu Light';
	src: url(Ubuntu-Light.ttf);
}
```
###### \bin\GUI\TaskWindow.fxml
``` fxml

<?import javafx.scene.effect.*?>
<?import javafx.scene.paint.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.text.*?>
<?import javafx.scene.control.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<StackPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="500.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="GUI.MainController">
   <children>
      <BorderPane fx:id="layout" prefHeight="600" prefWidth="370.0">
         <center>
            <TableView fx:id="taskTable" onKeyPressed="#handleKeyPressed" prefHeight="200.0" prefWidth="200.0" BorderPane.alignment="CENTER">
               <columns>
                  <TableColumn fx:id="indexColumn" editable="false" maxWidth="80.0" minWidth="80.0" prefWidth="-1.0" sortable="false" text="No." />
                  <TableColumn fx:id="taskColumn" editable="false" prefWidth="280.0" sortable="false" text="Task Name" />
                  <TableColumn fx:id="statusColumn" editable="false" maxWidth="100.0" minWidth="100.0" prefWidth="90.0" sortable="false" text="Status" />
                  <TableColumn fx:id="timeColumn" editable="false" prefWidth="180.0" sortable="false" text="Time" />
               </columns>
               <padding>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="8.0" />
               </padding>
               <BorderPane.margin>
                  <Insets />
               </BorderPane.margin>
               <columnResizePolicy>
                  <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
               </columnResizePolicy>
            </TableView>
         </center>
         <bottom>
            <VBox prefHeight="100.0" prefWidth="100.0" BorderPane.alignment="CENTER">
               <children>
                  <TextFlow fx:id="feedbackBox" opacity="0.7" prefHeight="40.0" prefWidth="200.0">
                     <children>
                        <Text fx:id="feedbackMessage" strokeType="OUTSIDE" strokeWidth="0.0">
                        </Text>
                     </children>
                     <padding>
                        <Insets left="5.0" top="10.0" />
                     </padding>
                     <VBox.margin>
                        <Insets left="1.0" right="1.0" top="5.0" />
                     </VBox.margin>
                  </TextFlow>
                  <TextField fx:id="userInput" onKeyPressed="#handleKeyPressed" onKeyReleased="#handleEnterPressed" prefHeight="40.0" prefWidth="180.0" promptText="Press &lt;Tab&gt; to enter command, &lt;F1&gt; for help" />
               </children>
            </VBox>
         </bottom>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
         <top>
            <Label fx:id="programName" alignment="CENTER" text="AdultTaskFinder" BorderPane.alignment="BOTTOM_CENTER">
               
               <BorderPane.margin>
                  <Insets top="10.0" />
               </BorderPane.margin>
            </Label>
         </top>
         <right>
            <VBox fx:id="sidePanel" prefHeight="200.0" prefWidth="200.0" translateX="100.0" visible="false" BorderPane.alignment="CENTER">
               <children>
                  <Label fx:id="recurTitle" wrapText="true">
                     <VBox.margin>
                        <Insets bottom="5.0" />
                     </VBox.margin></Label>
                  <ListView fx:id="taskDateList" onKeyPressed="#handleKeyPressed" prefHeight="200.0" prefWidth="200.0" VBox.vgrow="ALWAYS" />
               </children>
               <BorderPane.margin>
                  <Insets left="10.0" />
               </BorderPane.margin>
               <padding>
                  <Insets bottom="10.0" left="8.0" right="8.0" top="10.0" />
               </padding>
            </VBox>
         </right>
      </BorderPane>
   </children>
</StackPane>
```
###### \src\GUI\HelpPopup.fxml
``` fxml

<?import javafx.scene.paint.*?>
<?import javafx.scene.effect.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<VBox fx:id="helpPane" alignment="TOP_CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" onKeyPressed="#handleArrowPressed" prefHeight="500.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="GUI.HelpPopupController">
   <children>
      <Label fx:id="manualTitle" alignment="CENTER" contentDisplay="CENTER" onKeyPressed="#handleEscPressed" text="Help Manual" textAlignment="CENTER" textFill="#5e412f">
         <padding>
            <Insets left="10.0" top="10.0" />
         </padding>
         <font>
            <Font name="Agency FB Bold" size="30.0" />
         </font>
      </Label>
      <Label fx:id="userGuideText" alignment="CENTER" prefHeight="22.0" prefWidth="644.0" text="&lt;Left&gt;/&lt;Right&gt; arrow key to change topic, &lt;Esc&gt; to close Manual">
         <font>
            <Font name="Agency FB" size="18.0" />
         </font>
      </Label>
      <Label fx:id="topicLabel" focusTraversable="false">
         <font>
            <Font name="Agency FB Bold" size="20.0" />
         </font>
         <VBox.margin>
            <Insets left="10.0" right="5.0" top="5.0" />
         </VBox.margin>
         <padding>
            <Insets left="10.0" right="5.0" top="5.0" />
         </padding>
      </Label>
      <TextArea fx:id="helpText" editable="false" onKeyPressed="#handleArrowPressed" onKeyReleased="#handleEscPressed" prefHeight="407.0" prefWidth="580.0" wrapText="true" VBox.vgrow="ALWAYS">
         <font>
            <Font name="Agency FB" size="16.0" />
         </font>
         <VBox.margin>
            <Insets bottom="10.0" left="10.0" right="10.0" top="5.0" />
         </VBox.margin>
         <padding>
            <Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
         </padding>
      </TextArea>
      <Label fx:id="pageNumber" alignment="CENTER" prefHeight="45.0" prefWidth="646.0" textAlignment="RIGHT">
         <padding>
            <Insets bottom="5.0" right="12.0" />
         </padding>
         <font>
            <Font name="Agency FB" size="18.0" />
         </font>
      </Label>
   </children>
</VBox>
```
###### \src\GUI\HelpPopupController.java
``` java

package GUI;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.ResourceBundle;
import java.util.logging.Logger;

import common.AtfLogger;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

/**
 * Controls the HelpPopup to allow access to help manual Help topic displayed
 * sorted by command type: Add, Search, Edit, Delete, Undo, Save, Exit. Display
 * topic changes with left/right arrowkeys pressed. Popup closes with Esc
 * pressed
 * 
 * @author Seow Hwee
 *
 */

public class HelpPopupController implements Initializable {

	private static final String MESSAGE_INVALID_STYLESHEET = "Error: HelpStyle.css stylesheet not found.";
	private static final String MESSAGE_NODE_NOT_INJECTED = 
			"fx:id=\"%1$s\" was not injected: check your FXML file 'HelpPopup.fxml'.";

	private static final int MAX_PAGE = 28;
	private static final int MIN_PAGE = 1;
	
	private static Stage helpStage = new Stage();
	private static ArrayList<String> displayList = MainController.getHelpList(1);
	private static int page = 1;

	private static Logger logger = AtfLogger.getLogger();
	
	@FXML
	private VBox helpPane;
	@FXML
	private TextArea helpText;
	@FXML
	private Label topicLabel;
	@FXML
	private Label pageNumber;
	@FXML
	private Label userGuideText;
	@FXML
	private Label manualTitle;

	
	// ----------------------------- START HELP WINDOW ----------------------------
	/**
	 * Called by MainController to activate help pop-up. Function starts and
	 * shows the help pop-up window.
	 * 
	 * @throws IOException
	 *             unable to load fxml file
	 */
	public void startHelp() {
		Parent help;
		try {
			help = FXMLLoader.load(getClass().getResource("HelpPopup.fxml"));
			Scene helpScene = new Scene(help,650,500);
			helpStage.setScene(helpScene);
			setStyle(helpScene);
			helpStage.show();
		} catch (IOException e) {
			logger.warning("unable to load HelpPopup.fxml file");
			e.printStackTrace();
		}
	}

	private void setStyle(Scene scene) {
		URL url = this.getClass().getResource("HelpStyle.css");
		if (url == null) {
			System.out.println(MESSAGE_INVALID_STYLESHEET);
		}
		String css = url.toExternalForm();
		scene.getStylesheets().add(css);
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {

		assert helpText != null : String.format(MESSAGE_NODE_NOT_INJECTED, "helpText");
		assert helpPane != null : String.format(MESSAGE_NODE_NOT_INJECTED, "helpPane");
		assert pageNumber != null : String.format(MESSAGE_NODE_NOT_INJECTED, "pageNumber");
		assert topicLabel != null : String.format(MESSAGE_NODE_NOT_INJECTED, "topicLabel");
		assert userGuideText != null : String.format(MESSAGE_NODE_NOT_INJECTED, "userGuideText");
		assert manualTitle != null : String.format(MESSAGE_NODE_NOT_INJECTED, "manualTitle");

		setDisplay();
	}

	// -------------------------- SET HELP CONTENT METHODS ----------------------------

	private void setDisplay() {
		setHelpContent();
		setPageNumber();
	}

	private void setHelpContent() {
		setTopicName();
		clearPrevText();
		setCurrText();
		setHelpScrollTop();
	}

	private void setPageNumber() {
		pageNumber.setText(page + "/" + MAX_PAGE);
	}

	private void setTopicName() {
		topicLabel.setText(displayList.get(0));
	}

	private void clearPrevText() {
		helpText.clear();
	}

	private void setCurrText() {
		for (int i = 1; i < displayList.size(); i++) {
			helpText.appendText(displayList.get(i) + "\n");
		}
	}

	private void setHelpScrollTop() {
		Platform.runLater(() -> helpText.setScrollTop(Double.MIN_VALUE));
	}

	// ------------------------------ HANDLE KEYS PRESSED METHODS
	// ----------------------------

	/**
	 * Closes the help pop-up window
	 * 
	 * @param event
	 *            - Enter key pressed
	 */
	@FXML
	public void handleEscPressed(KeyEvent event) {
		if (event.getCode() == KeyCode.ESCAPE) {
			helpStage.close();
		}
	}

	/**
	 * Allows Help Pop-up Content to change with press of left/right arrow key.
	 * Help displayed switches between topics with each press.
	 * 
	 * @param event
	 *            - left or right arrow key pressed
	 */
	@FXML
	public void handleArrowPressed(KeyEvent event) {
		if (event.getCode() == KeyCode.RIGHT && page < MAX_PAGE) {
			page++;
		}
		if (event.getCode() == KeyCode.LEFT && page > MIN_PAGE) {
			page--;
		}
		displayList = MainController.getHelpList(page);
		setDisplay();
	}

}
```
###### \src\GUI\HelpStyle.css
``` css

#manualTitle {
	-fx-font-family: Ubuntu;
	-fx-font-size: 22;
}

#userGuideText {
	-fx-font-family: Abel;
	-fx-font-size: 16
}

#helpPane {
	-fx-background-image: url('background1.jpg');	
	-fx-background-repeat: no-repeat; 
	-fx-background-size: 100% 100%; 
	-fx-border-radius: 20px;
}

#topicLabel {
	-fx-font-family: Ubuntu;
	-fx-font-size: 17
}

#helpText {
	-fx-background-color: #F0A830; 
	-fx-font-family: Abel;
	-fx-font-size: 16;
}

#pageNumber {
	-fx-font-family: Abel;
	-fx-text-fill: white;
}
```
###### \src\GUI\MainController.java
``` java

package GUI;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.ResourceBundle;

import common.TaskObject;
import javafx.animation.TranslateTransition;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.TextField;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.util.Callback;
import javafx.util.Duration;

/**
 * Controls the TaskWindow to allow interaction with the program Inputs keyed in
 * textfield read with enter key pressed Tasks displayed in tableview updates
 * after every command Feedback message displayed above the textfield HelpPopup
 * initiated with with F1 hotkey pressed Program closes with Esc pressed
 * 
 * @author Seow Hwee
 *
 */
public class MainController implements Initializable {

	private static final String MESSAGE_NODE_NOT_INJECTED = 
			"fx:id=\"%1$s\" was not injected: check your FXML file 'TaskWindow.fxml'.";
	
	private static String _input;
	private static UIMain _UI = new UIMain();

	@FXML
	private static BorderPane layout;
	@FXML
	private VBox sidePanel;
	@FXML
	private ListView<String> taskDateList;
	@FXML
	private TableView<TaskObject> taskTable;
	@FXML
	private TableColumn<TaskObject, String> indexColumn;
	@FXML
	private TableColumn<TaskObject, String> taskColumn;
	@FXML
	private TableColumn<TaskObject, String> statusColumn;
	@FXML
	private TableColumn<TaskObject, String> timeColumn;
	@FXML
	private TextFlow feedbackBox;
	@FXML
	private Text feedbackMessage;
	@FXML
	private TextField userInput;
	@FXML
	private Label recurTitle;
	@FXML
	private Label programName;

	@Override
	public void initialize(URL location, ResourceBundle resources) {

		assert layout != null : String.format(MESSAGE_NODE_NOT_INJECTED, "layout");
		assert programName != null : String.format(MESSAGE_NODE_NOT_INJECTED, "programName");
		
		assert sidePanel != null : String.format(MESSAGE_NODE_NOT_INJECTED, "sidePanel");
		assert taskDateList != null : String.format(MESSAGE_NODE_NOT_INJECTED, "taskDateList");
		assert recurTitle != null : String.format(MESSAGE_NODE_NOT_INJECTED, "recurTitle");

		assert taskTable != null : String.format(MESSAGE_NODE_NOT_INJECTED, "taskTable");
		assert indexColumn != null : String.format(MESSAGE_NODE_NOT_INJECTED, "indexColumn");
		assert taskColumn != null : String.format(MESSAGE_NODE_NOT_INJECTED, "taskColumn");
		assert statusColumn != null : String.format(MESSAGE_NODE_NOT_INJECTED, "statusColumn");
		assert timeColumn != null : String.format(MESSAGE_NODE_NOT_INJECTED, "timeColumn");

		assert feedbackBox != null : String.format(MESSAGE_NODE_NOT_INJECTED, "feedbackBox");
		assert feedbackMessage != null : String.format(MESSAGE_NODE_NOT_INJECTED, "feedbackMessage");
		assert userInput != null : String.format(MESSAGE_NODE_NOT_INJECTED, "userInput");

		manageSidePanel();
		sidebarWrapText(); // for sideBarList
		displayMessage();
		display(); // start program with all tasks in table

	}
	
	//--------------------------- HANDLE KEYS PRESSED METHODS -----------------------------
	/**
	 * Handles enter pressed by reading input in textfield and process input.
	 * 
	 * @param event
	 *            - Enter pressed
	 * @throws IOException
	 */
	@FXML
	// reads input on enter
	public void handleEnterPressed(KeyEvent event) throws IOException {
		if (event.getCode() == KeyCode.ENTER) {
			readInput();
			passInput();
			clearTextField();
			hideSidePanel();
			feedbackUser();
		}
	}

	/**
	 * Handles when F1 pressed by activating help. Handles when Esc pressed by
	 * closing program.
	 * 
	 * @param event
	 *            - F1 or Esc Pressed
	 * @throws IOException
	 */
	@FXML
	public void handleKeyPressed(KeyEvent event) throws IOException {
		if (event.getCode() == KeyCode.F1) {
			HelpPopupController popupController = new HelpPopupController();
			popupController.startHelp();
		}

		if (event.getCode() == KeyCode.ESCAPE) {
			System.exit(0);
		}
	}

	// ---------------------- SIDE PANEL METHODS ------------------------------

	private void manageSidePanel() {
		sidePanel.managedProperty().bind(sidePanel.visibleProperty());
	}

	private void sidebarWrapText() {
		taskDateList.setCellFactory(new Callback<ListView<String>, ListCell<String>>() {
			@Override
			public ListCell<String> call(final ListView<String> list) {
				return new ListCell<String>() {
					{
						Text text = new Text();
						text.wrappingWidthProperty().bind(taskDateList.widthProperty());
						text.textProperty().bind(itemProperty());

						setPrefWidth(0);
						setGraphic(text);
					}
				};
			}
		});
	}

	private void hideSidePanel() {
		if ((!_input.startsWith("edit")) && !_input.startsWith("delete")) {
			sidePanel.setVisible(false);
		} else {
			fillSidebar();
		}
	}
	
	private void sidePanelAnimation() {
		TranslateTransition openNav = new TranslateTransition(new Duration(300), sidePanel);
		openNav.setToX(0);

		if (sidePanel.getTranslateX() != 0) {
			openNav.play();
		}
	}
	
	private void fillSidebar() {
		taskDateList.getItems().clear();
		try {
			ArrayList<String> recurringTimes = _UI.getTaskDateOutput();
			
			recurTitle.setText(recurringTimes.get(0));
			recurringTimes.remove(0);
			ObservableList<String> items = FXCollections.observableArrayList(recurringTimes);
			
			taskDateList.getItems().clear();
			taskDateList.setItems(items);
		} catch (NullPointerException e) {
			
		}		
	}

	//----------------------- USER INPUT AND FEEDBACK METHODS ---------------------------------
	private void readInput() {
		_input = userInput.getText();
	}

	private void passInput() throws IOException {
		if (_input.startsWith("help")) {
			HelpPopupController popupController = new HelpPopupController();
			popupController.startHelp();
		} else {
			_UI.passInput(_input);
		}
	}
	
	// clears textfield after each input
	private void clearTextField() {
		userInput.clear(); 
	}

	private void feedbackUser() {
		
		if (isRecurringDateRequest()) {
			sidePanel.setVisible(true);
			fillSidebar();
			sidePanelAnimation();
		}
		displayMessage(); 
		display();
		setSelectionFocus();
	}

	private boolean isRecurringDateRequest() {
		if (_UI.getOutput().size() > 0) {
			if (_UI.getOutput().get(0).startsWith("Displaying recurrence")) {
				return true;
			}
		}
		return false;
	}
	
	//shows feedback message in feedback box
	private void displayMessage() {
		feedbackMessage.setText(_UI.getMessage());
		feedbackBox.getChildren().clear();
		feedbackBox.getChildren().add(feedbackMessage);
	}

	//----------------------------- TASK TABLEVIEW METHODS -------------------------------
	
	//fills taskTable with outputTaskList
	private void display() {
		ObservableList<TaskObject> taskData = FXCollections.observableArrayList(getOutputTaskList());
		fillTable(taskData);
	}

	private void fillTable(ObservableList<TaskObject> taskData) {
		populateIndex();
		populateColumns();
		setCellProperty();
		taskTable.setItems(taskData);
	}

	//fill index column
	private void populateIndex() {
		indexColumn.setCellFactory(col -> new TableCell<TaskObject, String>() {
			@Override
			public void updateIndex(int index) {
				super.updateIndex(index);
				if (isEmpty() || index < 0) {
					setText(null);
				} else {
					setText(Integer.toString(index + 1));
				}
			}
		});
	}

	//fill all table columns except index Column
	private void populateColumns() {
		taskColumn.setCellValueFactory(new PropertyValueFactory<TaskObject, String>("Title"));
		statusColumn.setCellValueFactory(new PropertyValueFactory<TaskObject, String>("status"));
		timeColumn.setCellValueFactory(new PropertyValueFactory<TaskObject, String>("timeOutputString"));
	}

	private void setCellProperty() {
		tableWrapText();
		colourCode();
	}

	//highlight rows of tasks according to their status
	private void colourCode() {
		statusColumn.setCellFactory(new Callback<TableColumn<TaskObject, String>, TableCell<TaskObject, String>>() {
			@Override
			public TableCell<TaskObject, String> call(TableColumn<TaskObject, String> param) {
				final TableCell<TaskObject, String> cell = new TableCell<TaskObject, String>() {
					private Text text;

					@Override
					public void updateItem(String item, boolean empty) {
						super.updateItem(item, empty);
						if (!isEmpty()) {
							text = new Text(item.toString());
							if (item.startsWith("incomplete")) {
								this.getTableRow().getStyleClass().add("undoneTasks");
							} else if (item.startsWith("complete")) {
								this.getTableRow().getStyleClass().add("doneTasks");
							} else {
								this.getTableRow().getStyleClass().add("overdueTasks");
							}
							setGraphic(text);
						}
					}
				};
				return cell;
			}
		});

	}

	private void tableWrapText() {
		taskNameWrapText();
		timeWrapText();
	}

	private void taskNameWrapText() {
		taskColumn.setCellFactory(new Callback<TableColumn<TaskObject, String>, TableCell<TaskObject, String>>() {
			@Override
			public TableCell<TaskObject, String> call(TableColumn<TaskObject, String> param) {
				final TableCell<TaskObject, String> cell = new TableCell<TaskObject, String>() {
					private Text text;

					@Override
					public void updateItem(String item, boolean empty) {
						super.updateItem(item, empty);
						if (!isEmpty()) {
							text = new Text(item.toString());
							text.wrappingWidthProperty().bind(taskColumn.widthProperty());
							setGraphic(text);
						}
					}
				};
				return cell;
			}
		});
	}

	private void timeWrapText() {
		timeColumn.setCellFactory(new Callback<TableColumn<TaskObject, String>, TableCell<TaskObject, String>>() {
			@Override
			public TableCell<TaskObject, String> call(TableColumn<TaskObject, String> param) {
				final TableCell<TaskObject, String> cell = new TableCell<TaskObject, String>() {
					private Text text;

					@Override
					public void updateItem(String item, boolean empty) {
						super.updateItem(item, empty);
						if (!isEmpty()) {
							text = new Text(item.toString());
							text.wrappingWidthProperty().bind(timeColumn.widthProperty());
							setGraphic(text);
						}
					}
				};
				return cell;
			}
		});
	}

	private void setSelectionFocus() {
		if (_input.startsWith("add")) {
			
			focusToAddedTask();
			
		} else if ((_input.startsWith("edit") || _input.startsWith("view") || _input.startsWith("find")
				|| !_input.startsWith("filter") || !_input.startsWith("display") 
				|| _input.startsWith("search") || !_input.startsWith("list")) 
				&& sidePanel.isVisible() == false) {
			
			focusToEditedOrViewedTask();
			
		} else if (sidePanel.isVisible() == false) {
			
			clearFocus();
			
		}
	}

	private void focusToAddedTask() {
		int sortIndex = _UI.getSortedIndex();
		taskTable.scrollTo(sortIndex - 1);
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				taskTable.getSelectionModel().select(sortIndex - 1);
			}
		});
	}

	private void focusToEditedOrViewedTask() {
		String[] input = _input.split(" ");
		if (input.length > 1) {
			try {
				int index = _UI.getSortedIndex();
				taskTable.scrollTo(index - 1);
				taskTable.getSelectionModel().select(index - 1);
			} catch (NumberFormatException e) {

			}
		}
	}

	private void clearFocus() {
		taskTable.getSelectionModel().clearSelection();
	}

	//-------------------------- GETTERS -----------------------------
	/**
	 * Called by HelpPopupController to retrieve content in help manual for
	 * display.
	 * 
	 * @param i
	 *            - index to indicate which section of help manual to retrieve
	 * @return _UI.getOutput: returns ArrayList<String> from different sections
	 *         of help manual
	 */
	public static ArrayList<String> getHelpList(int i) {
		switch (i) {
		case 1:
			_UI.passInput("help Add a floating task");
			break;
		case 2:
			_UI.passInput("help Add a deadline task");
			break;
		case 3:
			_UI.passInput("help Add an event task");
			break;
		case 4:
			_UI.passInput("help Add a recurring task");
			break;
		case 5:
			_UI.passInput("help Search by title");
			break;
		case 6:
			_UI.passInput("help Search by date");
			break;
		case 7:
			_UI.passInput("help Search by date and time");
			break;
		case 8:
			_UI.passInput("help Search by category");
			break;
		case 9:
			_UI.passInput("help Search by status");
			break;
		case 10:
			_UI.passInput("help Search by index");
			break;
		case 11:
			_UI.passInput("help Edit title");
			break;
		case 12:
			_UI.passInput("help Edit date");
			break;
		case 13:
			_UI.passInput("help Edit time");
			break;
		case 14:
			_UI.passInput("help Edit interval");
			break;
		case 15:
			_UI.passInput("help Edit all occurrences of a recurring task");
			break;
		case 16:
			_UI.passInput("help Delete a task");
			break;
		case 17:
			_UI.passInput("help Delete all occurrences of a recurring task");
			break;
		case 18:
			_UI.passInput("help Delete all tasks");
			break;
		case 19:
			_UI.passInput("help Mark a task as completed");
			break;
		case 20:
			_UI.passInput("help Mark a task as incomplete");
			break;
		case 21:
			_UI.passInput("help Undo an action");
			break;
		case 22:
			_UI.passInput("help Redo an action");
			break;
		case 23:
			_UI.passInput("help Change a new default save location");
			break;
		case 24:
			_UI.passInput("help Create a backup copy of the saved events/task");
			break;
		case 25:
			_UI.passInput("help Load from a backup file");
			break;
		case 26:
			_UI.passInput("help Load from a specific file");
			break;
		case 27:
			_UI.passInput("help Access the user manual");
			break;
		case 28:
			_UI.passInput("help Exiting the programme");
			break;
		}
		return _UI.getOutput();
	}
	
	//gets tasklist to be displayed in table
	private ArrayList<TaskObject> getOutputTaskList() {
		return _UI.getLastOutputTaskList();
	}

}
```
###### \src\GUI\MainStyle.css
``` css

#programName {
	-fx-font-size: 30;
	-fx-text-fill: #5e412f;
	-fx-font-family: 'Ubuntu' 	
}

#layout {
	-fx-background-image: url('background4.jpg');	
	-fx-background-repeat: no-repeat; 
	-fx-background-size: 100% 100%; 
	-fx-border-radius: 20px;
}

#taskTable {
	-fx-border-color: #78C0A8; 
	-fx-border-width: 3px; 
	-fx-background-radius: 1.2em; 
	-fx-border-radius: 1.2em;
}

#taskTable .column-header .label {
	-fx-font-weight: bold;
	-fx-font-family: 'Ubuntu Light';
	-fx-text-fill: white;
}

.table-row-cell:selected { 
   -fx-border-color: red;
	-fx-border-width: 1;
}
.table-row-cell:selected .text {
	-fx-fill: black;
}
	
#taskTable .column-header {
	-fx-background-color: #3B8686;
	-fx-border-width: 0.1;
	-fx-border-color: white;
    -fx-effect: innershadow( gaussian, #3B8686, 5, 0, 5, 5 );
}


#indexColumn {
	-fx-alignment: CENTER; 
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
}

#statusColumn {
	-fx-alignment: CENTER; 
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
}
		
#taskColumn {
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
	-fx-alignment: CENTER-LEFT
}

#timeColumn {
	-fx-font-size: 17; 
	-fx-font-family: 'Abel', FallBack, sans-serif;	
}

#feedbackBox {
	-fx-background-color: white; 
	-fx-background-radius: 8 8 0 0;
}

#feedbackMessage {
	-fx-font-family: 'Ubuntu';
	-fx-font-size: 15;
	-fx-text-fill: #5e412f;
}

#userInput {
	-fx-background-radius: 0.5em;
	-fx-font-family: 'Abel';
	-fx-font-size: 16;
}

#taskDateList {
	-fx-font-family: 'Abel';
	-fx-font-size: 17; 
	
}

#sidePanel {
	-fx-background-color: white; 
	-fx-background-radius: 10px; 
	-fx-border-color: #78C0A8; 
	-fx-border-radius: 10px;
	-fx-border-width: 3px; 
}

#sidePanel .scroll-bar:vertical .increment-arrow,
#sidePanel .scroll-bar:vertical .decrement-arrow,
#sidePanel .scroll-bar:vertical .increment-button,
#sidePanel .scroll-bar:vertical .decrement-button {
    -fx-padding:0;
}

#recurTitle {
	-fx-alignment: CENTER; 
	-fx-font-size: 17; 
	-fx-font-family: 'Ubuntu';	
	-fx-text-fill: #5e412f;
}

.doneTasks {
	-fx-background-color: lightgray;
}

.undoneTasks {
	-fx-background-color: lightyellow;
}

.overdueTasks {
	-fx-background-color: lightpink;
}

@font-face {
	font-family: Abel;
	src: url(Abel-Regular.ttf);
}

@font-face {
	font-family: 'Ubuntu';
	src: url(Ubuntu-Regular.ttf);
}

@font-face {
	font-family: 'Ubuntu Light';
	src: url(Ubuntu-Light.ttf);
}
```
###### \src\GUI\TaskWindow.fxml
``` fxml

<?import javafx.scene.effect.*?>
<?import javafx.scene.paint.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.text.*?>
<?import javafx.scene.control.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<StackPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="500.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="GUI.MainController">
   <children>
      <BorderPane fx:id="layout" prefHeight="600" prefWidth="370.0">
         <center>
            <TableView fx:id="taskTable" onKeyPressed="#handleKeyPressed" prefHeight="200.0" prefWidth="200.0" BorderPane.alignment="CENTER">
               <columns>
                  <TableColumn fx:id="indexColumn" editable="false" maxWidth="80.0" minWidth="80.0" prefWidth="-1.0" sortable="false" text="No." />
                  <TableColumn fx:id="taskColumn" editable="false" prefWidth="280.0" sortable="false" text="Task Name" />
                  <TableColumn fx:id="statusColumn" editable="false" maxWidth="100.0" minWidth="100.0" prefWidth="90.0" sortable="false" text="Status" />
                  <TableColumn fx:id="timeColumn" editable="false" prefWidth="180.0" sortable="false" text="Time" />
               </columns>
               <padding>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="8.0" />
               </padding>
               <BorderPane.margin>
                  <Insets />
               </BorderPane.margin>
               <columnResizePolicy>
                  <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
               </columnResizePolicy>
            </TableView>
         </center>
         <bottom>
            <VBox prefHeight="100.0" prefWidth="100.0" BorderPane.alignment="CENTER">
               <children>
                  <TextFlow fx:id="feedbackBox" opacity="0.7" prefHeight="40.0" prefWidth="200.0">
                     <children>
                        <Text fx:id="feedbackMessage" strokeType="OUTSIDE" strokeWidth="0.0">
                        </Text>
                     </children>
                     <padding>
                        <Insets left="5.0" top="10.0" />
                     </padding>
                     <VBox.margin>
                        <Insets left="1.0" right="1.0" top="5.0" />
                     </VBox.margin>
                  </TextFlow>
                  <TextField fx:id="userInput" onKeyPressed="#handleKeyPressed" onKeyReleased="#handleEnterPressed" prefHeight="40.0" prefWidth="180.0" promptText="Press &lt;Tab&gt; to enter command, &lt;F1&gt; for help" />
               </children>
            </VBox>
         </bottom>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
         <top>
            <Label fx:id="programName" alignment="CENTER" text="AdultTaskFinder" BorderPane.alignment="BOTTOM_CENTER">
               
               <BorderPane.margin>
                  <Insets top="10.0" />
               </BorderPane.margin>
            </Label>
         </top>
         <right>
            <VBox fx:id="sidePanel" prefHeight="200.0" prefWidth="200.0" translateX="100.0" visible="false" BorderPane.alignment="CENTER">
               <children>
                  <Label fx:id="recurTitle" wrapText="true">
                     <VBox.margin>
                        <Insets bottom="5.0" />
                     </VBox.margin></Label>
                  <ListView fx:id="taskDateList" onKeyPressed="#handleKeyPressed" prefHeight="200.0" prefWidth="200.0" VBox.vgrow="ALWAYS" />
               </children>
               <BorderPane.margin>
                  <Insets left="10.0" />
               </BorderPane.margin>
               <padding>
                  <Insets bottom="10.0" left="8.0" right="8.0" top="10.0" />
               </padding>
            </VBox>
         </right>
      </BorderPane>
   </children>
</StackPane>
```
###### \src\GUI\UIMain.java
``` java

package GUI;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.logging.Logger;

import common.AtfLogger;
import common.TaskObject;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.stage.Stage;
import logic.Logic;
import javafx.scene.Parent;
import javafx.scene.Scene;

/**
 * Launches the program, initiating the TaskWindow users interact with Creates
 * Logic object within class to interact with backend component Passes input
 * from user to logic Gets output from logic after input command run in logic
 * 
 * @author Seow Hwee
 *
 */

public class UIMain extends Application {

	public static final String MESSAGE_INVALID_STYLESHEET = "Error: MainStyle.css stylesheet not found.";

	private static Logic logic = new Logic();
	private static Stage window;
	private static ArrayList<TaskObject> taskList;
	
	private static Logger logger = AtfLogger.getLogger();
	
	/**
	 * Starts and loads the program, shows the window. 
	 * Main window title set as AdultTaskFinder.
	 * 
	 */
	
	@Override
	public void start(Stage primaryStage) {
		window = primaryStage;
		Parent root;
		
		try {
			root = FXMLLoader.load(getClass().getResource("TaskWindow.fxml"));
			Scene scene = new Scene(root, 720, 500);
			setStyle(scene);
			window.setTitle("AdultTaskFinder");
			window.setScene(scene);
			window.show();
		} catch (IOException e) {
			logger.warning("unable to load TaskWindow.fxml file");
			e.printStackTrace();
		}
	}
	
	//load style from stylesheet
	private void setStyle(Scene scene) {
		URL url = this.getClass().getResource("MainStyle.css");
		if (url == null) {
			System.out.println(MESSAGE_INVALID_STYLESHEET);
		}
		String css = url.toExternalForm();
		scene.getStylesheets().add(css);
	}

	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * Called by MainController to pass input to logic for processing
	 * 
	 * @param input
	 *            - user input from textfield
	 */
	public void passInput(String input) {
		logic.run(input);
	}	
	
	//---------------------------------- GETTERS ----------------------------------------
	/**
	 * Called by MainController to get feedback message to display in feedback
	 * box. Output size = 0 indicates feedback message stored.
	 * 
	 * @return output.get(0)
	 */
	public String getMessage() {
		
		ArrayList<String> output = logic.getOutput();
		assert output != null : "Output = null, check logic output message";

		if (output.size() == 1) {
			return output.get(0);
		} else {
			return "";
		}
	}

	/**
	 * Called by MainController to get last output task list to display in table
	 * view.
	 * 
	 * @return logic.getLastOutputTaskList();
	 */
	public ArrayList<TaskObject> getLastOutputTaskList() {
		
		taskList = logic.getLastOutputTaskList();
		assert taskList != null : "Output = null, check logic lastOutputTaskList";

		return taskList;
	}

	/**
	 * Called by MainController to get output generated after processing user
	 * input. Used mainly to obtain help manual.
	 * 
	 * @return output - output from logic containing help manual
	 */
	public ArrayList<String> getOutput() {
		
		ArrayList<String> output = logic.getOutput();
		assert output != null : "Output = null, check logic output message";

		return output;
	}

	/**
	 * Called by MainController to get index of added task for focus.
	 * 
	 * @return logic.getSortedIndex()
	 */
	public int getSortedIndex() {
		return logic.getSortedIndex();
	}

	/**
	 * Called by MainController to obtain array list of task timings.
	 * 
	 * @return logic.getTaskDateTimeOutput()
	 */
	public ArrayList<String> getTaskDateOutput() {
		return logic.getTaskDateTimeOutput();
	}

}
```
###### \src\logic\constants\Index.java
``` java

package logic.constants;

public class Index {

	public static final int INDEX_ADD = 1;
	public static final int INDEX_SEARCH_DISPLAY = 2;
	public static final int INDEX_EDIT = 3;
	public static final int INDEX_DELETE = 4;
	public static final int INDEX_UNDO = 5;
	public static final int INDEX_REDO = 6;
	public static final int INDEX_SAVE = 7;
	public static final int INDEX_EXIT = 8;
	public static final int INDEX_HELP = 9;
	public static final int INDEX_COMPLETE = 10;
	public static final int INDEX_INCOMPLETE = 11;
	public static final int INDEX_LOAD = 12;
	
	public static final int RECURRENCE_CONSTANT_COUNT = 10;
	
	// Load indices
	public static final int LOAD_FROM = 1;
	public static final int LOAD_BACKUP = 2;
	public static final int STARTING_INDEX = 5;
	
}
```
###### \src\logic\constants\Strings.java
``` java

package logic.constants;

import common.TaskObject;

public class Strings {

	// common Constants
	public static final String CATEGORY_EVENT = "event";
	public static final String CATEGORY_DEADLINE = "deadline";
	public static final String CATEGORY_FLOATING = "floating";
	public static final String MESSAGE_INVALID_COMMAND = "Invalid command";
	public static final String STATUS_COMPLETED = "completed";
	public static final String STATUS_INCOMPLETE = "incomplete";
	public static final String STATUS_OVERDUE = "overdue";

	// Logic Constants
	public static final String MESSAGE_ALERT_EVENT = "Events today:";
	public static final String MESSAGE_ALERT_DEADLINE = "Deadlines today:";
	public static final String MESSAGE_INFORMATION_EVENT = "Task: %1s\nTime: %2s\n";
	public static final String MESSAGE_INFORMATION_DEADLINE = "Task: %1s\nDue: %2s\n";
	public static final String MESSAGE_BY_TODAY = "by end of today";
	public static final String MESSAGE_WELCOME_TASKS_OVERDUE_TODAY = "Tasks overdue and due today";
	public static final String MESSAGE_WELCOME_EMPTY = "No incomplete tasks. Add a task!";
	public static final String MESSAGE_WELCOME_TASKS_INCOMPLETE = "No tasks overdue and due today. \nDisplaying all incomplete tasks.";
	public static final String MESSAGE_FAILED_PROCESSING = "Failed to process input";

	// Recurring/Interval Constants
	public static final String FREQ_HOURLY = "HOURLY";
	public static final String FREQ_DAILY = "DAILY";
	public static final String FREQ_WEEKLY = "WEEKLY";
	public static final String FREQ_MONTHLY = "MONTHLY";
	public static final String FREQ_YEARLY = "YEARLY";
	public static final String MESSAGE_INVALID_RECURRENCE = "No valid end of recurrence";
	public static final String MESSAGE_INVALID_FREQUENCY = "Invalid frequency";

	// Add Constants
	public static final String MESSAGE_ADD_NON_RECURRING = "Task added: ";
	public static final String MESSAGE_ADD_RECURRING = "Recurring task added: ";
	public static final String MESSAGE_FAIL = "Failed to add task. ";
	public static final String MESSAGE_CLASH = "\nTask: %1s clashes with ";
	public static final String MESSAGE_INVALID_TIME = "Reason: Invalid time input.";
	public static final String MESSAGE_NULL_POINTER = "Reason: No object available to access.";
	public static final String MESSAGE_ADD_OVERDUE = "Task added is overdue.";
	public static final String MESSAGE_REQUEST_SAVE_LOCATION = "Error saving to file. Please enter \"save to\" followed by a valid file directory";

	// Delete Constants
	public static final String MESSAGE_DELETE = "Task deleted: %1s";
	public static final String MESSAGE_DELETE_ERROR = "Error deleting task. ";
	public static final String MESSAGE_DELETED_ALL = "All tasks deleted. Undo and redo lists are cleared.";
	public static final String MESSAGE_COMPLETED_TASKS_DELETE = "All completed tasks deleted.";
	public static final String MESSAGE_SINGLE_OCCURRENCE_DELETE = "Occurrence %1s deleted.";
	public static final String MESSAGE_MOST_RECENT_OCCURRENCE_DELETE = "Most recent occurrence of task '%1s' deleted.";
	public static final String MESSAGE_ALL_OCCURRENCES_DELETE = "All occurrences of task '%1s' deleted.";
	public static final String MESSAGE_ONLY_ONE_OCCURRENCE_REMAINING = "Only one occurrence remaining. ";
	public static final String MESSAGE_INDEX_OUT_OF_BOUNDS = "Requested index does not exist";
	public static final String MESSAGE_SINGLE_OCCURENCE_MISSING_ERROR = "Occurrence does not exist.";
	public static final String MESSAGE_FILE_NOT_FOUND = "File to save information to is not found.";
	public static final String MESSAGE_IO_EXCEPTION = "Unable to write tasks to storage file";

	// Display Constants
	public static final String MESSAGE_EMPTY_LIST = "Task list is empty.";
	public static final String MESSAGE_DISPLAYING_ALL_TASKS = "Displaying all tasks.";

	// Edit Constants
	public static final String MESSAGE_TITLE_EDIT = "Title edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_DATE_ADD = "Added date '%1s' to task '%2s'. ";
	public static final String MESSAGE_DATE_EDIT = "Date edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_DATE_FOR_OCCURRENCE_ADD = "Added date '%1s' to occurrence %2s. ";
	public static final String MESSAGE_DATE_FOR_OCCURRENCE_EDIT = "Date of occurrence %1s edited from '%2s' to %3s'. ";
	public static final String MESSAGE_DATE_FOR_ALL_OCCURRENCES_ADD = "Added date '%1s' to all occurrences. ";
	public static final String MESSAGE_DATE_FOR_ALL_OCCURRENCES_EDIT = "All dates edited to '%1s'. ";
	public static final String MESSAGE_TIME_ADD = "Added time '%1s' to task '%2s'. ";
	public static final String MESSAGE_TIME_EDIT = "Time edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_TIME_FOR_OCCURRENCE_ADD = "Added time '%1s' to occurrence %2s. ";
	public static final String MESSAGE_TIME_FOR_OCCURRENCE_EDIT = "TIme of occurrence %1s edited from '%2s' to %3s'. ";
	public static final String MESSAGE_TIME_FOR_ALL_OCCURRENCES_ADD = "Added time '%1s' to all occurrences. ";
	public static final String MESSAGE_TIME_FOR_ALL_OCCURRENCES_EDIT = "All times edited to '%1s'. ";
	public static final String MESSAGE_START_DATE_ADD = "Added start date '%1s' to task '%2s'. ";
	public static final String MESSAGE_START_DATE_EDIT = "Start date edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_START_DATE_FOR_OCCURRENCE_ADD = "Added start date '%1s' to occurrence %2s. ";
	public static final String MESSAGE_START_DATE_FOR_OCCURRENCE_EDIT = "Start date of occurrence %1s edited from '%2s' to '%3s'. ";
	public static final String MESSAGE_START_DATE_FOR_ALL_OCCURRENCES_ADD = "Added start date '%1s' to all occurrences. ";
	public static final String MESSAGE_START_DATE_FOR_ALL_OCCURRENCES_EDIT = "All start dates edited to '%1s'. ";
	public static final String MESSAGE_START_TIME_ADD = "Added start time '%1s' to task '%2s'. ";
	public static final String MESSAGE_START_TIME_EDIT = "Start time edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_START_TIME_FOR_OCCURRENCE_ADD = "Added start time '%1s' to occurrence %2s. ";
	public static final String MESSAGE_START_TIME_FOR_OCCURRENCE_EDIT = "Start time of occurrence %1s edited from '%2s' to '%3s'. ";
	public static final String MESSAGE_START_TIME_FOR_ALL_OCCURRENCES_ADD = "Added start time '%1s' to all occurrences. ";
	public static final String MESSAGE_START_TIME_FOR_ALL_OCCURRENCES_EDIT = "All start times edited to '%1s'. ";
	public static final String MESSAGE_END_DATE_ADD = "Added end date '%1s' to task '%2s'. ";
	public static final String MESSAGE_END_DATE_EDIT = "End date edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_END_DATE_FOR_OCCURRENCE_ADD = "Added end date '%1s' to occurrence %2s. ";
	public static final String MESSAGE_END_DATE_FOR_OCCURRENCE_EDIT = "End date of occurrence %1s edited from '%2s' to '%3s'. ";
	public static final String MESSAGE_END_DATE_FOR_ALL_OCCURRENCES_ADD = "Added end date '%1s' to all occurrences. ";
	public static final String MESSAGE_END_DATE_FOR_ALL_OCCURRENCES_EDIT = "All end dates edited to '%1s'. ";
	public static final String MESSAGE_END_TIME_ADD = "Added end time '%1s' to task '%2s'. ";
	public static final String MESSAGE_END_TIME_EDIT = "End time edited from '%1s' to '%2s'. ";
	public static final String MESSAGE_END_TIME_FOR_OCCURRENCE_ADD = "Added end time '%1s' to occurrence %2s. ";
	public static final String MESSAGE_END_TIME_FOR_OCCURRENCE_EDIT = "End time of occurrence %1s edited from '%2s' to '%3s'. ";
	public static final String MESSAGE_END_TIME_FOR_ALL_OCCURRENCES_ADD = "Added end time '%1s' to all occurrences. ";
	public static final String MESSAGE_END_TIME_FOR_ALL_OCCURRENCES_EDIT = "All end times edited to '%1s'. ";
	public static final String MESSAGE_INTERVAL_EDIT = "Interval edited. ";
	public static final String MESSAGE_NO_EDIT = "No edits have been made.";
	public static final String MESSAGE_NO_SUCH_OCCURRENCE_EXISTS = "No such occurrence exists. ";
	public static final String MESSAGE_SETTING_EDIT_INFO_ERROR = "Error setting edit information. ";

	// Load Constants
	public static final String KEYWORD_FROM = "from ";
	public static final String KEYWORD_BACKUP = "backup";
	public static final String MESSAGE_LOAD_SUCCESS = "Loaded file from: %1s";

	// Mark Constants
	public static final String MESSAGE_DONE = "Task: '%1s' marked as completed";
	public static final String MESSAGE_MARK_DONE_ERROR = "Error marking task as complete";
	public static final String MESSAGE_MARK_INCOMPLETE_ERROR = "Error marking task as incomplete";
	public static final String MESSAGE_MARK_OVERDUE_ERROR = "Error marking task as overdue";
	public static final String MESSAGE_INCOMPLETE = "Task: '%1s' is marked as incomplete";
	public static final String MESSAGE_OVERDUE = "Task: '%1s' is marked as overdue";
	public static final String MESSAGE_INCOMPLETE_OVERDUE = "Task: %1s cannot be marked as incomplete as it is overdue";

	// Save Constants
	public static final String MESSAGE_SAVE_TO = "Tasks have been, and will continue to be saved to %1s";
	public static final String MESSAGE_SAVE_AS = "Tasks have been saved to %1s";
	public static final String MESSAGE_SAVE_INVALID = "Save command is invalid";
	public static final String MESSAGE_SAVE_ERROR = "Error saving file to %1s";

	// Search Constants
	public static final String MESSAGE_SETTING_SEARCH_INFORMATION_ERROR = "Error setting search information.";
	public static final String MESSAGE_NO_RESULTS_FOUND = "No results found for the specified parameters.";
	public static final String MESSAGE_SEARCH_PARAMETERS = "Displaying tasks for the search parameters:\n%1s";
	public static final String MESSAGE_RECURRENCE_TIMINGS_DISPLAY = "Displaying recurrence timings for task %1s.";
	public static final String MESSAGE_NO_RECURRENCE_TIMING_DISPLAY = "Task %1s has no recurrence timings to be displayed.";
	public static final String MESSAGE_TIMINGS_FOUND = "Timings for %1s:";
	public static final String MESSAGE_TASK_INDEX_NOT_FOUND_ERROR = "No such task index found.";

	// TimeOutput Constants
	public static final String MESSAGE_DATE_TIME_CONVERSION_ERROR = "Error converting DateTime to GUI Display";
	public static final String MESSAGE_NULL_POINTER_EXCEPTION = "Not enough arguments within target object";
	public static final String DISPLAY_TIME_EVENT_1 = "from %1s on %2s \nto %3s on %4s";
	public static final String DISPLAY_TIME_EVENT_2 = "from %1s to %2s";
	public static final String DISPLAY_TIME_EVENT_3 = "from %1s to %2s \non %3s";
	public static final String DISPLAY_TIME_EVENT_4 = "from %1s on %2s \nto %3s";
	public static final String DISPLAY_TIME_EVENT_5 = "from %1s \nto %2s on %3s";
	public static final String DISPLAY_TIME_DEADLINE = "by %1s";

	// Redo Constants
	public static final String MESSAGE_REDO = "%1s redone.";
	public static final String MESSAGE_REDO_ERROR = "Nothing to redo!";
	public static final String MESSAGE_REDO_LIST_EMPTY = "Redo list is empty.";

	// Undo Constants
	public static final String MESSAGE_UNDO = "%1s undone.";
	public static final String MESSAGE_UNDO_ERROR = "Nothing to undo!";
	public static final String MESSAGE_UNDO_LIST_EMPTY = "Undo list is empty.";

	// Add Exception constants
	public static final String MESSAGE_ADD_EXCEPTION = "Error adding task to task list";
	public static final String MESSAGE_ADD_FLOATING_RECURRING = "Task with no time cannot be set as a recurring task";

	// Delete Exception constants
	public static final String MESSAGE_NO_INDEX_SPECIFIED_EXCEPTION = "Please specify a task index to delete.";
	
	// Edit Exception constants
	public static final String MESSAGE_EDIT_EXCEPTION = "Error editing %1s. ";
	public static final String MESSAGE_EDIT_END_TIME_WITHOUT_START_TIME_EXCEPTION = "Unable to edit end time without an existing start time.";
	public static final String MESSAGE_INVALID_NEW_START_TIMING_EXCEPTION = "New start timing cannot be after the end timing.";
	
	// Load Exception constants
	public static final String MESSAGE_LOAD_EXCEPTION_IO = "Error reading information from external file storage";
	public static final String MESSAGE_LOAD_EXCEPTION_FNF = "Saved storage file not found";
	public static final String MESSAGE_LOAD_EXCEPTION_JSON = "Error interpreting information from external file storage";
	public static final String MESSAGE_LOAD_EXCEPTION_IFP = "Invalid file path used";
	public static final String MESSAGE_LOAD_BACKUP = "Please key in \"load backup\" to load the backup file";

	// Mark Exception constants
	public static final String MESSAGE_MARK_EXCEPTION = "Error marking task: %1s.";
	public static final String MESSAGE_MARK_EXCEPTION_SAME_STATUS = "Task already has status: %1s";

	// Recurring Exception constants
	public static final String MESSAGE_RECURRENCE_EXCEPTION = "Error handling recurring task: %1s";
	public static final String MESSAGE_RECURRENCE_EXCEPTION_INVALID_STATUS = "Invalid status to change to";
	public static final String MESSAGE_RECURRENCE_EXCEPTION_INVALID_INTERVAL = "Interval is invalid";
	public static final String MESSAGE_RECURRENCE_EXCEPTION_INVALID_UNTIL = "End of Recurrence is invalid";
	public static final String MESSAGE_RECURRENCE_EXCEPTION_CORRUPTED = "Corrupted task: %1s removed";

	// Search Exception constants
	public static final String MESSAGE_SEARCH_BY_DATE_REQUIRED_EXCEPTION = "Search by time requires a search by date as well.";
	
	// FOR PACKAGE-WIDE DEBUGGING PURPOSES
	public static void printTaskObjectFields(TaskObject taskObj) {
		System.out.println("title = " + taskObj.getTitle());
		System.out.println("start date time = " + taskObj.getStartDateTime());
		System.out.println("start end time = " + taskObj.getEndDateTime());
		System.out.println("category = " + taskObj.getCategory());
		System.out.println("status = " + taskObj.getStatus());
		System.out.println("task id = " + taskObj.getTaskId());
		System.out.println("isRecurring = " + taskObj.getIsRecurring());
		System.out.println("taskDateTimes size = " + taskObj.getTaskDateTimes().size());
	}

}
```
###### \src\logic\sort\Sort.java
``` java

package logic.sort;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.logging.Logger;

import common.AtfLogger;
import common.TaskObject;
import storage.FileStorage;

public class Sort {
	
	private static Logger logger = AtfLogger.getLogger();

	private ArrayList<TaskObject> taskList;
	
	public Sort(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}
	
	public ArrayList<TaskObject> run() {
		Comparator<TaskObject> dateComparator = new Comparator<TaskObject>() {
			@Override
			public int compare(final TaskObject o1, final TaskObject o2) {
				if (!o1.getStatus().equals(o2.getStatus())) {
					return o2.getStatus().compareTo(o1.getStatus());
				} else if (!o1.getStartDateTime().equals(o2.getStartDateTime())) {
					return o1.getStartDateTime().compareTo(o2.getStartDateTime());
				} else if (!o1.getEndDateTime().equals(o2.getEndDateTime())) {
					return o1.getEndDateTime().compareTo(o2.getEndDateTime());
				} else {	
					return o1.getTitle().compareTo(o2.getTitle());
				}
			}
		};
		
		Collections.sort(taskList, dateComparator);
		saveExternal();
		logger.info("sorted and saved list");
		return taskList;
	}
	
	private void saveExternal() {
		try {
		FileStorage storage = FileStorage.getInstance();
		storage.save(taskList);
		} catch (NoSuchFileException e) {
			e.printStackTrace();
			logger.warning("unable to save sorted list to external file");
		} catch (IOException e) {
			e.printStackTrace();
			logger.warning("unable to save sorted list to external file");
		}
	}
}
```
###### \src\logic\sort\SortTest.java
``` java

package logic.sort;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;

import org.junit.Test;

import static org.junit.Assert.*;

import common.TaskObject;

public class SortTest {

	private ArrayList<TaskObject> testList = new ArrayList<TaskObject>();

	// incomplete tasks
	private TaskObject taskOne = new TaskObject("Do well for Finals",
			LocalDateTime.of(LocalDate.parse("2016-04-25"), LocalTime.parse("09:00")), "deadline", "incomplete", 1);
	private TaskObject taskTwo = new TaskObject("Submit CS2103",
			LocalDateTime.of(LocalDate.parse("2016-04-20"), LocalTime.parse("10:00")), "deadline", "incomplete", 2);
	private TaskObject taskThree = new TaskObject("Be awake early",
			LocalDateTime.of(LocalDate.parse("2016-04-20"), LocalTime.parse("11:00")), "deadline", "incomplete", 3);

	// overdue tasks
	private TaskObject taskFour = new TaskObject("Eat with my parents",
			LocalDateTime.of(LocalDate.parse("2016-03-30"), LocalTime.parse("19:00")), "deadline", "overdue", 4);
	private TaskObject taskFive = new TaskObject("Just a random task",
			LocalDateTime.of(LocalDate.parse("2016-04-09"), LocalTime.parse("19:00")), "deadline", "overdue", 5);

	// completed events with same startdate, different end dates
	private TaskObject taskSix = new TaskObject("Meeting with Block",
			LocalDateTime.of(LocalDate.parse("2012-01-31"), LocalTime.parse("21:00")),
			LocalDateTime.of(LocalDate.parse("2013-11-29"), LocalTime.parse("17:00")), "event", "complete", 6);
	private TaskObject taskSeven = new TaskObject("Project Meeting",
			LocalDateTime.of(LocalDate.parse("2012-01-31"), LocalTime.parse("21:00")),
			LocalDateTime.of(LocalDate.parse("2012-01-31"), LocalTime.parse("23:59")), "event", "complete", 7);

	// floating tasks
	private TaskObject taskEight = new TaskObject("Buy groceries", "floating", "incomplete", 8);
	private TaskObject taskNine = new TaskObject("Collect money from people", "floating", "incomplete", 9);

	/*
	 * Correct Sorted Sequence taskFour taskFive taskTwo taskThree taskOne
	 * taskEight taskNine taskSeven taskSix
	 */

	@Test
	public void testSort() {

		testList.add(taskOne);
		testList.add(taskTwo);
		testList.add(taskThree);
		testList.add(taskFour);
		testList.add(taskFive);
		testList.add(taskSix);
		testList.add(taskSeven);
		testList.add(taskEight);
		testList.add(taskNine);

		Sort testSort = new Sort(testList);
		ArrayList<TaskObject> actualOutput = testSort.run();

		ArrayList<TaskObject> correctOutput = new ArrayList<TaskObject>();

		correctOutput.add(taskFour);
		correctOutput.add(taskFive);
		correctOutput.add(taskTwo);
		correctOutput.add(taskThree);
		correctOutput.add(taskOne);
		correctOutput.add(taskEight);
		correctOutput.add(taskNine);
		correctOutput.add(taskSeven);
		correctOutput.add(taskSix);

		assertEquals(actualOutput, correctOutput);
		correctOutput.clear();
	}
}
```
