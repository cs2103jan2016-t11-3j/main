# A0124052X
###### \src\common\Interval.java
``` java

package common;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Comparator;

/**
 * A class for storing relevant information about a task's recurrence. 
 * Only accessed and used in the TaskObject if the task is recurring.
 * 
 * @author ChongYan
 *
 */
public class Interval implements Comparator<Interval> {

	public final String FREQ_HOURLY = "HOURLY";
	public final String FREQ_DAILY = "DAILY";
	public final String FREQ_WEEKLY = "WEEKLY";
	public final String FREQ_MONTHLY = "MONTHLY";
	public final String FREQ_YEARLY = "YEARLY";

	private final String MESSAGE_INVALID_FREQUENCY = "Invalid frequency";

	private String freq = "";
	private int interval = -1;
	private int count = -1;
	private LocalDateTime until = LocalDateTime.MAX;
	private String byDay = ""; // for multiple occurrences within the same
								// frequency -- TO BE DONE
	private int[] byDayArray = new int[8];

	public Interval() {
	}

	public Interval(String freq, int interval, int count, String byDay) throws Exception {
		setFrequency(freq);
		this.interval = interval;
		this.count = count;
		this.byDay = byDay;
		this.until = LocalDateTime.MAX;
		this.byDayArray[0] = 0;
		// Until cannot be a valid value if count exists
	}

	public Interval(String freq, int interval, LocalDateTime until, String byDay) throws Exception {
		setFrequency(freq);
		this.interval = interval;
		this.until = until;
		this.byDay = byDay;
		this.count = -1;
		this.byDayArray[0] = 0;
		// Count cannot be a valid value if until exists
	}

	public String getFrequency() {
		return freq;
	}

	public int getTimeInterval() {
		return interval;
	}

	public int getCount() {
		return count;
	}

	public LocalDateTime getUntil() {
		return until;
	}

	public String getByDay() {
		return byDay;
	}
	
	public int[] getByDayArray() {
		return byDayArray;
	}

	public void setFrequency(String freq) throws Exception {
		switch (freq) {

		case FREQ_HOURLY:
			this.freq = FREQ_HOURLY;
			break;

		case FREQ_DAILY:
			this.freq = FREQ_DAILY;
			break;

		case FREQ_WEEKLY:
			this.freq = FREQ_WEEKLY;
			break;

		case FREQ_MONTHLY:
			this.freq = FREQ_MONTHLY;
			break;

		case FREQ_YEARLY:
			this.freq = FREQ_YEARLY;
			break;

		default:
			Exception e = new Exception(MESSAGE_INVALID_FREQUENCY);
			throw e;
		}
	}

	public void setTimeInterval(int interval) {
		this.interval = interval;
	}

	public void setCount(int count) {
		this.count = count;
	}

	public void setUntil(LocalDateTime until) {
		this.until = until;
	}

	public void setByDay(String byDay) {
		this.byDay = byDay;
	}

	public void setByDay(int day) {
		if (day < 8) {
			byDayArray[0] = 1;
			byDayArray[day] = 1;
		}
	}

	@Override
	public int compare(Interval arg0, Interval arg1) {
		// TODO Auto-generated method stub
		return 0;
	}

	// Returns true if all the values are the default values
	public boolean isNull() {
		return (freq.equals("") && interval == -1 && count == -1 && until.equals(LocalDateTime.MAX));
	}
	
	// For debugging
	public void print() {
		System.out.println("freq = " + freq);
		System.out.println("interval = " + interval);
		System.out.println("count = " + count);
		System.out.println("until = " + until.toString());
		System.out.println("byDay = " + byDay);
		System.out.println("byDayArray = " + Arrays.toString(byDayArray));
	}
}
```
###### \src\common\LocalDateTimePair.java
``` java

package common;

import java.time.LocalDateTime;

/**
 * A pair class for LocalDateTime to store sets of timings for tasks. 
 * A deadline will have its endDateTime set to LocalDateTime.MAX.
 * 
 * @author ChongYan
 *
 */
public class LocalDateTimePair {
	
	private LocalDateTime startDateTime;
	private LocalDateTime endDateTime;
	
	// Constructor for events
	public LocalDateTimePair(LocalDateTime startDateTime, LocalDateTime endDateTime) {
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;
	}
	
	// Constructors for deadlines
	public LocalDateTimePair(LocalDateTime startDateTime) {
		this.startDateTime = startDateTime;
		this.endDateTime = LocalDateTime.MAX; // System defined value
	}
	
	// Empty constructor
	public LocalDateTimePair() {
		this.startDateTime = LocalDateTime.MAX;
		this.endDateTime = LocalDateTime.MAX;
		
	}
	
	public LocalDateTime getStartDateTime() {
		return startDateTime;
	}
	
	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}
	
	public void setStartDateTime(LocalDateTime startDateTime) {
		this.startDateTime = startDateTime;
	}
	
	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}
	
	public void setDateTimePair(LocalDateTimePair dateTimePair) {
		this.startDateTime = dateTimePair.getStartDateTime();
		this.endDateTime = dateTimePair.getEndDateTime();
	}
	
	public boolean equals(LocalDateTimePair newDateTimePair) {
		return (this.startDateTime.equals(newDateTimePair.getStartDateTime()) && this.endDateTime.equals(newDateTimePair.getEndDateTime()));
		
	}
	
	public boolean isEmpty() {
		return (this.startDateTime.equals(LocalDateTime.MAX) && this.endDateTime.equals(LocalDateTime.MAX));
	}
	
	// For debugging
	public String print() {
		return "Start date/time = " + startDateTime.toString() + ", End date/time = " + endDateTime.toString();
	}
	
}
```
###### \src\logic\add\Add.java
``` java

package logic.add;

import logic.*;
import logic.exceptions.AddException;
import logic.exceptions.RecurrenceException;
import storage.*;
import common.*;

import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.nio.file.NoSuchFileException;
import java.util.ArrayList;
import java.time.DateTimeException;
import java.time.LocalDateTime;
import java.util.logging.*;

import common.TaskObject;

import static logic.constants.Strings.*;

/**
 * Creates an "Add" object to facilitate adding of a task into Adult TaskFinder's TaskList. Tasks will be
 * added internally before being saved to its default file location. <br>
 * Events to be added will be checked against all existing events - the names of clashing events will be
 * generated in the output list, but the user will not be stopped from adding the event. <br>
 * Deadlines to be added will be checked if it is already overdue - overdue deadlines will have their status
 * toggled to "overdue" before being added.
 * 
 * @author ChongYan, RuiBin
 *
 */
public class Add {

	private TaskObject task;
	private int index;
	private int lastSearchedIndex;
	private boolean addedInternal = false;
	private boolean addedExternal = false;
	private boolean isClash = false;
	private boolean isOverdue = false;
	private ArrayList<TaskObject> taskList;
	private ArrayList<String> output = new ArrayList<String>();
	private ArrayList<TaskObject> clashedTasks = new ArrayList<TaskObject>();
	private boolean isExceptionThrown = false;
	
	private boolean isAddSingleOccurrence = false;
	private boolean isEvent = false;
	private boolean isDeadline = false;
	private boolean isFloating = false;

	private static Logger logger = AtfLogger.getLogger();

	public Add() {

	}

	/**
	 * Normal constructor for Add
	 * 
	 * @param taskObj
	 *            The task to be added, generated by parser.
	 * @param index
	 *            The position within the task list to add the task. Optional, default value 0.
	 * @param taskList
	 *            The list of tasks maintained internally by Adult TaskFinder
	 */
	public Add(TaskObject taskObj, int index, int lastSearchedIndex, ArrayList<TaskObject> taskList) {
		this.task = taskObj;
		this.index = index;
		this.lastSearchedIndex = lastSearchedIndex;
		this.taskList = taskList;
	}

	public Add(TaskObject taskObj, int index, ArrayList<TaskObject> taskList) {
		this.task = taskObj;
		this.index = index;
		this.taskList = taskList;
	}

	/**
	 * Called by logic to add the task initialised in the Add object to the task list.
	 * 
	 * @return output: ArrayList<String> - Contains all the output that the user will see
	 */
	public ArrayList<String> run() {
		// Special processing to handle undoing the deletion of an occurrence of a recurring task
		if (task.getIsContainingOnlyTaskDateTimes()) {
			addSingleOccurrence();
		} else {
			assert (!task.getTitle().equals(""));
			try {
				determineTaskCategory();
				processTaskInformation();
				addTask();
				saveToStorage();
				createOutput();
			} catch (DateTimeException e) {
				removeInternallyAddedTask();
				output.add(MESSAGE_FAIL + MESSAGE_INVALID_TIME);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "date within input task is invalid");
			} catch (NullPointerException e) {
				removeInternallyAddedTask();
				e.printStackTrace();
				output.add(MESSAGE_FAIL + MESSAGE_NULL_POINTER);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "tried to retrieve an unavailable object");
			} catch (RecurrenceException e) {
				removeInternallyAddedTask();
				String exceptionMessage = e.getRecurrenceExceptionMessage();
				output.add(exceptionMessage);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "task added has invalid recurrence properties");
			} catch (AddException e) {
				removeInternallyAddedTask();
				if (e.getIsRecurring() && e.getCategory().equals(CATEGORY_FLOATING)) {
					output.add(MESSAGE_ADD_EXCEPTION + " " + MESSAGE_ADD_FLOATING_RECURRING);
				} else {
					output.add(MESSAGE_ADD_EXCEPTION);
				}
				isExceptionThrown = true;
				logger.log(Level.WARNING, e.getMessage());
			} catch (InvalidPathException e) {
				removeInternallyAddedTask();
				output.add(MESSAGE_FAIL + MESSAGE_LOAD_EXCEPTION_IFP);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "invalid file path");
			} catch (NoSuchFileException e) {
				e.printStackTrace();
				output.add(MESSAGE_REQUEST_SAVE_LOCATION);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "did not manage to add task externally, invalid file");
			} catch (IOException e) {
				e.printStackTrace();
				output.add(MESSAGE_REQUEST_SAVE_LOCATION);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "did not manage to add task externally, IO exception");
			} catch (Exception e) {
				removeInternallyAddedTask();
				output.add(MESSAGE_FAIL);
				isExceptionThrown = true;
				logger.log(Level.WARNING, "task does not have a valid category");
			}
		}
		return output;
	}

	// ==========================================================================
	// First Level of Abstraction
	// ==========================================================================
	private void determineTaskCategory() {
		if (task.getCategory().equals(CATEGORY_EVENT)) {
			this.isEvent = true;
		}
		if (task.getCategory().equals(CATEGORY_DEADLINE)) {
			this.isDeadline = true;
		}
		if (task.getCategory().equals(CATEGORY_FLOATING)) {
			this.isFloating = true;
		}
	}

	/**
	 * Control flow to determine adding process for each type of task
	 * 
	 * @throws Exception
	 *             for any general exception
	 * @throws RecurrenceException
	 *             when there are problems adding recurrences to a task
	 * @throws AddException
	 *             when a floating task has a date time
	 */
	private void processTaskInformation() throws Exception, RecurrenceException, AddException {
		if (isEvent) {
			assert (!task.getStartDateTime().equals(LocalDateTime.MAX));
			assert (!task.getEndDateTime().equals(LocalDateTime.MAX));
			logger.log(Level.INFO, "event to be added");
			processEventDetails();
		}
		if (isDeadline) {
			assert (!task.getStartDateTime().equals(LocalDateTime.MAX));
			assert (task.getEndDateTime().equals(LocalDateTime.MAX));
			logger.log(Level.INFO, "deadline to be added");
			processDeadlineDetails();
		}
		if (isFloating) {
			assert (task.getStartDateTime().equals(LocalDateTime.MAX));
			assert (task.getEndDateTime().equals(LocalDateTime.MAX));
			logger.log(Level.INFO, "floating to be added");
			processFloatingDetails();
		}
		if (!isEvent && !isDeadline && !isFloating) {
			Exception e = new Exception("Invalid task");
			throw e;
		}
	}

	private void addTask() throws NullPointerException {
		int originalSize = taskList.size();
		int newSize = originalSize + 1;
		if (index != -1) { // must add at a specific point
			taskList.add(index - 1, task);
		} else {
			taskList.add(task);
		}

		if (taskList.size() == newSize) {
			addedInternal = true;
			logger.log(Level.INFO, "added task to internal taskList");
		} else {
			logger.log(Level.WARNING, "failed to add task");
		}
	}

	private void saveToStorage() throws NoSuchFileException, IOException {
		IStorage storage = FileStorage.getInstance();
		storage.save(taskList);
		addedExternal = true;
		logger.log(Level.INFO, "added task to external file storage");
	}

	private void createOutput() {
		if (addedInternal && addedExternal) {
			String title = task.getTitle().concat(". ");
			String text;

			text = concatenateTitleOutput(title);
			text = concatenateOverdueOutput(text);
			if (isClash) {
				text = concatenateClashOutput(text);
			}

			output.add(text);
			logger.log(Level.INFO, "output created successfully");
		} else if (output.isEmpty()) {
			output.add(MESSAGE_FAIL);
			logger.log(Level.WARNING, "task was not added, failure output created");
		}
	}

	// ==========================================================================
	// Second Level of Abstraction
	// ==========================================================================

	/*****************************************************************************/
	/**
	 * Checks for clashes between events (including recurrent times) and adds to taskList Also creates all
	 * dates and times for recurrent tasks
	 * 
	 * @throws RecurrenceException
	 *             if task is recurring but has a problem with setting all recurring times
	 */
	private void processEventDetails() throws RecurrenceException {
		this.isOverdue = checkIfOverdue();
		copyToTaskDateTimeList(task.getStartDateTime(), task.getEndDateTime());
		if (task.getIsRecurring()) {
			addRecurringEventTimes();
			removeAnyDeletedOccurrences();
		}
		if (isOverdue) {
			if (task.getIsRecurring()) {
				Recurring.updateEvent(task, taskList, STATUS_OVERDUE);
			} else {
				setTaskStatus(isOverdue);
			}
		}
		checkIfEventsClash();
	}

	/**
	 * Checks if a deadline is overdue, modifies status if necessary, adds to taskList
	 */
	private void processDeadlineDetails() throws RecurrenceException {
		this.isOverdue = checkIfOverdue();
		copyToTaskDateTimeList(task.getStartDateTime(), task.getEndDateTime());
		if (task.getIsRecurring()) {
			addRecurringDeadlineTimes(task);
		}
		if (isOverdue) {
			if (task.getIsRecurring()) {
				Recurring.updateDeadline(task, taskList, STATUS_OVERDUE);
			} else {
				setTaskStatus(isOverdue);
			}
		}
	}

	private void processFloatingDetails() throws AddException {
		if (task.getIsRecurring()) {
			AddException e = new AddException(task);
			throw e;
		}
	}

	// ============================================================================
	// Lower Levels of Abstraction
	// ============================================================================

	/**
	 * Copies startDateTime and endDateTime to taskDateTimes
	 * 
	 * @param startDateTime
	 *            LocalDateTime start date and time of event
	 * @param endDateTime
	 *            LocalDateTime end date and time of event
	 */
	private void copyToTaskDateTimeList(LocalDateTime startDateTime, LocalDateTime endDateTime) {
		LocalDateTimePair pair = new LocalDateTimePair(startDateTime, endDateTime);
		task.addToTaskDateTimes(pair);
	}

	private void addRecurringEventTimes() throws RecurrenceException {
		Recurring.setAllRecurringEventTimes(task);
	}
	
	private void addRecurringDeadlineTimes(TaskObject task) throws RecurrenceException {
		Recurring.setAllRecurringDeadlineTimes(task);
	}


	// @@ author A0124636H
	private void removeAnyDeletedOccurrences() {
		ArrayList<LocalDateTimePair> deletedOccurrences = task.getDeletedTaskDateTimes();
		LocalDateTimePair taskCurrentStartEndDateTime = new LocalDateTimePair(task.getStartDateTime(),
				task.getEndDateTime());

		try {
			for (int i = 0; i < deletedOccurrences.size(); i++) {
				logger.log(Level.INFO, "Removing occurrence that had been previously deleted");
				LocalDateTimePair deletedOccurrence = deletedOccurrences.get(i);

				for (int j = 0; j < task.getTaskDateTimes().size(); j++) {
					if (task.getTaskDateTimes().get(j).equals(deletedOccurrence)
							&& !task.getTaskDateTimes().get(j).equals(taskCurrentStartEndDateTime)) {
						task.getTaskDateTimes().remove(j);
					}
				}
			}
		} catch (IndexOutOfBoundsException e) {

		}
	}

	// @@ author A0124052X
	/**
	 * Throws Exception if time input is invalid. Deadline to be added has a valid date and time in its
	 * TaskObject <br>
	 * Converts date and time to the LocalDateTime format by calling static method in Logic class.
	 * 
	 * @return isOverdue: boolean - True if deadline is before current time
	 */
	private boolean checkIfOverdue() throws DateTimeException {
		boolean isOverdue = false;

		logger.log(Level.INFO, "going to check whether a deadline is overdue");

		if (task.getStartDateTime().isBefore(LocalDateTime.now())) {
			isOverdue = true;
		}
		return isOverdue;
	}

	private void setTaskStatus(boolean isOverdue) {
		if (isOverdue) {
			task.setStatus(STATUS_OVERDUE);
		}
		logger.log(Level.INFO, "toggled a task's status if applicable");
	}

	// Checks with incomplete, overdue events for clashes
	private void checkIfEventsClash() throws NullPointerException {
		if (task.getStartDateTime().isAfter(task.getEndDateTime())) {
			DateTimeException e = new DateTimeException("Start Date Time after End Date Time");
			throw e;
		}
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getCategory().equals(CATEGORY_EVENT)) {
				if (!taskList.get(i).getStatus().equals(STATUS_COMPLETED)) {
					checkAllExistingTimes(taskList.get(i));
				}
			}
		}
		logger.log(Level.INFO, "checked if events clash");
	}

	private void checkAllExistingTimes(TaskObject current) throws NullPointerException {
		ArrayList<LocalDateTimePair> currentTaskDateTimes = current.getTaskDateTimes();
		ArrayList<LocalDateTimePair> newTaskDateTimes = task.getTaskDateTimes();

		for (int i = 0; i < currentTaskDateTimes.size(); i++) {
			for (int j = 0; j < newTaskDateTimes.size(); j++) {
				processIndividualClashes(i, j, currentTaskDateTimes, newTaskDateTimes, current);
			}
		}
	}

	private void processIndividualClashes(int currentIndex, int newIndex,
			ArrayList<LocalDateTimePair> currentTaskDateTimes, ArrayList<LocalDateTimePair> newTaskDateTimes,
			TaskObject current) {

		LocalDateTime currentStart = currentTaskDateTimes.get(currentIndex).getStartDateTime();
		LocalDateTime currentEnd = currentTaskDateTimes.get(currentIndex).getEndDateTime();
		LocalDateTime newStart = newTaskDateTimes.get(newIndex).getStartDateTime();
		LocalDateTime newEnd = newTaskDateTimes.get(newIndex).getEndDateTime();

		if (checkIndividualTimeClash(currentStart, currentEnd, newStart, newEnd)) {
			this.isClash = true;
			addToClashedTasks(current);
			logger.log(Level.INFO, "detected a clash between non-recurring tasks");
		}
	}

	/**
	 * LocalDateTime format obtained by calling static method in Logic class Checks if two events clash.
	 * Achieves this by: <br>
	 * 1) Checking if event 1's start time is between event 2's start and end time <br>
	 * 2) Checking if event 1's end time is between event 2's start and end time <br>
	 * 3) Checking if event 2's start time is between event 1's start and end time <br>
	 * 4) Checking if event 2's end time is between event 1's start and end time
	 * 
	 * @param current
	 *            The TaskObject passed into the function from the task list.
	 * @return
	 */
	private boolean checkIndividualTimeClash(LocalDateTime currentStart, LocalDateTime currentEnd,
			LocalDateTime newStart, LocalDateTime newEnd) throws DateTimeException {

		// For special cases e.g. 1200-1400 and 1400-1600
		if (currentEnd.isEqual(newStart)) {
			return false;
		}
		if (newEnd.isEqual(currentStart)) {
			return false;
		}

		if (!currentStart.isBefore(newStart)) {
			if (!currentStart.isAfter(newEnd)) {
				return true;
			}
		}
		if (!currentEnd.isBefore(newStart)) {
			if (!currentEnd.isAfter(newEnd)) {
				return true;
			}
		}
		if (!newStart.isBefore(currentStart)) {
			if (!newStart.isAfter(currentEnd)) {
				return true;
			}
		}
		if (!newEnd.isBefore(currentStart)) {
			if (!newEnd.isAfter(currentEnd)) {
				return true;
			}
		}
		return false;
	}

	/********************************************************************************/
	/**
	 * Group of functions for addition of task
	 */

```
###### \src\logic\add\Add.java
``` java
	private String concatenateTitleOutput(String title) {
		String text;
		if (task.getIsRecurring()) {
			text = MESSAGE_ADD_RECURRING.concat(title);
			// "Recurring task added: -title-. "
		} else {
			text = MESSAGE_ADD_NON_RECURRING.concat(title);
			// "Task added: - title-."
		}
		return text;
	}

	private String concatenateOverdueOutput(String text) {
		if (isOverdue) {
			text = text.concat(MESSAGE_ADD_OVERDUE);
		}
		return text;
	}

	private String concatenateClashOutput(String text) {
		String clashFormat = String.format(MESSAGE_CLASH, task.getTitle());
		text = text.concat(clashFormat);
		for (int i = 0; i < clashedTasks.size(); i++) {
			String title = clashedTasks.get(i).getTitle() + ", ";
			text = text.concat(title);
		}
		text = text.substring(0, text.length() - 2);
		text = text.concat(". ");
		return text;
	}

	private void removeInternallyAddedTask() {
		if (addedInternal) {
			for (int i = 0; i < taskList.size(); i++) {
				if (taskList.get(i).getTaskId() == task.getTaskId()) {
					taskList.remove(i);
				}
			}
		}
	}

	/***************************************************************************/

	private void addToClashedTasks(TaskObject current) {
		boolean canAdd = true;
		for (int i = 0; i < clashedTasks.size(); i++) {
			if (clashedTasks.get(i).getTaskId() == current.getTaskId()) {
				canAdd = false;
			}
		}
		if (canAdd) {
			clashedTasks.add(current);
		}
	}

	// GETTERS, SETTERS
	public ArrayList<String> getOutput() {
		return output;
	}

	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}

	public TaskObject getTask() {
		return task;
	}

	public boolean getIsClash() {
		return isClash;
	}

	public boolean getIsAddSingleOccurrence() {
		return isAddSingleOccurrence;
	}

	public boolean getIsExceptionThrown() {
		return isExceptionThrown;
	}
	
	public ArrayList<TaskObject> getClashedTasks() {
		return clashedTasks;
	}

	public void setOutput(ArrayList<String> output) {
		this.output = output;
	}

	public void setTaskList(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}

	public void setTask(TaskObject task) {
		this.task = task;
	}
}
```
###### \src\logic\add\AddTest.java
``` java

package logic.add;

import common.*;

import java.time.LocalDateTime;
import java.util.ArrayList;

import static org.junit.Assert.*;

import org.junit.Test;
import org.junit.runners.MethodSorters;
import org.junit.FixMethodOrder;

import parser.Parser;

import common.TaskObject;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class AddTest {

	private static ArrayList<TaskObject> testArray = new ArrayList<TaskObject>();

	/*********************************************************************************/

	@Test
	// Add floating task. No partitions
	public void testZ() throws Exception {
		Parser parser = new Parser("add dinner by tmr 7pm", 1);
		ArrayList<String> actualOutput = new ArrayList<String>();
		// TaskObject task = new TaskObject("Dinner tonight", 1);
		TaskObject temp = parser.run().getTaskObject();
		Add add = new Add(temp, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: dinner. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add floating task. No partitions
	public void testA() {
		ArrayList<String> actualOutput = new ArrayList<String>();
		TaskObject task = new TaskObject("Dinner tonight", 1);
		task.setCategory("floating");
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: Dinner tonight. ");

		assertEquals(expectedOutput, actualOutput);
	}

	/*********************************************************************************/
	@Test
	// Add deadline not yet due
	public void testB() {
		ArrayList<String> actualOutput = new ArrayList<String>();
		TaskObject task = new TaskObject("Assignment 1", 2);
		task.setStatus("incomplete");
		task.setCategory("deadline");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 29, 15, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: Assignment 1. ");

		assertEquals(expectedOutput, actualOutput);

		assertEquals("incomplete", task.getStatus());
	}

	@Test
	// Add overdue deadline
	public void testC() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("CE2", 6);
		task.setCategory("deadline");
		task.setStartDateTime(LocalDateTime.of(2016, 02, 27, 16, 00));
		Add add = new Add(task, 3, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: CE2. Task added is overdue.");

		assertEquals(expectedOutput, actualOutput);

		String taskStatus = add.getTask().getStatus();
		assertEquals("overdue", taskStatus);
	}

	/*********************************************************************************/

	@Test
	// Add completely new event
	public void testD() {
		ArrayList<String> actualOutput = new ArrayList<String>();
		TaskObject task = new TaskObject("event 1", 1);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 25, 15, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 26, 12, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 1. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing event: StartDateTime and EndDateTime identical
	public void testE() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 2", 2);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 25, 15, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 26, 12, 00));
		Add add = new Add(task, 1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 2. \nTask: event 2 clashes with event 1. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing event: new task EndDateTime == current task StartDateTime
	public void testF() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 3", 3);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 25, 14, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 25, 15, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 3. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing event: new task StartDateTime == current task EndDateTime
	public void testG() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 4", 4);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 26, 12, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 26, 13, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 4. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add completely new event, overdue
	public void testH() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 5", 5);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 03, 31, 21, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 01, 20, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 5. Task added is overdue.");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing event: current task StartDateTime between new task start and end
	public void testI() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 6", 6);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 03, 31, 18, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 03, 31, 23, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 6. Task added is overdue.\nTask: event 6 clashes with event 5. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing event: current task EndDateTime between new task start and end
	public void testJ() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 7", 7);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 01, 17, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 01, 21, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 7. Task added is overdue.\nTask: event 7 clashes with event 5. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing event: New task starts and ends within timings of current task
	public void testK() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 8", 8);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 04, 01, 01, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 04, 01, 06, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 8. Task added is overdue.\nTask: event 8 clashes with event 5. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add completely new event
	public void testL() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 9", 9);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 12, 00, 30));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 12, 00, 31));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 9. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing events: Current event occurs during new event
	public void testM() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 10", 10);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 11, 21, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 12, 12, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 10. \nTask: event 10 clashes with event 9. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing events: New event starts the same time as current event
	public void testN() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 11", 11);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 11, 21, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 11, 22, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 11. \nTask: event 11 clashes with event 10. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add clashing events: New event ends the same time as current event
	public void testO() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 12", 12);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 12, 10, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 12, 12, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 12. \nTask: event 12 clashes with event 10. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add non-clashing event: new event ends right before current event
	public void testP() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 13", 13);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 11, 20, 30));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 11, 20, 59));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 13. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Add non-clashing event: new event starts right after current event
	public void testQ() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 14", 14);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 12, 12, 01));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 12, 12, 40));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task added: event 14. ");

		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Tests exception handling: start time after end time
	public void testR() {
		ArrayList<String> actualOutput = new ArrayList<String>();

		TaskObject task = new TaskObject("event 15", 15);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 05, 18, 12, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 05, 18, 11, 00));
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Failed to add task. Reason: Invalid time input.");

		assertEquals(expectedOutput, actualOutput);
	}

	/*********************************************************************************/

	@Test
	// Adds recurrent task with preset "until"
	public void testS() throws Exception {
		ArrayList<String> actualOutput = new ArrayList<String>();
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.of(2016, 9, 24, 12, 00), "");

		TaskObject task = new TaskObject("event 16", 16);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 06, 18, 12, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 06, 18, 14, 00));
		task.setInterval(interval);
		task.setIsRecurring(true);
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Recurring task added: event 16. ");
		assertEquals(expectedOutput, actualOutput);

		ArrayList<LocalDateTimePair> expectedDateTimes = new ArrayList<LocalDateTimePair>();

		LocalDateTime testStart = LocalDateTime.of(2016, 06, 18, 12, 00);
		LocalDateTime testEnd = LocalDateTime.of(2016, 06, 18, 14, 00);

		while (!testStart.isAfter(LocalDateTime.of(2016, 9, 24, 12, 00))) {
			LocalDateTimePair pair = new LocalDateTimePair(testStart, testEnd);
			expectedDateTimes.add(pair);
			testStart = testStart.plusWeeks(2);
			testEnd = testEnd.plusWeeks(2);
		}

		assertEquals(expectedDateTimes.size(), task.getTaskDateTimes().size());

		for (int i = 0; i < expectedDateTimes.size(); i++) {
			assertEquals(expectedDateTimes.get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getStartDateTime());
			assertEquals(expectedDateTimes.get(i).getEndDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
		}
	}

	@Test
	// Adds recurrent task with preset "count"
	public void testT() throws Exception {
		ArrayList<String> actualOutput = new ArrayList<String>();
		Interval interval = new Interval("DAILY", 6, 5, "");

		TaskObject task = new TaskObject("event 17", 17);
		task.setCategory("event");
		task.setStartDateTime(LocalDateTime.of(2016, 06, 26, 12, 00));
		task.setEndDateTime(LocalDateTime.of(2016, 06, 26, 14, 00));
		task.setInterval(interval);
		task.setIsRecurring(true);
		Add add = new Add(task, -1, testArray);
		actualOutput = add.run();

		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Recurring task added: event 17. \nTask: event 17 clashes with event 16. ");
		assertEquals(expectedOutput, actualOutput);

		assertTrue(add.getIsClash());

		ArrayList<LocalDateTimePair> expectedDateTimes = new ArrayList<LocalDateTimePair>();

		LocalDateTime testStart = LocalDateTime.of(2016, 06, 26, 12, 00);
		LocalDateTime testEnd = LocalDateTime.of(2016, 06, 26, 14, 00);

		for (int i = 0; i < interval.getCount(); i++) {
			LocalDateTimePair pair = new LocalDateTimePair(testStart, testEnd);
			expectedDateTimes.add(pair);
			testStart = testStart.plusDays(6);
			testEnd = testEnd.plusDays(6);
		}

		assertEquals(expectedDateTimes.size(), task.getTaskDateTimes().size());

		for (int i = 0; i < expectedDateTimes.size(); i++) {
			// System.out.println(task.getTaskDateTimes().get(i).getStartDateTime().toString());
			// System.out.println(task.getTaskDateTimes().get(i).getEndDateTime().toString());
			assertEquals(expectedDateTimes.get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getStartDateTime());
			assertEquals(expectedDateTimes.get(i).getEndDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
		}
	}
	/*********************************************************************************/
}
```
###### \src\logic\CommandFacade.java
``` java
	// ------------------------- METHODS FOR FILTERING THE DISPLAYED LIST -------------------------
	
	// hides completed tasks if command is not "view done"
	private void filterLastOutputTaskList() {
		if ((commandType == INDEX_SEARCH_DISPLAY) && (index == -1)
				&& (taskObj.getStatus().equals(STATUS_COMPLETED))) {
			return;
		} else {
			filterOutCompletedTasks();
			if (commandType == INDEX_COMPLETE) {
				addRecentlyCompletedTask();
			}
		}
	}

	private void filterOutCompletedTasks() {
		ArrayList<TaskObject> newLastOutputTaskList = new ArrayList<TaskObject>();
		for (int i = 0; i < lastOutputTaskList.size(); i++) {
			if (!lastOutputTaskList.get(i).getStatus().equals(STATUS_COMPLETED)) {
				newLastOutputTaskList.add(lastOutputTaskList.get(i));
			}
		}
		setLastOutputTaskList(newLastOutputTaskList);
	}

	private void addRecentlyCompletedTask() {
		ArrayList<TaskObject> newLastOutputTaskList = this.lastOutputTaskList;
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == lastCompletedTaskId) {
				newLastOutputTaskList.add(taskList.get(i));
			}
		}
		setLastOutputTaskList(newLastOutputTaskList);
	}

```
###### \src\logic\delete\Delete.java
``` java

package logic.delete;

import storage.*;
import common.AtfLogger;
import common.CommandObject;
import common.LocalDateTimePair;
import common.TaskObject;
import logic.Recurring;
import logic.exceptions.DeleteException;
import logic.exceptions.RecurrenceException;
import logic.timeoutput.TimeOutput;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.logging.*;

import static logic.constants.Strings.*;

/**
 * Creates a "Delete" object to facilitate the deletion of a task from task list internally, before updating
 * the file at its default location. <br>
 * 
 * There are five ways which Delete can be run: <br>
 * 1) Quick delete <br>
 * Input command: 'delete' Pre-condition that user has to add a task in his last command. Quick delete does
 * not require the user to input an index for deletion, it automatically deletes the last added task. This
 * will remove the entire task and all its occurrences, even if it is a recurring task. <br>
 * 
 * 2) Delete all <br>
 * Input command: 'delete all' This clears all lists - task list, undo list and redo list.
 * 
 * 3) Normal delete <br>
 * Input command: 'delete [index]' Pre-condition that user has to use a search/display function first. With
 * that task list which was displayed, the user proceeds to decide which item in the list he wishes to delete.
 * <br>
 * 
 * 4) Normal delete on recurring task <br>
 * Input command: 'delete [index]' If the task to be deleted is a recurring task, the upcoming occurrence will
 * be deleted and be replaced by the second occurrence.
 * 
 * 5) Delete all on recurring task Input command: 'delete [index] all' The recurring task and all related
 * occurrences will be deleted.
 *
 * @author ChongYan, RuiBin
 *
 */

public class Delete {

	private static Logger logger = AtfLogger.getLogger();

	// This command object contains the index number of the line to be deleted
	private CommandObject commandObj;

	private TaskObject removedTask = new TaskObject(); // Task that is removed
	private int removedTaskIndex = -1; // Stores the position of the task to be removed in the taskList
	// Stores the index of the timings to be removed (Only for recurrence and single occurrence delete)
	private int removedOccurrenceIndex = 1;
	// Stores the original timings
	private ArrayList<LocalDateTimePair> originalRecurrenceTimings = new ArrayList<LocalDateTimePair>(); 
	// Stores the details of the removed occurrence of the task
	private LocalDateTimePair removedTaskOccurrenceDetails = new LocalDateTimePair();
	
	// Actual name of the task which is to be deleted
	private String removedTaskName = "";
	// Actual task ID of the task requested to be deleted
	private int taskIdToBeDeleted = -1;
	// Check if the task to be deleted is a recurring task
	private boolean isRecurringTask = false;

	// Attributes that should be passed in when the delete object is first constructed
	private ArrayList<TaskObject> taskList;
	private ArrayList<TaskObject> lastOutputTaskList;
	private ArrayList<String> tempOutput = new ArrayList<String>();
	private ArrayList<String> output = new ArrayList<String>();
	private Deque<CommandObject> undoList = new ArrayDeque<CommandObject>();
	private Deque<CommandObject> redoList = new ArrayDeque<CommandObject>();
	private int lastSearchedIndex = -1;

	// Internal checkers
	private boolean isDeleteSingleOccurrence = false;
	private boolean isDeleteAll = false;
	private boolean hasDeletedInternal = false;
	private boolean hasDeletedExternal = false;
	private boolean isExceptionThrown = false;

	// Constructors
	public Delete() {

	}

	/**
	 * Default constructor for Quick Delete. <br>
	 * There will be an additional CommandObject initialised, with an index of -1.
	 * 
	 * @param taskList
	 *            Existing list of tasks in Adult TaskFinder
	 * @param undoList
	 *            Current stack of CommandObjects with the purpose of undoing previous actions
	 */
	public Delete(CommandObject commandObj, ArrayList<TaskObject> taskList, Deque<CommandObject> undoList) {
		this.taskList = taskList;
		this.undoList = undoList;
		this.commandObj = commandObj;
	}

	// Constructor for test cases
	public Delete(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList) {
		this.commandObj = commandObj;
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;
	}

	/**
	 * Default constructor for Normal Delete.
	 * 
	 * @param commandObj
	 *            Contains the index to delete from the last output task list
	 * @param taskList
	 *            Existing list of tasks in Adult TaskFinder
	 * @param lastOutputTaskList
	 *            List of tasks outputted in the last command (e.g. Search, Display)
	 * @param undoList
	 *            Deque containing the list of undo tasks
	 * @param redoList
	 *            Deque containing the list of redo tasks
	 */
	public Delete(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList, Deque<CommandObject> undoList,
			Deque<CommandObject> redoList) {
		this.commandObj = commandObj;
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;
		this.undoList = undoList;
		this.redoList = redoList;
		this.lastSearchedIndex = commandObj.getLastSearchedIndex();
	}

```
###### \src\logic\delete\Delete.java
``` java

	// Deletes all completed tasks from the task list
	private void runDeleteCompletedTasks() throws NoSuchFileException, IOException {
		for (int i = 0; i < taskList.size(); i++) {
			System.out.println(taskList.get(i).getTitle() + " " + taskList.get(i).getStatus());
			if (taskList.get(i).getStatus().equals(STATUS_COMPLETED)) {
				System.out.println("deleted: " + taskList.get(i).getTitle());
				taskList.remove(i);
				i--; // since all remaining index of taskList will be reduced by 1
			}
		}
		deleteExternal();
		createCompletedTasksDeletedOutput();
	}

```
###### \src\logic\delete\Delete.java
``` java

	// Delete is handled differently if it is a recurring task
	private void runNormalDelete()
			throws NullPointerException, IndexOutOfBoundsException, NoSuchFileException, IOException {
		assert (!taskList.isEmpty());

		hasDeletedInternal = deleteInternal();

		if (hasDeletedInternal) {
			hasDeletedExternal = deleteExternal();
			if (hasDeletedExternal) {
				createOutput();
				logger.log(Level.INFO, "Normal delete executed");
			}
		} else {
			createErrorOutput();
		}
	}

	private boolean deleteInternal() {
		try {
			taskList.remove(removedTaskIndex);
			logger.log(Level.INFO, "Task deleted from taskList");
			checkForOverdueTask();
			return true;
		} catch (NullPointerException e) {
			isExceptionThrown = true;
			return false;
		}
	}

	private boolean deleteExternal() throws NoSuchFileException, IOException {
		IStorage storage = FileStorage.getInstance();
		storage.save(taskList);
		logger.log(Level.INFO, "Storage file replaced");
		return true;
	}

```
###### \src\logic\delete\Delete.java
``` java

	private void setDeleteInformationForNormalDelete() {
		setTaskIdToBeDeleted();
		setRemovedTask();
		setRemovedTaskName();
		setIsRecurringTask();

		logger.log(Level.INFO, "Set delete information for normal delete");
	}

	private void setTaskIdToBeDeleted() {
		int index = commandObj.getIndex();
		assert (index > 0 && index <= lastOutputTaskList.size());

		taskIdToBeDeleted = lastOutputTaskList.get(index - 1).getTaskId();
	}

	private void setRemovedTask() {
		assert (taskIdToBeDeleted > 0);

		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == taskIdToBeDeleted) {
				removedTask = taskList.get(i);
				removedTaskIndex = i;
				lastSearchedIndex = i + 1;
			}
		}
	}

	private void setRemovedTaskName() {
		removedTaskName = removedTask.getTitle();
	}

	private void setIsRecurringTask() {
		isRecurringTask = removedTask.getIsRecurring();
	}

	// ----------------------- CREATING OUTPUT -----------------------

	private void createOutput() {
		if (isRecurringTask) {
			tempOutput.add(String.format(MESSAGE_ALL_OCCURRENCES_DELETE, removedTaskName));
		} else {
			tempOutput.add(String.format(MESSAGE_DELETE, removedTaskName));
		}
	}

	private void createErrorOutput() {
		removedTask = null;
		tempOutput.add(MESSAGE_DELETE_ERROR);
	}

	private void createCompletedTasksDeletedOutput() {
		tempOutput.add(MESSAGE_COMPLETED_TASKS_DELETE);
	}

	private void createDeletedAllOutput() {
		tempOutput.add(MESSAGE_DELETED_ALL);
	}

	private void createSingleOccurrenceOutput() {
		if (removedOccurrenceIndex == 1 && isRecurringTask) {
			tempOutput.add(String.format(MESSAGE_MOST_RECENT_OCCURRENCE_DELETE, removedTaskName));
		} else {
			tempOutput.add(String.format(MESSAGE_SINGLE_OCCURRENCE_DELETE, removedOccurrenceIndex));
		}
	}

	private void createSingleOccurrenceMissingErrorOutput() {
		removedTask = null;
		tempOutput.add(MESSAGE_SINGLE_OCCURENCE_MISSING_ERROR);

	}

	private void createOnlyOneOccurrenceRemainingOutput() {
		tempOutput.add(MESSAGE_ONLY_ONE_OCCURRENCE_REMAINING);
	}

	private void concatenateOutput() {
		assert (!tempOutput.isEmpty());

		String concatOutput = "";
		for (int i = 0; i < tempOutput.size(); i++) {
			concatOutput = concatOutput.concat(tempOutput.get(i));
		}

		output.add(concatOutput.trim());
	}

	// ----------------------- GETTERS AND SETTERS -----------------------

	public CommandObject getCommandObject() {
		return commandObj;
	}

	public TaskObject getRemovedTask() {
		return removedTask;
	}

	public int getRemovedOccurrenceIndex() {
		return removedOccurrenceIndex;
	}

	public ArrayList<String> getOutput() {
		return output;
	}

	public ArrayList<LocalDateTimePair> getOriginalRecurrenceTimings() {
		return originalRecurrenceTimings;
	}

	public LocalDateTimePair getRemovedTaskOccurrenceDetails() {
		return removedTaskOccurrenceDetails;
	}

	public ArrayList<TaskObject> getTaskList() {
		return taskList;
	}

	public Deque<CommandObject> getUndoList() {
		return undoList;
	}

	public Deque<CommandObject> getRedoList() {
		return redoList;
	}

	public boolean getIsDeleteAll() {
		return isDeleteAll;
	}

	public boolean getIsDeleteSingleOccurrence() {
		return isDeleteSingleOccurrence;
	}
	
	public boolean getIsExceptionThrown() {
		return isExceptionThrown;
	}

	public void setTaskList(ArrayList<TaskObject> taskList) {
		this.taskList = taskList;
	}

	public void setCommandObject(CommandObject commandObj) {
		this.commandObj = commandObj;
	}

	public void setTaskName(String removedTaskName) {
		this.removedTaskName = removedTaskName;
	}

	public void setRemovedTask(TaskObject removedTask) {
		this.removedTask = removedTask;
	}

	public void setOutput(ArrayList<String> output) {
		this.output = output;
	}

}
```
###### \src\logic\delete\DeleteTest.java
``` java

package logic.delete;

import static logic.constants.Index.*;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Deque;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayDeque;

import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runners.MethodSorters;

import common.CommandObject;
import common.LocalDateTimePair;
import common.TaskObject;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class DeleteTest {
	
	private ArrayList<LocalDateTimePair> testTimingsOne = new ArrayList<LocalDateTimePair>();
	private ArrayList<LocalDateTimePair> testTimingsTwo = new ArrayList<LocalDateTimePair>();

	private final ArrayList<TaskObject> testArray = new ArrayList<TaskObject> ();
	private final ArrayList<TaskObject> lastOutputList = new ArrayList<TaskObject> ();
	private TaskObject taskOne = new TaskObject("Hello", 200);
	private TaskObject taskTwo = new TaskObject("Nonsense", 178);
	private TaskObject taskThree = new TaskObject("Dinner tonight", LocalDateTime.of(2016, 02, 26, 19, 00), "deadline", "incomplete", 24);
	private CommandObject delete = new CommandObject(INDEX_DELETE, new TaskObject(), 1);
	private CommandObject deleteFail = new CommandObject(INDEX_DELETE, new TaskObject(), 2);
	private TaskObject deleteQuick = new TaskObject();
	private Deque<CommandObject> testUndoList = new ArrayDeque<CommandObject> ();

	/* For all NORMAL Delete **************************************************/
	@Test
	// Delete an applicable task
	public void testSuccess() {
		testArray.add(taskOne);
		testArray.add(taskTwo);
		testArray.add(taskThree);
		
		lastOutputList.add(taskOne);
		lastOutputList.add(taskThree);
		Delete deleteFirst = new Delete(delete, testArray, lastOutputList);
		ArrayList<String> actualOutput = deleteFirst.run();
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Task deleted: Hello");
		
		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	// Delete an inapplicable task
	public void testFail() {
		testArray.add(taskOne);		
		Delete deleteFirst = new Delete(deleteFail, testArray, lastOutputList);
		ArrayList<String> actualOutput = deleteFirst.run();
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Error deleting task. Requested index does not exist");
		
		assertEquals(expectedOutput, actualOutput);
	}
	
	/* For all QUICK Delete **************************************************
	@Test
	//Failed Quick delete test(One try)
	public void testQuickFail() {
		testArray.add(taskOne);
		testUndoList.push(new CommandObject(INDEX_ADD, deleteQuick));
		CommandObject cmd = new CommandObject(INDEX_DELETE, new TaskObject(), -1);
		Delete deleteLast = new Delete(cmd, testArray, testUndoList);
		ArrayList<String> actualOutput = deleteLast.run();
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Quick delete unavailable.");
		
		assertEquals(expectedOutput, actualOutput);
	}

	@Test
	//Successful Quick delete test(One try)
	public void testQuickSuccess() {
		testArray.add(taskOne);
		testUndoList.push(new CommandObject(INDEX_DELETE, deleteQuick));
		CommandObject cmd = new CommandObject(INDEX_DELETE, new TaskObject(), -1);
		Delete deleteLast = new Delete(cmd, testArray, testUndoList);
		ArrayList<String> actualOutput = deleteLast.run();
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task deleted: Hello");
		
		assertEquals(expectedOutput, actualOutput);
	}
	@Test
	// Multiple quick deletes (Two tries, first success, second fail)
	public void testMultipleQuick() {
		testArray.add(taskOne);
		testArray.add(taskTwo);
		testArray.add(taskThree);
		testUndoList.push(new CommandObject(INDEX_DELETE, deleteQuick));
		CommandObject cmd = new CommandObject(INDEX_DELETE, new TaskObject(), -1);
		Delete deleteOne = new Delete(cmd, testArray, testUndoList);
		ArrayList<ArrayList<String> > actualOutput = new ArrayList<ArrayList<String> > ();
		actualOutput.add(deleteOne.run());
		testUndoList.push(new CommandObject(INDEX_ADD, new TaskObject()));
		CommandObject cmdx = new CommandObject(INDEX_DELETE, new TaskObject(), -1);
		Delete deleteTwo = new Delete(cmdx, testArray, testUndoList);
		// Dummy add command to simulate the effect of deleting a task 
		actualOutput.add(deleteTwo.run());
		
		ArrayList<ArrayList<String> > expectedOutput = new ArrayList<ArrayList<String> > ();
		ArrayList<String> firstExpectedOutput = new ArrayList<String> ();
		firstExpectedOutput.add("Task deleted: Dinner tonight");
		expectedOutput.add(firstExpectedOutput);
		ArrayList<String> secondExpectedOutput = new ArrayList<String> ();
		secondExpectedOutput.add("Quick delete unavailable.");
		expectedOutput.add(secondExpectedOutput);
		
		assertEquals(expectedOutput, actualOutput);
	}*/

```
###### \src\logic\exceptions\AddException.java
``` java

package logic.exceptions;
import common.TaskObject;
import static logic.constants.Strings.*;

@SuppressWarnings("serial")
public class AddException extends Exception {
	
	private boolean isRecurring;
	private String category;
	
	public AddException() {
		
	}
	
	public AddException(TaskObject task) {
		super(MESSAGE_ADD_EXCEPTION);
		isRecurring = task.getIsRecurring();
		category = task.getCategory();
	}
	
	public boolean getIsRecurring() {
		return isRecurring;
	}
	
	public String getCategory() {
		return category;
	}

}
```
###### \src\logic\exceptions\MarkException.java
``` java

package logic.exceptions;

import static logic.constants.Strings.*;
import common.TaskObject;

@SuppressWarnings("serial")
public class MarkException extends Exception {

	public MarkException () {
		
	}
	
	public MarkException(TaskObject task) {
		super(String.format(MESSAGE_MARK_EXCEPTION, String.format(MESSAGE_MARK_EXCEPTION_SAME_STATUS, task.getStatus())));
	}
	
	public String getMarkExceptionMessage() {
		return super.getMessage();
	}
}
```
###### \src\logic\exceptions\RecurrenceException.java
``` java

package logic.exceptions;

import common.TaskObject;
import common.Interval;
import static logic.constants.Strings.*;

import java.time.LocalDateTime;

@SuppressWarnings("serial")
public class RecurrenceException extends Exception {

	private int taskId = -1;
	private String title = "";
	
	public RecurrenceException() {
		
	}
	
	public RecurrenceException(TaskObject task) {
		super(String.format(MESSAGE_RECURRENCE_EXCEPTION, task.getTitle()));
		this.taskId = task.getTaskId();
		this.title = task.getTitle();
	}
	
	public RecurrenceException(String errorMessage) {
		super(String.format(MESSAGE_RECURRENCE_EXCEPTION, errorMessage));
	}
	
	public RecurrenceException(Interval interval) {
		super(String.format(MESSAGE_RECURRENCE_EXCEPTION, MESSAGE_RECURRENCE_EXCEPTION_INVALID_INTERVAL));
	}
	
	public RecurrenceException(LocalDateTime until) {
		super(String.format(MESSAGE_RECURRENCE_EXCEPTION, MESSAGE_RECURRENCE_EXCEPTION_INVALID_UNTIL));
	}
	
	public String getRecurrenceExceptionMessage() {
		return super.getMessage();
	}
	
	public String getTaskName() {
		return title;
	}
	
	public int getTaskId() {
		return taskId;
	}
}
```
###### \src\logic\help\Help.java
``` java

package logic.help;

import java.util.ArrayList;

/**
 * Creates a Help object to display the user guide. There are two ways which the
 * manual can be displayed: <br>
 * 1) Entire user guide - The user does not key in any search keys. Entire
 * manual will be transferred to the output ArrayList for displaying <br>
 * 2) Parts related to the topic of interest - Based on the search keys entered
 * by the user, the program searches for topics related and displays all
 * sections related to it. If the topic of interest does not exist, an error
 * message will be returned to the user will be returned through the same output
 * channel.
 * 
 * @author ChongYan
 *
 */
public class Help {

	// Messages used within the function
	public static final String MESSAGE_NO_TOPIC = "Sorry, the topic you requested is not available";

	// Number of topics in user manual
	private static final int MAX_TOPIC_NUMBER = 28;

	// Attributes contained in the helpFunction class
	private ArrayList<HelpTopic> manual = new ArrayList<HelpTopic>();
	// Entire manual will be stored in this once a new object is called
	private ArrayList<String> display = new ArrayList<String>();
	private String searchKey = "";

	// Constructors
	public Help() {
		importManual();
	}

	public Help(String line) {
		searchKey = line;
		importManual();
	}

	// Getters and Setters;
	public ArrayList<HelpTopic> getManual() {
		return manual;
	}

	public ArrayList<String> getDisplay() {
		return display;
	}

	public String getSearchKey() {
		return searchKey;
	}

	public void setSearchKey(String line) {
		searchKey = line;
	}

	// Class methods

	// Imports manual from text files using objects called HelpTopics
	private void importManual() {
		for (int i = 1; i <= MAX_TOPIC_NUMBER; i++) {
			manual.add(new HelpTopic(i));
		}
	}

	/**
	 * Main method in Help which copies all information related to the topic
	 * requested, or all information if no topics were requested, to the output
	 * ArrayList
	 * 
	 * @return output: ArrayList<String>
	 */
	public ArrayList<String> run() {
		if (searchKey == "") {
			for (int i = 0; i < MAX_TOPIC_NUMBER; i++) {
				createDisplay(i);
			}
			return display;
		} else {
			runSearch();
			if (display.isEmpty()) {
				display.add(MESSAGE_NO_TOPIC);
			}
			return display;
		}
	}

	private void createDisplay(int num) {
		int i = 0;
		String text = "";
		display.add(manual.get(num).getTopicName());
		while (i < manual.get(num).getDetails().size()) {
			text = manual.get(num).getDetails().get(i);
			display.add(text);
			i++;
		}
	}

	private void runSearch() {
		String name;
		for (int i = 0; i < MAX_TOPIC_NUMBER; i++) {
			name = manual.get(i).getTopicName();
			if (name.toUpperCase().contains(searchKey.toUpperCase())) {
				createDisplay(i);
			}
		}
	}
}
```
###### \src\logic\help\HelpTest.java
``` java

package logic.help;

import static org.junit.Assert.*;

import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class HelpTest {

	private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
	// File Path
	public static String FILE_PATH = "/src/logic/help/";

	@Test
	// For invalid search string
	public void testHelpFunctionOne() {
		PrintStream printStream = new PrintStream(outContent);
		System.setOut(printStream);
		Help helper = new Help("hello");
		ArrayList<String> toDisplay = new ArrayList<String>();
		toDisplay = helper.run();
		for (int i = 0; i < toDisplay.size(); i++) {
			System.out.print(toDisplay.get(i));
			assertEquals(Help.MESSAGE_NO_TOPIC, outContent.toString());
		}
		printStream.flush();
	}

	@Test
	// For no search string
	public void testHelpFunctionTwo() {
		PrintStream newPrintStream = new PrintStream(outContent);
		System.setOut(newPrintStream);
		String text = "";
		int i = 0;
		Help help = new Help();
		ArrayList<String> toDisp = new ArrayList<String>();
		toDisp = help.run();
		try {
			File fakeFile = new File("");
			String path = fakeFile.getAbsolutePath(); // To obtain working directory
			File file = new File(path + FILE_PATH + "1.txt");
			FileReader fileReader = new FileReader(file);
			BufferedReader reader = new BufferedReader(fileReader);
			text = reader.readLine();
			System.out.println(toDisp.get(i));
			assertEquals(text, "Add a floating task");
			i++;
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}
	}
}
```
###### \src\logic\load\Load.java
``` java
package logic.load;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.logging.Logger;

import com.google.gson.JsonSyntaxException;

import common.AtfLogger;
import common.TaskObject;
import storage.FileStorage;
import storage.IStorage;

import static logic.constants.Strings.*;
import static logic.constants.Index.*;

/**
 * This class serves to load tasks from another source file other than the existing, default source file.
 * There are two ways a load object could be run: <br>
 * 1. Loading from a user defined directory <br>
 * 2. Loading from a backup copy. This backup copy is saved internally within the program, and is saved in
 * parallel with the original copy that the user has access to.
 * 
 * @author ChongYan
 *
 */
public class Load {

	static Logger logger = AtfLogger.getLogger();

	private TaskObject task;
	private int loadCommand = -1;
	private String filePath = "";
	private ArrayList<String> output = new ArrayList<String>();
	private ArrayList<TaskObject> loadedTaskList = new ArrayList<TaskObject>();

	public Load(TaskObject task) {
		this.task = task;
		processLoadCommand();
	}

	private void processLoadCommand() {
		String command = task.getTitle();
		if (command.startsWith(KEYWORD_FROM)) {
			loadCommand = LOAD_FROM;
			obtainFilePath(command);
		} else if (command.startsWith(KEYWORD_BACKUP)) {
			loadCommand = LOAD_BACKUP;
		} else {
			logger.warning("Load Command is invalid");
		}
	}

	private void obtainFilePath(String command) {
		filePath = command.substring(STARTING_INDEX);
	}

	/**
	 * Main method within the Load class. Creates a FileStorage Object and accesses the storage component, and
	 * attempts to retrieve all tasks from a set location.
	 * 
	 * @return ArrayList<String> containing output to be displayed to the user. Output varies according to the
	 *         type of load command and also depends on whether it is successful.
	 */
	public ArrayList<String> run() {
		try {
			IStorage storage = FileStorage.getInstance();
			loadFile(storage);
			logger.info("obtained task list from alternative storage");
		} catch (InvalidPathException e) {
			logger.warning("invalid file path provided");
			createErrorOutput(MESSAGE_LOAD_EXCEPTION_IFP);
		} catch (FileNotFoundException e) {
			logger.warning("file cannot be found");
			createErrorOutput(MESSAGE_LOAD_EXCEPTION_FNF);
		} catch (JsonSyntaxException e) {
			logger.warning("external file format cannot be read");
			createErrorOutput(MESSAGE_LOAD_EXCEPTION_JSON);
		} catch (IOException e) {
			logger.warning("general IO exception");
			createErrorOutput(MESSAGE_LOAD_EXCEPTION_IO);
		}
		return output;
	}

	/**
	 * Loads a file using the FileStorage object. Method determines whether the command is to load from a
	 * user-defined location or from the backup, and proceeds to load the tasks.
	 * 
	 * @param storage
	 *            FileStorage object which is used to access all stored information
	 * @throws InvalidPathException
	 *             Thrown when the file path given is invalid
	 * @throws FileNotFoundException
	 *             Thrown when the file does not exist at the given location
	 * @throws JsonSyntaxException
	 *             Thrown when the file at the given location has an invalid syntax and cannot be read by the
	 *             library
	 * @throws IOException
	 *             General IO Exception in case of any unforeseen circumstances
	 */
	private void loadFile(IStorage storage)
			throws InvalidPathException, FileNotFoundException, JsonSyntaxException, IOException {
		if (loadCommand == LOAD_FROM) {
			loadedTaskList = storage.load(filePath);
			createOutput();
		} else if (loadCommand == LOAD_BACKUP) {
			loadedTaskList = storage.loadBackup();
			createOutput();
		} else {
			IOException e = new IOException("Invalid command");
			throw e;
		}
	}

	private void createOutput() {
		if (loadCommand == LOAD_FROM) {
			System.out.println(filePath);
			output.add(String.format(MESSAGE_LOAD_SUCCESS, "\n" + filePath));
		} else if (loadCommand == LOAD_BACKUP) {
			output.add(String.format(MESSAGE_LOAD_SUCCESS, KEYWORD_BACKUP));
		}
	}

	private void createErrorOutput(String message) {
		output.clear();
		output.add(message);
	}

	// =============================================================================

	public ArrayList<TaskObject> getLoadedTaskList() {
		return loadedTaskList;
	}

	public ArrayList<String> getOutput() {
		return output;
	}
}
```
###### \src\logic\Logic.java
``` java

package logic;

import parser.*;
import storage.FileStorage;
import logic.mark.*;
import logic.timeoutput.*;
import logic.exceptions.*;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.gson.JsonSyntaxException;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

import common.AtfLogger;
import common.CommandObject;
import common.TaskObject;

/**
 * Main driver for Adult TaskFinder. Upon initialisation of the object, retrieves all existing tasks from an
 * external file source and places them into an ArrayList of TaskObjects. The main Logic object initialised in
 * the GUI will exist until exit command is inputted. <br>
 * Alternatively, secondary Logic objects may be initialised when Undo or Redo commands are given. In this
 * case, secondary Logic objects will only carry out the specific task required before it "dies".
 * 
 * @param taskList
 *            - Initialised as an empty list of TaskObjects, will maintain all TaskObjects existing in Adult
 *            TaskFinder internally throughout the runtime of the program.
 * @param undoList
 *            - Stack of CommandObjects stored for undoing. Every time a command is executed, the reverse of
 *            that command will be pushed into undoList in the form of a CommandObject.
 * @param redoList
 *            - Stack of CommandObjects stored for redoing. Every time a command is popped from the undoList
 *            for undoing, the reverse of that command will be pushed into the redoList as an CommandObject.
 *            Clears itself whenever the user inputs a command which is not "undo".
 * @author ChongYan, RuiBin
 *
 */

public class Logic {

	static Logger logger = AtfLogger.getLogger();
	// Maintained throughout the entire running operation of the program
	protected ArrayList<TaskObject> taskList = new ArrayList<TaskObject>();
	private Deque<CommandObject> undoList = new ArrayDeque<CommandObject>();
	private Deque<CommandObject> redoList = new ArrayDeque<CommandObject>();
	private int taskId; // For generation of a unique task ID for each task

	// This variable will get repeatedly updated by UI for each input
	private String userInput;
	// Output is to be returned to UI after each command
	private ArrayList<String> output = new ArrayList<String>();
	// Output containing the list of timings pertaining to a single task
	private ArrayList<String> taskDateTimeOutput = new ArrayList<String>();
	// Keeps track of the list that is constantly displayed in UI
	private ArrayList<TaskObject> lastOutputTaskList = new ArrayList<TaskObject>();
	// Stores the index of the last task searched
	private int lastSearchedIndex = -1;
	private int sortedIndex = -1;

	/**
	 * Constructor called by UI only upon starting up. Loads all existing tasks and checks each task to see
	 * whether any of them are overdue, and updates their corresponding statuses. Sets the next Task ID of a
	 * task which will be added to the list. Also calls method to set up the list of tasks which will be shown
	 * to users, as well as the relevant welcome message.
	 */
	public Logic() {
		taskList = new ArrayList<TaskObject>();
		undoList = new ArrayDeque<CommandObject>();
		redoList = new ArrayDeque<CommandObject>();
		runPreProcessingOfList();
	}
	
```
###### \src\logic\Logic.java
``` java
	
	// Called when the task list is first initialised on startup of the program
	public void runPreProcessingOfList() {
		try {
			loadTaskList();
			TimeOutput.setTimeOutputForGui(taskList);
			setStartingTaskId();
			checkOverdue();
			Recurring.updateRecurringEvents(taskList);
			Recurring.updateRecurringDeadlines(taskList);
			createFirstOutputTaskList();
		} catch (RecurrenceException e) {
			String exceptionMessage;
			if (e.getTaskId() != -1) {
				removeFromTaskList(e.getTaskId());
				exceptionMessage = String.format(MESSAGE_RECURRENCE_EXCEPTION_CORRUPTED, e.getTaskName());
			} else {
				exceptionMessage = e.getRecurrenceExceptionMessage();
			}
			output.add(exceptionMessage);
			logger.log(Level.WARNING, "unable to update recurrences");
		} catch (InvalidPathException e) {
			logger.warning("invalid file path provided");
			output.add(MESSAGE_LOAD_EXCEPTION_IFP + ". " + MESSAGE_LOAD_BACKUP);
		} catch (FileNotFoundException e) {
			output.add(MESSAGE_LOAD_EXCEPTION_FNF + ". " + MESSAGE_LOAD_BACKUP);
			logger.log(Level.WARNING,
					"unable to read information from external file storage, file not found");
		} catch (IOException e) {
			output.add(MESSAGE_LOAD_EXCEPTION_IO + ". " + MESSAGE_LOAD_BACKUP);
			logger.log(Level.WARNING,
					"unable to read information from external file storage, general IO exception");
		} catch (JsonSyntaxException e) {
			output.add(MESSAGE_LOAD_EXCEPTION_JSON + ". " + MESSAGE_LOAD_BACKUP);
			logger.log(Level.WARNING,
					"unable to read information from external file storage, Json syntax error");
		}
		logger.info("Start logic");
	}

	/**
	 * Internal method which is called during the initialisation of Logic object. Purpose of this method is
	 * to call storage and retrieve all existing task information from the external file source, if available
	 * 
	 * @throws FileNotFoundException
	 *             Specific exception where file does not exist, will be caught and processed by Logic
	 *             constructor
	 * @throws JsonSyntaxException
	 *             Specific exception where the Json Library is unable to read the external file, will be
	 *             caught and processed by Logic constructor
	 * @throws IOException
	 *             General exception for failing to read a file, will be caught and processed by Logic
	 *             constructor
	 */
	private void loadTaskList() throws 
			InvalidPathException, FileNotFoundException, JsonSyntaxException, IOException {
		FileStorage storage = FileStorage.getInstance();
		taskList = storage.load();
		setLastOutputTaskList(taskList);
	}

```
###### \src\logic\Logic.java
``` java

	// Checks for overdue tasks at the start when the program is first run
	private void checkOverdue() {
		Overdue.markAllOverdueTasks(taskList);
	}
	
	/**
	 * Method which is only called during startup of AdultTaskFinder. Tasks are added to a "first output" task
	 * list in the following order: <br>
	 * 1. Tasks overdue <br>
	 * 2. Tasks due today <br>
	 * If there are no tasks in the task list at this point, method will proceed to look for tasks which are
	 * incomplete and add them to the "first output" task list, regardless of whether it is due today, even if
	 * it is a floating task. <br>
	 * However, if there are no tasks in the list even at this point, then no tasks will be showed on startup.
	 * The message shown to the user varies based on the tasks which were added to the "first output" task
	 * list.
	 */
	private void createFirstOutputTaskList() {
		ArrayList<TaskObject> firstOutputTaskList = new ArrayList<TaskObject>();
		ArrayList<String> firstOutput = new ArrayList<String>();

		addOverdueTasksToFirstOutputTaskList(firstOutputTaskList);
		addTasksDueTodayToFirstOutputTaskList(firstOutputTaskList);
		if (firstOutputTaskList.isEmpty()) {
			addIncompleteTasksToFirstOutputTaskList(firstOutputTaskList);
		} else {
			firstOutput.add(MESSAGE_WELCOME_TASKS_OVERDUE_TODAY);
			logger.log(Level.INFO, "added overdue and tasks due today to show on startup");
		}

		if (firstOutputTaskList.isEmpty()) {
			firstOutput.add(MESSAGE_WELCOME_EMPTY);
			logger.log(Level.INFO, "no incomplete tasks to show on startup");
		} else {
			if (firstOutput.isEmpty()) {
				firstOutput.add(MESSAGE_WELCOME_TASKS_INCOMPLETE);
				logger.log(Level.INFO, "added incomplete tasks to show on startup");
			}
		}

		setLastOutputTaskList(firstOutputTaskList);
		setOutput(firstOutput);
	}

	private void addOverdueTasksToFirstOutputTaskList(ArrayList<TaskObject> firstOutputTaskList) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getStatus().equals(STATUS_OVERDUE)) {
				firstOutputTaskList.add(taskList.get(i));
			}
		}
	}

	private void addTasksDueTodayToFirstOutputTaskList(ArrayList<TaskObject> firstOutputTaskList) {
		for (int i = 0; i < taskList.size(); i++) {
			if (!taskList.get(i).getStatus().equals(STATUS_COMPLETED)) {
				if (taskList.get(i).getStartDateTime().toLocalDate().equals(LocalDate.now())) {
					if (checkNotDuplicate(taskList.get(i), firstOutputTaskList)) {
						firstOutputTaskList.add(taskList.get(i));
					}
				}
			}
		}
	}

	private void addIncompleteTasksToFirstOutputTaskList(ArrayList<TaskObject> firstOutputTaskList) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getStatus().equals(STATUS_INCOMPLETE)) {
				firstOutputTaskList.add(taskList.get(i));
			}
		}
	}

	private boolean checkNotDuplicate(TaskObject task, ArrayList<TaskObject> firstOutputTaskList) {
		for (int i = 0; i < firstOutputTaskList.size(); i++) {
			if (task.getTaskId() == firstOutputTaskList.get(i).getTaskId()) {
				return false;
			}
		}
		return true;
	}

	private void removeFromTaskList(int taskId) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == taskId) {
				taskList.remove(i);
			}
		}
	}
	
```
###### \src\logic\LogicTest.java
``` java
	
	@Test // Invalid delete
	public void testAF() {
		logic.run("delete");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Please specify a task index to delete.");
		
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getTaskList().size());
		assertEquals(2, logic.getLastOutputTaskList().size());
	}
	
	@Test // Test normal deletion
	public void testAG() {
		logic.run("delete 2");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Task deleted: CS2103 v0.5");
		
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getTaskList().size());
		assertEquals(1, logic.getLastOutputTaskList().size());
	}
	
	// At this point, taskList is empty
	
	@Test // Test delete 3rd recurring time
	public void testAH() {
		logic.run("add run every day by 2359hrs until 30 April");
		logic.run("view 1");
		
		int originalNumberOfOccurrences = logic.getTaskList().get(0).getTaskDateTimes().size();
		
		logic.run("delete 3");
		
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Occurrence 3 deleted.");
		
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getTaskList().size());
		assertEquals(2, logic.getLastOutputTaskList().size());
		assertEquals(originalNumberOfOccurrences - 1, logic.getTaskList().get(0).getTaskDateTimes().size());
	}
	
	@Test // test search for title
	public void testAI() {
		logic.run("add CS2103 lecture every saturday from 4pm to 6pm until 1 May");
		logic.run("add assignment 1 by 30/4 4pm");
		logic.run("add IE2100 lecture every saturday from 7pm to 9pm");
		
		assertEquals(5, logic.getTaskList().size());
		
		for (int i = 0; i < logic.getTaskList().size(); i++) {
			System.out.println(logic.getTaskList().get(i).getTitle());
		}
		
		logic.run("search lecture");
		ArrayList<String> expectedOutput = new ArrayList<String>();
		expectedOutput.add("Displaying tasks for the search parameters:\n\'lecture\'");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getLastOutputTaskList().size());
		
		logic.run("search junk");
		expectedOutput.clear();
		expectedOutput.add("No results found for the specified parameters.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getLastOutputTaskList().size());
	}
	
	@Test // search by category
	public void testAJ() {
		logic.run("search event");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Displaying tasks for the search parameters:\n\'event\'");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(3, logic.getLastOutputTaskList().size());
		
		logic.run("search deadline");
		expectedOutput.clear();
		expectedOutput.add("Displaying tasks for the search parameters:\n\'deadline\'");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getLastOutputTaskList().size());
	}
	
	@Test // marking a task as done
	public void testAK() {
		logic.run("done 1");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Task: \'run\' marked as completed");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(6, logic.getLastOutputTaskList().size());
	}
	
	@Test // search by status and display
	public void testAL() {
		logic.run("view completed");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Displaying tasks for the search parameters:\n\'completed\'");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		
		logic.run("display");
		expectedOutput.clear();
		expectedOutput.add("Displaying all tasks.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(5, logic.getLastOutputTaskList().size());
	}
	
	@Test // delete all occurrences
	public void testAM() {
		logic.run("delete 2 all");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("All occurrences of task \'event\' deleted.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(4, logic.getLastOutputTaskList().size());
		assertEquals(5, logic.getTaskList().size());
	}
	
	@Test // delete done
	public void testAN() {
		logic.run("delete done");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("All completed tasks deleted.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(4, logic.getLastOutputTaskList().size());
		assertEquals(4, logic.getTaskList().size());
	}
	
	@Test // search date
	public void testAO() {
		logic.run("search 30/4");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Displaying tasks for the search parameters:\n\'2016-04-30\'");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		assertEquals(4, logic.getTaskList().size());
	}
	
	@Test // edit title
	public void testAP() {
		logic.run("display");
		logic.run("edit 3 IE3100 Lecture");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Title edited from \'IE2100 lecture\' to \'IE3100 Lecture\'.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(4, logic.getLastOutputTaskList().size());
	}
	
	@Test // edit date and time
	public void testAQ() {
		logic.run("edit 4 by 1900hrs 25/4");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Date edited from \'2016-04-30\' to \'2016-04-25\'. \nTime edited from \'16:00\' to \'19:00\'.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(4, logic.getLastOutputTaskList().size());
	}
	
	@Test // search date and time
	public void testAR() {
		logic.run("search 25/4 1900hrs");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Displaying tasks for the search parameters:\n\'2016-04-25\', \'19:00\'");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
	}
	
	@Test // load backup
	public void testAS() {
		logic.run("load backup");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Loaded file from: backup");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(4, logic.getLastOutputTaskList().size());
		assertEquals(4, logic.getTaskList().size());
	}

	@Test // test edit time end
	public void testAT() {
		logic.run("delete all");
		logic.run("add new event from 30/5 4pm to 10pm");
		logic.run("edit 1 11pm end");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("End time edited from \'22:00\' to \'23:00\'.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		assertEquals(1, logic.getTaskList().size());
	}
	
	@Test // test edit time start
	public void testAU() {
		logic.run("edit 1 6pm start");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Start time edited from \'16:00\' to \'18:00\'.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		assertEquals(1, logic.getTaskList().size());
	}
	
	@Test // test failed help
	public void testAV() {
		logic.run("help blah blah");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Sorry, the topic you requested is not available");
		assertEquals(expectedOutput, logic.getOutput());
	}
	
	@Test // test edit interval
	public void testAW() {
		logic.run("delete all");
		logic.run("add event every saturday from 4pm to 6pm for 6 weeks");
		logic.run("edit 1 every sunday from 3pm to 5pm");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Start date edited from \'2016-04-16\' to \'2016-04-17\'. \nStart time edited from \'16:00\' to \'15:00\'. \nEnd date edited from \'2016-04-16\' to \'2016-04-17\'. \nEnd time edited from \'18:00\' to \'17:00\'. \nInterval edited.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		assertEquals(1, logic.getTaskList().size());
	}
	
	@Test // delete all occurrences
	public void testAX() {
		logic.run("delete all 1");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("All occurrences of task \'event\' deleted.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(0, logic.getLastOutputTaskList().size());
		assertEquals(0, logic.getTaskList().size());
	}
	
	@Test // add overdue deadline
	public void testAY() {
		logic.run("add deadline by today 0000hrs");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Task added: deadline. Task added is overdue.");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		assertEquals(1, logic.getTaskList().size());
	}
	
	@Test // add clashing event
	public void testAZ() {
		logic.run("delete all");
		logic.run("add event 1 from today 0000hrs to 0040hrs");
		logic.run("add event 2 from today 0000hrs to 0040hrs");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Task added: event 2. Task added is overdue.\nTask: event 2 clashes with event 1. ");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(2, logic.getLastOutputTaskList().size());
		assertEquals(2, logic.getTaskList().size());
	}
	
	@Test // test incomplete
	public void testBA() {
		logic.run("delete all");
		logic.run("add deadline by 6 june");
		logic.run("done 1");
		logic.run("incomplete 1");
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Task: \'deadline\' is marked as incomplete");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(1, logic.getLastOutputTaskList().size());
		assertEquals(1, logic.getTaskList().size());
	}
	
	@Test // test save as and load from
	public void testBB() {
		Path path = Paths.get(".\\atf_files");
		String directory = path.toString();
		logic.run("save as " + directory);
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Tasks have been saved to " + directory);
		assertEquals(expectedOutput, logic.getOutput());
		
		logic.run("load from" + directory + "\\filecopy.txt.txt");
		expectedOutput.clear();
		expectedOutput.add("Loaded file from:\n" + directory + "\\filecopy.txt.txt");
	}
	
	@Test // test save to
	public void testBC() {
		Path path = Paths.get(".\\atf_files");
		String directory = path.toString();
		logic.run("save to " + directory);
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Tasks have been, and will continue to be saved to " + directory);
		assertEquals(expectedOutput, logic.getOutput());
		
		// to use original working directory again
		path = Paths.get(".");
		directory = path.toString();
		logic.run(directory);
	}
	
	@Test // failed save to
	public void testBD() {
		Path path = Paths.get("\\atk_files");
		String directory = path.toString();
		logic.run("save to " + directory);
		
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Error saving file to " + directory);
		assertEquals(expectedOutput, logic.getOutput());
	}
	
	@Test // failed load
	public void testZZ() {
		logic.run("load from blahblahblah");
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		expectedOutput.add("Invalid file path used");
		assertEquals(expectedOutput, logic.getOutput());
		assertEquals(0, logic.getLastOutputTaskList().size());
		assertEquals(0, logic.getTaskList().size());
	}
}
```
###### \src\logic\mark\Done.java
``` java

package logic.mark;

import java.util.ArrayList;
import java.util.logging.*;

import common.CommandObject;
import common.TaskObject;
import logic.Recurring;
import logic.exceptions.MarkException;
import logic.exceptions.RecurrenceException;

import static logic.constants.Strings.*;

/**
 * Creates a Done object, which is a Mark object. However, it specifically changes the status of the target
 * task to "done".
 * 
 * @author ChongYan
 *
 */
public class Done extends Mark {

	/**
	 * Constuctor for a Done object.
	 * 
	 * @param commandObj
	 *            - Contains information on the task to be changed, not the task to be changed
	 * @param taskList
	 *            - Contains all existing tasks in Adult TaskFinder
	 * @param lastOutputTaskList
	 *            - Contains the list of tasks which was last outputted
	 */
	public Done(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList) {
		this.index = commandObj.getIndex();
		this.markTaskObj = commandObj.getTaskObject();
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;

		logger.log(Level.INFO, "constructed Done object");
	}

	/**
	 * Main method of the Done class, which facilitates the toggling of a task's status to "completed", before
	 * setting an output of ArrayList <String> describing the changes made to that specific task. <br>
	 * If the task marked as completed is a recurring task, it will be handled differently and this will be
	 * dealt with by the methods in Recurring.
	 * 
	 * @return output: ArrayList<String>
	 */
	public ArrayList<String> run() {
		obtainTaskId();
		assert (taskIdToMark != -1);
		// Impossible to have a task ID of -1

		boolean isChanged = false;
		isChanged = changeStatus();
		if (isChanged) {
			saveToFile();
			createOutput();
			logger.log(Level.INFO, "marked task as completed");
		} else {
			createErrorOutput(MESSAGE_MARK_DONE_ERROR);
		}
		return output;
	}

	private void createOutput() {
		String text = String.format(MESSAGE_DONE, taskName);
		output.add(text);
	}

```
###### \src\logic\mark\Done.java
``` java

	// On top of this, consider implementation for event
	private void changeStatusForRecurringTask(TaskObject task) {
		if (task.getCategory().equals(CATEGORY_DEADLINE)) {
			logger.log(Level.INFO, "about to mark a recurring deadline as completed");
			changeStatusForRecurringDeadline(task);
		} else if (task.getCategory().equals(CATEGORY_EVENT)) {
			logger.log(Level.INFO, "about to mark a recurring event as completed");
			changeStatusForRecurringEvent(task);
		}
	}

	private void changeStatusForRecurringDeadline(TaskObject task) {
		try {
			Recurring.updateDeadline(task, taskList, STATUS_COMPLETED);
			// At the last recurrence, task will be set to be non-recurring
			if (task.getIsRecurring()) {
				int splitTaskId = findSplitTaskId();
				setMostRecentlyMarkedTaskId(splitTaskId);
			}
		} catch (RecurrenceException e) {
			String exceptionMessage = e.getRecurrenceExceptionMessage();
			createErrorOutput(exceptionMessage);
			isExceptionThrown = true;
		}
	}

	private void changeStatusForRecurringEvent(TaskObject task) {
		try {
			Recurring.updateEvent(task, taskList, STATUS_COMPLETED);
			// At the last recurrence, task will be set to non-recurring
			if (task.getIsRecurring()) {
				int splitTaskId = findSplitTaskId();
				setMostRecentlyMarkedTaskId(splitTaskId);
			}
		} catch (RecurrenceException e) {
			String exceptionMessage = e.getRecurrenceExceptionMessage();
			createErrorOutput(exceptionMessage);
			isExceptionThrown = true;
		}
	}

	private int findSplitTaskId() {
		int id = -1;
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() < id) {
				id = taskList.get(i).getTaskId();
			}
		}
		return id;
	}

}
```
###### \src\logic\mark\DoneTest.java
``` java

package logic.mark;

import static org.junit.Assert.*;
import org.junit.Test;
import org.junit.runners.MethodSorters;
import org.junit.FixMethodOrder;

import common.*;
import logic.*;
import logic.timeoutput.TimeOutput;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

import java.util.ArrayList;
import java.time.LocalDateTime;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class DoneTest {
	
	private final TaskObject taskOne = new TaskObject("Find calculator", "floating", "undone", 200);
	private final TaskObject taskTwo = new TaskObject("Find money", "floating", "undone", 3);
	private ArrayList<TaskObject> taskList = new ArrayList<TaskObject> ();
	private ArrayList<TaskObject> lastOutput = new ArrayList<TaskObject> ();

	@Test
	public void testA() {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		TaskObject taskTest = new TaskObject("1");
		CommandObject test = new CommandObject(INDEX_COMPLETE, taskTest, 1);
		taskList.add(taskOne);
		taskList.add(taskTwo);
		lastOutput.add(taskOne);
		Done doneTest = new Done(test, taskList, lastOutput);
		actualOutput = doneTest.run();
		expectedOutput.add("Task: 'Find calculator' marked as completed");
		assertEquals(expectedOutput, actualOutput);
	}
	
	/**
	 * Following tested: <br>
	 * 1. Recurring deadline with >1 remaining timing <br>
	 * 2. Recurring deadline with 1 remaining timing <br>
	 */
	 
	@Test
	// Recurrent deadline with multiple timings left
	public void testB() throws Exception {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		CommandObject test = new CommandObject(INDEX_COMPLETE, new TaskObject(), 3);
		TaskObject task = new TaskObject("deadline 1", LocalDateTime.of(2016, 4, 1, 23, 59), CATEGORY_DEADLINE, "incomplete", 2);
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.of(2016, 5, 13, 23, 59), "");
		LocalDateTimePair newPair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(newPair);
		task.setIsRecurring(true);
		task.setInterval(interval);
		Recurring.setAllRecurringDeadlineTimes(task);
		
		// sets up taskList and lastOutputTaskList
		taskList.add(taskOne);
		taskList.add(taskTwo);
		taskList.add(task);
		lastOutput.add(taskOne);
		lastOutput.add(taskTwo);
		lastOutput.add(task);
		
		Done done = new Done(test, taskList, lastOutput);
		actualOutput = done.run();
		
		// Recurrent task should continue to have incomplete status
		System.out.println(task.getStatus());
		assertTrue(task.getStatus().equals("incomplete"));
		
		expectedOutput.add("Task: 'deadline 1' marked as completed");
		assertEquals(expectedOutput, actualOutput);
		
		// Number of tasks increase by 1
		System.out.println(taskList.size());
		assertTrue(taskList.size() == 4);
		
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() < 0) {
				System.out.println(taskList.get(i).getTitle());
				System.out.println(taskList.get(i).getStatus());
				System.out.println(taskList.get(i).getStartDateTime().toString());
			}
		}
	}
	
	@Test
	// Recurrent deadline with 1 timing left
	public void testC() throws Exception {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		CommandObject test = new CommandObject(INDEX_COMPLETE, new TaskObject(), 3);
		TaskObject task = new TaskObject("deadline 1", LocalDateTime.of(2016, 4, 1, 23, 59), CATEGORY_DEADLINE, "incomplete", 2);
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.of(2016, 4, 5, 23, 59), "");
		LocalDateTimePair newPair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(newPair);
		task.setIsRecurring(true);
		task.setInterval(interval);
		Recurring.setAllRecurringDeadlineTimes(task);
		
		// sets up taskList and lastOutputTaskList
		taskList.add(taskOne);
		taskList.add(taskTwo);
		taskList.add(task);
		lastOutput.add(taskOne);
		lastOutput.add(taskTwo);
		lastOutput.add(task);
		
		Done done = new Done(test, taskList, lastOutput);
		actualOutput = done.run();
		
		// Recurrent task with 1 timing left should have completed status
		System.out.println(task.getStatus());
		assertTrue(task.getStatus().equals("completed"));
		
		expectedOutput.add("Task: 'deadline 1' marked as completed");
		assertEquals(expectedOutput, actualOutput);
		
		// No increase in number of tasks
		System.out.println(taskList.size());
		assertTrue(taskList.size() == 3);
		
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() < 0) {
				System.out.println(taskList.get(i).getTitle());
				System.out.println(taskList.get(i).getStatus());
				System.out.println(taskList.get(i).getStartDateTime().toString());
			}
		}
	}
	
	@Test
	// Infinite recurring deadline
	public void testD() throws Exception {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		CommandObject test = new CommandObject(INDEX_COMPLETE, new TaskObject(), 3);
		TaskObject task = new TaskObject("deadline 1", LocalDateTime.of(2016, 4, 1, 23, 59), CATEGORY_DEADLINE, "incomplete", 2);
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.MAX, "");
		LocalDateTimePair newPair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(newPair);
		task.setIsRecurring(true);
		task.setInterval(interval);
		Recurring.setAllRecurringDeadlineTimes(task);
		
		// sets up taskList and lastOutputTaskList
		taskList.add(taskOne);
		taskList.add(taskTwo);
		taskList.add(task);
		lastOutput.add(taskOne);
		lastOutput.add(taskTwo);
		lastOutput.add(task);
		
		Done done = new Done(test, taskList, lastOutput);
		actualOutput = done.run();
		
		// Infinite recurring task should always have incomplete status
		System.out.println(task.getStatus());
		assertTrue(task.getStatus().equals("incomplete"));
		
		expectedOutput.add("Task: 'deadline 1' marked as completed");
		assertEquals(expectedOutput, actualOutput);
		
		// Increase in number of tasks by 1
		System.out.println(taskList.size());
		assertTrue(taskList.size() == 4);
		
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() < 0) {
				System.out.println(taskList.get(i).getTitle());
				System.out.println(taskList.get(i).getStatus());
				System.out.println(taskList.get(i).getStartDateTime().toString());
			}
		}
		
		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setDeadlineTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime());
			System.out.println(line);
		}
	}
	
	@Test
	// Recurring event with multiple timings
	public void testE() throws Exception {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		CommandObject test = new CommandObject(INDEX_COMPLETE, new TaskObject(), 3);
		TaskObject task = new TaskObject("event 1", LocalDateTime.of(2016, 4, 13, 23, 59), LocalDateTime.of(2016, 4, 14, 01, 59), CATEGORY_EVENT, "incomplete", 2);
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.of(2016, 6, 13, 23, 59), "");
		LocalDateTimePair newPair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(newPair);
		task.setIsRecurring(true);
		task.setInterval(interval);
		Recurring.setAllRecurringEventTimes(task);
		int originalTimingCount = task.getTaskDateTimes().size();
		
		// sets up taskList and lastOutputTaskList
		taskList.add(taskOne);
		taskList.add(taskTwo);
		taskList.add(task);
		lastOutput.add(taskOne);
		lastOutput.add(taskTwo);
		lastOutput.add(task);
		
		Done done = new Done(test, taskList, lastOutput);
		actualOutput = done.run();
		int newTimingCount = task.getTaskDateTimes().size();
		
		// Number of timings in the task should decrease by 1
		assertEquals (newTimingCount + 1, originalTimingCount);
		
		// Number of tasks should increase by 1
		assertEquals (4, taskList.size());
		
		// Recurring task with >1 timings should always have incomplete status
		System.out.println(task.getStatus());
		assertTrue(task.getStatus().equals("incomplete"));
		
		expectedOutput.add("Task: 'event 1' marked as completed");
		assertEquals(expectedOutput, actualOutput);
		
		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(), task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
		
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() < 0) {
				System.out.println(taskList.get(i).getTimeOutputString());
				System.out.println(taskList.get(i).getStatus());
				System.out.println(taskList.get(i).getTaskId());
			}
		}
	}
	
	@Test
	// Recurring event with 1 timing left
	public void testF() throws Exception {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		CommandObject test = new CommandObject(INDEX_COMPLETE, new TaskObject(), 3);
		TaskObject task = new TaskObject("event 1", LocalDateTime.of(2016, 4, 13, 23, 59), LocalDateTime.of(2016, 4, 14, 01, 59), CATEGORY_EVENT, "incomplete", 2);
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.of(2016, 4, 13, 23, 59), "");
		LocalDateTimePair newPair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(newPair);
		task.setIsRecurring(true);
		task.setInterval(interval);
		Recurring.setAllRecurringEventTimes(task);
		int originalTimingCount = task.getTaskDateTimes().size();
		
		// sets up taskList and lastOutputTaskList
		taskList.add(taskOne);
		taskList.add(taskTwo);
		taskList.add(task);
		lastOutput.add(taskOne);
		lastOutput.add(taskTwo);
		lastOutput.add(task);
		
		Done done = new Done(test, taskList, lastOutput);
		actualOutput = done.run();
		int newTimingCount = task.getTaskDateTimes().size();
		
		// Number of timings in the task should not change
		assertTrue (newTimingCount == originalTimingCount);
		
		// Recurring event with 1 timing left should be set to completed
		System.out.println(task.getStatus());
		assertTrue(task.getStatus().equals("completed"));
		
		expectedOutput.add("Task: 'event 1' marked as completed");
		assertEquals(expectedOutput, actualOutput);
		
		// No change in number of tasks
		System.out.println(taskList.size());
		assertTrue(taskList.size() == 3);
		
		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(), task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}
	
	@Test
	// Infinite recurring event 
	public void testG() throws Exception {
		ArrayList<String> expectedOutput = new ArrayList<String> ();
		ArrayList<String> actualOutput = new ArrayList<String> ();
		CommandObject test = new CommandObject(INDEX_COMPLETE, new TaskObject(), 3);
		TaskObject task = new TaskObject("event 1", LocalDateTime.of(2016, 4, 13, 23, 59), LocalDateTime.of(2016, 4, 14, 01, 59), CATEGORY_EVENT, "incomplete", 2);
		Interval interval = new Interval("WEEKLY", 2, LocalDateTime.MAX, "");
		LocalDateTimePair newPair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(newPair);
		task.setIsRecurring(true);
		task.setInterval(interval);
		Recurring.setAllRecurringEventTimes(task);
		int originalTimingCount = task.getTaskDateTimes().size();
		
		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(), task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
		
		// sets up taskList and lastOutputTaskList
		taskList.add(taskOne);
		taskList.add(taskTwo);
		taskList.add(task);
		lastOutput.add(taskOne);
		lastOutput.add(taskTwo);
		lastOutput.add(task);
		
		Done done = new Done(test, taskList, lastOutput);
		actualOutput = done.run();
		int newTimingCount = task.getTaskDateTimes().size();
		
		// Number of timings in the task should be 10
		assertTrue (newTimingCount == originalTimingCount);
		assertTrue (newTimingCount == 10);
		
		// Infinitely recurring event cannot be completed
		System.out.println(task.getStatus());
		assertTrue(task.getStatus().equals("incomplete"));
		
		expectedOutput.add("Task: 'event 1' marked as completed");
		assertEquals(expectedOutput, actualOutput);
		
		// Number of tasks increase by 1
		System.out.println(taskList.size());
		assertTrue(taskList.size() == 4);
		
		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(), task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}
}
```
###### \src\logic\mark\Incomplete.java
``` java

package logic.mark;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.logging.Level;

import common.CommandObject;
import common.TaskObject;

import static logic.constants.Strings.*;

/**
 * Child class of Mark, main purpose is to support Logic in the marking of a task as incomplete. Obtains the
 * desired task ID through the index parsed from user input, before proceeding to mark that particular task
 * with the status "incomplete".
 * 
 * @author ChongYan
 *
 */
public class Incomplete extends Mark {

	public Incomplete(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList) {
		this.index = commandObj.getIndex();
		this.markTaskObj = commandObj.getTaskObject();
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;
	}

	/**
	 * The main processor called by CommandFacade to mark a task as "incomplete". Obtains the desired task ID,
	 * changes the status internally before saving it to the external storage.
	 * 
	 * @return ArrayList<String> containing output showed to the user
	 */
	public ArrayList<String> run() {
		obtainTaskId();
		assert (taskIdToMark != -1);

		boolean isChanged = false;
		isChanged = changeStatus();
		if (isChanged) {
			saveToFile();
			logger.log(Level.INFO, "marked task as incomplete");
		} else {
			createErrorOutput(MESSAGE_MARK_INCOMPLETE_ERROR);
		}
		return output;
	}

```
###### \src\logic\mark\Mark.java
``` java

package logic.mark;

import logic.exceptions.MarkException;
import storage.FileStorage;
import storage.IStorage;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.util.ArrayList;
import java.util.logging.*;

import common.AtfLogger;
import common.CommandObject;
import common.LocalDateTimePair;
import common.TaskObject;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

/**
 * An abstract class. Inherited by Done, Incomplete and Overdue. This set of
 * classes serve to facilitate switching the status of a selected task between
 * three set statuses - "done", "incomplete" and "overdue". <br>
 * Precondition: This command should be preceded by a command such as "display"
 * or "search", which will generate a list of tasks for the user to manipulate.
 * Class methods will not work if the last output task list is invalid. <br>
 * Contains the abstract run() method which will be overridden by each
 * subclasses's implementation.
 * 
 * @author ChongYan
 *
 */
public abstract class Mark {

	protected static Logger logger = AtfLogger.getLogger();

	/**
	 * @param TaskObject
	 *            instructionTask - This is the TaskObject which contains
	 *            information on which task's status to be modified.
	 * @param TaskObject
	 *            markedTask - This is a copy of the TaskObject which is
	 *            modified by this specific Mark object. Will be added to the
	 *            undo/redo list whichever is applicable.
	 * @param String
	 *            taskName - This contains the name of the task which was
	 *            modified
	 * @param String
	 *            statusBeforeChange - This contains the status of the task
	 *            before it was toggled by Mark.run()
	 * @param taskIdToMark
	 *            - Contains the task ID of the task whose status will be
	 *            toggled
	 */

	protected TaskObject originalTask = new TaskObject(); // original task info for undo purposes
	protected ArrayList<LocalDateTimePair> originalTimings = new ArrayList<LocalDateTimePair>();

	protected TaskObject markedTask;
	protected String taskName = "";
	protected String statusBeforeChange = "";
	protected ArrayList<TaskObject> taskList;
	protected ArrayList<TaskObject> lastOutputTaskList;
	protected ArrayList<String> output = new ArrayList<String>();
	protected int taskIdToMark = -1; // The intended task ID user wants to mark
	protected int mostRecentlyMarkedTaskId = -1; 
	// The task ID of the task most recently marked complete, which is split task for recurring
	protected int command;

	protected TaskObject markTaskObj = new TaskObject();
	protected int index = -1;
	protected boolean isExceptionThrown = false;

	public Mark() {

	}

	/**
	 * Generic constructor for all subclasses of Mark to be used.
	 * 
	 * @param taskObj
	 *            - Contains information on the task to be changed, not the task to be changed
	 * @param taskList
	 *            - Contains all existing tasks in Adult TaskFinder
	 * @param lastOutputTaskList
	 *            - Contains the list of tasks which was last output
	 */
	public Mark(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList) {
		this.index = commandObj.getIndex();
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;
		this.command = commandObj.getCommandType();
	}

	public abstract ArrayList<String> run();

	// May need to change if parser changes the way this command object is constructed
	protected void obtainTaskId() {
		index--;
		if (index >= 0 && index < lastOutputTaskList.size()) {
			taskIdToMark = lastOutputTaskList.get(index).getTaskId();
			logger.log(Level.INFO, "valid task ID obtained");
		} else {
			processError();
			logger.log(Level.WARNING, "invalid task ID obtained");
		}
	}
	
	private void processError() {
		if (command == INDEX_COMPLETE) {
			createErrorOutput(MESSAGE_MARK_DONE_ERROR);
		} else if (command == INDEX_INCOMPLETE) {
			createErrorOutput(MESSAGE_MARK_INCOMPLETE_ERROR);
		}
	}

	protected void checkCurrentStatus(String status) throws MarkException {
		if (markedTask.getStatus().equals(status)) {
			MarkException e = new MarkException(markedTask);
			throw e;
		}
	}

	protected void saveToFile() {
		IStorage storage = FileStorage.getInstance();
		try {
			storage.save(taskList);
			logger.log(Level.INFO, "successfully saved changes to external file");
		} catch (NoSuchFileException e) {
			e.printStackTrace();
			createErrorOutput(String.format(MESSAGE_SAVE_ERROR, "default location"));
			logger.log(Level.WARNING, "unable to save changes to external file");
		} catch (IOException e) {
			e.printStackTrace();
			createErrorOutput(String.format(MESSAGE_SAVE_ERROR, "default location"));
			logger.log(Level.WARNING, "unable to save changes to external file");
		}
	}

	protected abstract boolean changeStatus();

	protected void createErrorOutput(String errorMessage) {
		if (output.isEmpty()) {
			output.add(errorMessage);
		}
	}

	protected void deleteSplitTaskFromTaskList() {
		int smallestTaskId = 0;
		int indexOfTaskToDelete = -1;

		for (int i = 0; i < taskList.size(); i++) {
			int taskId = taskList.get(i).getTaskId();
			if (taskId < 0 && taskId < smallestTaskId) {
				smallestTaskId = taskId;
				indexOfTaskToDelete = i;
			}
		}

		taskList.remove(indexOfTaskToDelete);
		logger.log(Level.INFO, "deleted split task from task list");
	}

	// ---------------------------- GETTERS AND SETTERS ---------------------------- 
	
	public int getTaskIdToMark() {
		return taskIdToMark;
	}

	public String getStatusToChange() {
		return statusBeforeChange;
	}

	public TaskObject getMarkedTask() {
		return markedTask;
	}

	public TaskObject getOriginalTask() {
		return originalTask;
	}
	
	public int getMostRecentlyMarkedTaskId() {
		return mostRecentlyMarkedTaskId;
	}

	public int getMarkIndex() {
		return index;
	}

	public boolean getIsExceptionThrown() {
		return isExceptionThrown;
	}
	
	public void setMarkIndex(int index) {
		this.index = index;
	}
	
	public void setMostRecentlyMarkedTaskId(int mostRecentlyMarkedTaskId) {
		this.mostRecentlyMarkedTaskId = mostRecentlyMarkedTaskId;
	}
}
```
###### \src\logic\mark\Overdue.java
``` java

package logic.mark;

import java.util.ArrayList;
import java.util.logging.Level;
import java.time.LocalDateTime;

import common.CommandObject;
import common.TaskObject;

import static logic.constants.Strings.*;

public class Overdue extends Mark {

	public Overdue(CommandObject commandObj, ArrayList<TaskObject> taskList,
			ArrayList<TaskObject> lastOutputTaskList) {
		this.index = commandObj.getIndex();
		this.taskList = taskList;
		this.lastOutputTaskList = lastOutputTaskList;
	}

	public ArrayList<String> run() {
		obtainTaskId();
		boolean isChanged = false;
		isChanged = changeStatus();
		if (isChanged) {
			saveToFile();
			createOutput();
		} else {
			createErrorOutput(MESSAGE_MARK_OVERDUE_ERROR);
		}
		return output;
	}

	@Override
	protected boolean changeStatus() {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == taskIdToMark) {
				taskName = taskList.get(i).getTitle();
				statusBeforeChange = taskList.get(i).getStatus();
				taskList.get(i).setStatus(STATUS_OVERDUE);

				logger.log(Level.INFO, "Status changed to \'overdue\'");
				return true;
			}
		}
		return false;
	}

	private void createOutput() {
		String text = String.format(MESSAGE_OVERDUE, taskName);
		output.add(text);
	}

	/*******************************************************************************/

	/**
	 * Checks and marks all overdue tasks in the task list, called by Logic when a Logic object is first
	 * constructed.
	 * 
	 * @param taskList
	 *            stores all tasks
	 */
	public static void markAllOverdueTasks(ArrayList<TaskObject> taskList) {
		boolean isOverdue = false;
		for (int i = 0; i < taskList.size(); i++) {
			// only for non-recurring tasks, recurring tasks have their own
			// dedicated methods
			if (!taskList.get(i).getIsRecurring()) {
				if (taskList.get(i).getCategory().equals(CATEGORY_DEADLINE) || taskList.get(i).getCategory().equals(CATEGORY_EVENT)) {
					if (!taskList.get(i).getStatus().equals(STATUS_COMPLETED)) {
						isOverdue = performCheckOverdue(taskList.get(i));
						if (isOverdue) {
							taskList.get(i).setStatus(STATUS_OVERDUE);
							logger.log(Level.INFO, "set status of non-recurring task to overdue");
						}
					}
				}
			}
		}
	}

	private static boolean performCheckOverdue(TaskObject task) {
		LocalDateTime startDateTime = task.getStartDateTime();
		assert (!startDateTime.isEqual(LocalDateTime.MAX));

		if (startDateTime.isBefore(LocalDateTime.now())) {
			return true;
		}
		return false;
	}
}
```
###### \src\logic\Recurring.java
``` java

package logic;

import common.*;
import logic.add.Add;
import logic.exceptions.RecurrenceException;
import logic.timeoutput.TimeOutput;

import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.time.DayOfWeek;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.TemporalAdjusters;

import static logic.constants.Index.*;
import static logic.constants.Strings.*;

/**
 * This class deals with the adding and updating of recurring task timings. It is called by various classes
 * such as Logic, Add, Done and Edit.
 * 
 * @author ChongYan
 *
 */

public class Recurring {

	private static Logger logger = AtfLogger.getLogger();

	// ==================================================================
	// First Level of Abstraction
	// ==================================================================

	/**
	 * Method called by Add or Edit. <br>
	 * When a new recurring event is initially added, Add calls this method to generate a series of
	 * recurrences for this event. <br>
	 * When a recurring event is edited, Edit calls this method to generate the new timings for the event.
	 * 
	 * @param task
	 *            TaskObject for addition of all recurring timings
	 */
	public static void setAllRecurringEventTimes(TaskObject task) throws RecurrenceException {
		assert task.getCategory().equals(CATEGORY_EVENT);
		logger.log(Level.INFO, "About to set all recurring times for event: " + task.getTitle());

		Interval interval = task.getInterval();
		LocalDateTimePair eventDateTime = task.getTaskDateTimes().get(0);

		// in case there is an existing list and the interval is changed
		task.removeAllDateTimes();

		if (!interval.getUntil().equals(LocalDateTime.MAX)) {
			setTimingsBasedOnUntil(task, eventDateTime, interval);
		} else if (interval.getCount() != -1) {
			setTimingsBasedOnCounts(task, eventDateTime, interval, interval.getCount());
		} else {
			setTimingsBasedOnCounts(task, eventDateTime, interval, RECURRENCE_CONSTANT_COUNT);
		}

		// In case of funny recurrences where no timings get added
		if (task.getTaskDateTimes().isEmpty()) {
			task.addToTaskDateTimes(eventDateTime);
		}
	}

	/**
	 * Method called by Add or Edit. <br>
	 * When a new recurring deadline is initially added, Add calls this method to generate a series of
	 * recurrences for this deadline. <br>
	 * When a recurring deadline is edited, Edit calls this method to generate the new timings for the
	 * deadline.
	 * 
	 * @param task
	 *            TaskObject for addition of all recurring timings
	 */
	public static void setAllRecurringDeadlineTimes(TaskObject task) throws RecurrenceException {
		assert task.getCategory().equals(CATEGORY_DEADLINE);

		Interval interval = task.getInterval();
		LocalDateTimePair deadlineDateTime = task.getTaskDateTimes().get(0);

		task.removeAllDateTimes();

		if (!interval.getUntil().isEqual(LocalDateTime.MAX)) {
			setTimingsBasedOnUntil(task, deadlineDateTime, interval);
		} else if (interval.getCount() != -1) {
			setTimingsBasedOnCounts(task, deadlineDateTime, interval, interval.getCount());
		} else {
			setTimingsBasedOnCounts(task, deadlineDateTime, interval, RECURRENCE_CONSTANT_COUNT);
		}

		// In case of funny recurrences where no timings get added
		if (task.getTaskDateTimes().isEmpty()) {
			task.addToTaskDateTimes(deadlineDateTime);
		}

		logger.log(Level.INFO, "successfully created all recurring timings for deadline");
	}
	/**
	 * Method called by logic when AdultTaskFinder is launched. Searches for all recurring events and passes
	 * it to updateEvent to determine if the recurring event has to be updated, and updates the event if
	 * necessary.
	 * 
	 * @param taskList
	 *            List of tasks stored by AdultTaskFinder.
	 * @throws RecurrenceException
	 *             Customised exception called when there is a fault performing any recurrence related
	 *             command.
	 */
	public static void updateRecurringEvents(ArrayList<TaskObject> taskList) throws RecurrenceException {
		logger.log(Level.INFO, "about to update all recurring events");
		for (int i = 0; i < taskList.size(); i++) {
			checkForAndProcessRecurringEvents(taskList.get(i), taskList);
		}
	}
	
	/**
	 * Method called by logic when AdultTaskFinder is launched. Searches for all recurring deadlines and
	 * passes it to updateDeadline to determine if the recurring deadline has to be updated, and updates the
	 * deadline if necessary
	 * 
	 * @param taskList
	 *            List of tasks stored by AdultTaskFinder
	 */
	public static void updateRecurringDeadlines(ArrayList<TaskObject> taskList) throws RecurrenceException {
		for (int i = 0; i < taskList.size(); i++) {
			checkForAndProcessRecurringDeadlines(taskList.get(i), taskList);
		}
	}

	// ==================================================================
	// Second Level of Abstraction
	// ==================================================================
	
	private static void checkForAndProcessRecurringEvents(TaskObject task, ArrayList<TaskObject> taskList)
			throws RecurrenceException {
		if (task.getIsRecurring() && task.getCategory().equals(CATEGORY_EVENT)) {
			updateEvent(task, taskList, STATUS_OVERDUE);
			logger.log(Level.INFO, "about to update recurring event:" + task.getTitle());
		}
	}

	private static void checkForAndProcessRecurringDeadlines(TaskObject task, ArrayList<TaskObject> taskList)
			throws RecurrenceException {
		if (task.getIsRecurring() && task.getCategory().equals(CATEGORY_DEADLINE)) {
			updateDeadline(task, taskList, STATUS_OVERDUE);
			logger.log(Level.INFO, "about to update recurring deadline:" + task.getTitle());
		}
	}

	// ==================================================================
	// Third Level of Abstraction
	// ==================================================================
	
	/**
	 * Method called by updateRecurringEvents or a Done object to update an event to the desired status
	 * (either completed or overdue). Exception is thrown if the desired status is invalid. <br>
	 * 
	 * @param task
	 *            TaskObject to be updated.
	 * @param taskList
	 *            Stores all the tasks the user has.
	 * @param status
	 *            The desired status for updating. Can only be either "overdue" or "completed".
	 */
	public static void updateEvent(TaskObject task, ArrayList<TaskObject> taskList, String status)
			throws RecurrenceException {
		if (status.equals(STATUS_OVERDUE)) {
			updateEventToOverdue(task, taskList, status);
			logger.log(Level.INFO, "updated status of event " + task.getTitle() + " to " + status);
		} else if (status.equals(STATUS_COMPLETED)) {
			updateEventToCompleted(task, taskList, status);
			logger.log(Level.INFO, "updated status of event " + task.getTitle() + " to " + status);
		} else {
			logger.log(Level.WARNING, "unable to update status of event");
			RecurrenceException e = new RecurrenceException(MESSAGE_RECURRENCE_EXCEPTION_INVALID_STATUS);
			throw e;
		}
	}

	/**
	 * Method called by updateRecurringDeadlines or a Done object to update a deadline to the desired status
	 * (either completed or overdue). Exception is thrown if the desired status is invalid. <br>
	 * 
	 * @param task
	 *            TaskObject to be updated
	 * @param taskList
	 *            Stores all the tasks the user has
	 * @param status
	 *            The desired status for updating. Can only be either "overdue" or "completed"
	 */
	public static void updateDeadline(TaskObject task, ArrayList<TaskObject> taskList, String status)
			throws RecurrenceException {
		if (status.equals(STATUS_OVERDUE)) {
			updateDeadlineToOverdue(task, taskList, status);
		} else if (status.equals(STATUS_COMPLETED)) {
			updateDeadlineToCompleted(task, taskList, status);
		} else {
			logger.log(Level.WARNING, "unable to update status of deadline");
			RecurrenceException e = new RecurrenceException(MESSAGE_RECURRENCE_EXCEPTION_INVALID_STATUS);
			throw e;
		}
		logger.log(Level.INFO, "updated status of deadline " + task.getTitle() + " to " + status);
	}
	
	// ==================================================================
	// Fourth Level of Abstraction
	// ==================================================================
	/**
	 * Main method being called when updating a recurring event's status to overdue. Processes according to
	 * whether: <br>
	 * 1. There is >1 timing left in the recurring task, or <br>
	 * 2. There is only 1 timing left in the recurring task. <br>
	 * With >1 timing left, it will continually split the recurring task until the recurring task is no longer
	 * overdue. If there is only one timing left, another method will be called. This method will change the
	 * status of the task directly to overdue, and sets the isRecurring variable to false. The software will
	 * no longer recognise the task as a recurring task.
	 * 
	 * @param task
	 *            Recurring TaskObject which will be checked for overdue timings.
	 * @param taskList
	 *            ArrayList<TaskObject> which stores all the tasks. To add split event inside.
	 * @param status
	 *            String storing the value "overdue".
	 * @throws RecurrenceException
	 *             thrown when there are no timings left in taskDateTimes, which should not occur normally.
	 */
	private static void updateEventToOverdue(TaskObject task, ArrayList<TaskObject> taskList, String status)
			throws RecurrenceException {
		// Prevent IndexOutOfBoundsException
		if (task.getTaskDateTimes().isEmpty()) {
			RecurrenceException e = new RecurrenceException(task);
			throw e;
		}

		LocalDateTimePair eventTimePair = task.getTaskDateTimes().get(0);
		LocalDateTime eventEndTime = eventTimePair.getEndDateTime();
		LocalDateTime eventStartTime = eventTimePair.getStartDateTime();

		String taskName = task.getTitle();

		assert (!eventEndTime.equals(LocalDateTime.MAX));

		// While there are multiple timings left and the first timing in the list is overdue
		while (LocalDateTime.now().isAfter(eventEndTime) && task.getTaskDateTimes().size() > 1) {
			splitTaskFromRecurringEvent(taskName, eventStartTime, eventEndTime, taskList, status);
			renewEvent(task);
			eventEndTime = task.getEndDateTime();
			eventStartTime = task.getStartDateTime();
			logger.log(Level.INFO,
					"Modified recurring event to next set of timings, and split current overdue event");
		}

		// If there is only one timing left in the recurring event
		if (task.getTaskDateTimes().size() <= 1) {
			if (LocalDateTime.now().isAfter(eventEndTime)) {
				handleChangeInStatusForOneOccurrence(task, status);
			}
		}
	}

	/**
	 * Main method being called when updating a recurring task's status to completed. First checks that there
	 * are timings left in the list of dates and times stored by the task, after which, it processes the task
	 * according to whether: <br>
	 * 1. There is >1 timing left in the recurring task, or <br>
	 * 2. There is only 1 timing left in the recurring task. <br>
	 * If there are multiple tasks left, the recurring task will be split into a completed task and an
	 * incomplete task, and the completed task will be added into taskList. <br>
	 * If there is only one timing left, another method will be called. This method will change the status of
	 * the task directly to overdue, and sets the isRecurring variable to false. The software will no longer
	 * recognise the task as a recurring task.
	 * 
	 * @param task
	 *            TaskObject to be marked as completed.
	 * @param taskList
	 *            ArrayList<TaskObject> stored. To add split Event.
	 * @param status
	 *            String holding the value "completed".
	 * @throws RecurrenceException
	 *             thrown if taskDateTimes is empty, which should not occur.
	 */
	private static void updateEventToCompleted(TaskObject task, ArrayList<TaskObject> taskList, String status)
			throws RecurrenceException {
		// Prevent IndexOutOfBoundsException
		if (task.getTaskDateTimes().isEmpty()) {
			RecurrenceException e = new RecurrenceException(task);
			throw e;
		}

		LocalDateTimePair eventTimePair = task.getTaskDateTimes().get(0);
		LocalDateTime eventEndTime = eventTimePair.getEndDateTime();
		LocalDateTime eventStartTime = eventTimePair.getStartDateTime();
		String taskName = task.getTitle();

		if (task.getTaskDateTimes().size() == 1) {
			handleChangeInStatusForOneOccurrence(task, status);
		} else {
			splitTaskFromRecurringEvent(taskName, eventStartTime, eventEndTime, taskList, status);
			renewEvent(task);
			logger.log(Level.INFO,
					"Modified recurring event to next set of timings, and split current completed event");
		}
	}
	
	/**
	 * Main method being called when updating a recurring deadline's status to overdue. Processes according to
	 * whether: <br>
	 * 1. There is >1 timing left in the recurring task, or <br>
	 * 2. There is only 1 timing left in the recurring task. <br>
	 * With >1 timing left, it will continually split the recurring task until the recurring task is no longer
	 * overdue. If there is only one timing left, another method will be called. This method will change the
	 * status of the task directly to overdue, and sets the isRecurring variable to false. The software will
	 * no longer recognise the task as a recurring task.
	 * 
	 * @param task
	 *            Recurring TaskObject which will be checked for overdue timings.
	 * @param taskList
	 *            ArrayList<TaskObject> which stores all the tasks. To add split deadline inside.
	 * @param status
	 *            String storing the value "overdue".
	 * @throws RecurrenceException
	 *             thrown when there are no timings left in taskDateTimes, which should not occur normally.
	 */
	private static void updateDeadlineToOverdue(TaskObject task, ArrayList<TaskObject> taskList,
			String status) throws RecurrenceException {
		// Prevent IndexOutOfBoundsException
		if (task.getTaskDateTimes().isEmpty()) {
			RecurrenceException e = new RecurrenceException(task);
			throw e;
		}

		LocalDateTime deadlineDateTime = task.getTaskDateTimes().get(0).getStartDateTime();
		String taskName = task.getTitle();

		// Continually splits tasks until recurring task is no longer overdue
		// number of recurring times must also be more than 1
		while (LocalDateTime.now().isAfter(deadlineDateTime) && task.getTaskDateTimes().size() > 1) {
			splitTaskFromRecurringDeadline(deadlineDateTime, taskName, taskList, status);
			renewDeadline(task);
			deadlineDateTime = task.getStartDateTime();
			logger.log(Level.INFO, "updated recurring deadline");
		}

		// Special case for only 1 timing left
		if (task.getTaskDateTimes().size() == 1) {
			if (LocalDateTime.now().isAfter(deadlineDateTime)) {
				handleChangeInStatusForOneOccurrence(task, status);
			}
		}
	}

	/**
	 * Main method being called when updating a recurring deadline's status to completed. First checks that
	 * there are timings left in the list of dates and times stored by the task, after which, it processes the
	 * task according to whether: <br>
	 * 1. There is >1 timing left in the recurring task, or <br>
	 * 2. There is only 1 timing left in the recurring task. <br>
	 * If there are multiple tasks left, the recurring task will be split into a completed task and an
	 * incomplete task, and the completed task will be added into taskList. <br>
	 * If there is only one timing left, another method will be called. This method will change the status of
	 * the task directly to overdue, and sets the isRecurring variable to false. The software will no longer
	 * recognise the task as a recurring task.
	 * 
	 * @param task
	 *            TaskObject to be marked as completed.
	 * @param taskList
	 *            ArrayList<TaskObject> stored. To add split deadline.
	 * @param status
	 *            String holding the value "completed".
	 * @throws RecurrenceException
	 *             thrown if taskDateTimes is empty, which should not occur.
	 */
	private static void updateDeadlineToCompleted(TaskObject task, ArrayList<TaskObject> taskList,
			String status) throws RecurrenceException {
		// Prevent IndexOutOfBoundsException
		if (task.getTaskDateTimes().isEmpty()) {
			RecurrenceException e = new RecurrenceException(task);
			throw e;
		}

		LocalDateTime deadlineDateTime = task.getTaskDateTimes().get(0).getStartDateTime();
		String taskName = task.getTitle();

		if (task.getTaskDateTimes().size() == 1) {
			handleChangeInStatusForOneOccurrence(task, status);
		} else {
			splitTaskFromRecurringDeadline(deadlineDateTime, taskName, taskList, status);
			renewDeadline(task);
		}
	}

	// ======================================================================
	// Fifth Level of Abstraction
	// ======================================================================
	/**
	 * Creates a non-recurring task with a specified set of timings and the desired status. Added to taskList
	 * after that.
	 * 
	 * @param taskName
	 *            String containing the name of the task.
	 * @param startDateTime
	 *            LocalDateTime containing the start date and time of task.
	 * @param endDateTime
	 *            LocalDateTime containing the end date and time of task.
	 * @param taskList
	 *            ArrayList of TaskObjects containing all tasks stored in AdultTaskFinder.
	 * @param status
	 *            String containing the desired status of the split task.
	 */
	private static void splitTaskFromRecurringEvent(String taskName, LocalDateTime startDateTime,
			LocalDateTime endDateTime, ArrayList<TaskObject> taskList, String status) {
		int taskId = generateTaskId(taskList);

		assert (taskId < 0);
		assert (startDateTime.isBefore(endDateTime));

		TaskObject splitEvent = createSplitEventTaskObject(taskName, startDateTime, endDateTime, status,
				taskId);
		Add add = new Add(splitEvent, -1, taskList);
		add.run();

		logger.log(Level.INFO, "Added the split recurring event to task list");
	}
	
	/**
	 * Creates a non-recurring task with a specified set of timings and the desired status. Added to taskList
	 * after that.
	 * 
	 * @param deadline
	 *            LocalDateTime containing the due date of the event, stored in the TaskObject's
	 *            startDateTime.
	 * @param taskName
	 *            String containing the name of the task.
	 * @param taskList
	 *            ArrayList of TaskObjects containing all tasks in AdultTaskFinder.
	 * @param status
	 *            String containing the desired status of the split task.
	 */
	private static void splitTaskFromRecurringDeadline(LocalDateTime deadline, String taskName,
			ArrayList<TaskObject> taskList, String status) {
		int taskId = generateTaskId(taskList);
		TaskObject splitDeadline = createSplitDeadlineTaskObject(deadline, taskName, taskId, status);
		Add add = new Add(splitDeadline, -1, taskList);
		add.run();
		// adds the split deadline into the taskList
	}
	
	/**
	 * Removes the first set of timings in the list of timings stored by the recurring task, and updates the
	 * startDateTime and endDateTime variables to the next set of timings.
	 * 
	 * @param task
	 *            TaskObject which contains all information of the recurring task.
	 * @throws RecurrenceException
	 *             thrown if there are issues in the methods it calls, such as an invalid recurrence interval.
	 */
	private static void renewEvent(TaskObject task) throws RecurrenceException {
		LocalDateTime newStartDateTime;
		LocalDateTime newEndDateTime;
		LocalDateTimePair nextEvent;

		// For this method to be called, there must be at least 2 timings present
		assert (task.getTaskDateTimes().size() > 1);

		task.removeFromTaskDateTimes(0);

		nextEvent = task.getTaskDateTimes().get(0);
		newStartDateTime = nextEvent.getStartDateTime();
		newEndDateTime = nextEvent.getEndDateTime();

		task.setStartDateTime(newStartDateTime);
		task.setEndDateTime(newEndDateTime);
		logger.log(Level.INFO, "Set to next recurring date time: " + newStartDateTime.toString()
				+ newEndDateTime.toString());

		boolean isInfiniteRecurrence = checkIfInfiniteRecurrence(task.getInterval());
		if (isInfiniteRecurrence) {
			updateInfiniteRecurrence(task);
		}
	}
	
	/**
	 * Removes the first set of timings in the list of timings stored by the recurring task, and updates the
	 * startDateTime and endDateTime variables to the next set of timings.
	 * 
	 * @param task
	 *            TaskObject containing all information regarding the recurring deadline.
	 * @throws RecurrenceException
	 *             thrown when there are exceptions in the methods it calls, such as an invalid recurrence
	 *             interval.
	 */
	private static void renewDeadline(TaskObject task) throws RecurrenceException {
		LocalDateTime newStartDateTime;
		LocalDateTimePair nextDeadline;

		// To even use this method, at least 2 timings must be present in task
		assert (task.getTaskDateTimes().size() > 1);

		task.removeFromTaskDateTimes(0);
		nextDeadline = task.getTaskDateTimes().get(0);
		newStartDateTime = nextDeadline.getStartDateTime();
		task.setStartDateTime(newStartDateTime);

		logger.log(Level.INFO, "set the next deadline for recurring task");

		boolean isInfiniteRecurrence = checkIfInfiniteRecurrence(task.getInterval());
		if (isInfiniteRecurrence) {
			updateInfiniteRecurrence(task);
		}
	}


	// ======================================================================
	// Sixth Level of Abstraction
	// ======================================================================
	private static TaskObject createSplitEventTaskObject(String taskName, LocalDateTime startDateTime,
			LocalDateTime endDateTime, String status, int taskId) {
		TaskObject splitEvent = new TaskObject(taskName, startDateTime, endDateTime, CATEGORY_EVENT, status,
				taskId);
		splitEvent.setIsRecurring(false);
		splitEvent.addToTaskDateTimes(new LocalDateTimePair(startDateTime, endDateTime));
		TimeOutput.setEventTimeOutput(splitEvent);

		logger.log(Level.INFO, "Created a split event task object to be added");
		return splitEvent;
	}
	
	private static TaskObject createSplitDeadlineTaskObject(LocalDateTime deadline, String title, int taskId,
			String status) {
		TaskObject splitDeadline = new TaskObject(title, deadline, CATEGORY_DEADLINE, status, taskId);
		splitDeadline.setIsRecurring(false);
		splitDeadline.addToTaskDateTimes(new LocalDateTimePair(deadline));
		TimeOutput.setDeadlineTimeOutput(splitDeadline);
		return splitDeadline;
	}
	
	// ========================================================================
	// Lower Levels of Abstraction
	// ========================================================================

	// returns a negative number as taskID to prevent clashing with normal IDs
	private static int generateTaskId(ArrayList<TaskObject> taskList) {
		int id = -2;
		// -1 denotes error so set to -2 to prevent any unforeseen bugs
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() <= id) {
				id = taskList.get(i).getTaskId() - 1;
			}
		}
		return id;
	}

	/**
	 * Method which adds a new occurrence to the end of the recurring task's timings, if the recurring task is
	 * infinitely recurring.
	 * 
	 * @param task
	 *            TaskObject which is infinitely recurring.
	 * @throws RecurrenceException
	 *             thrown if there are problems generating the next recurrence in the methods it calls.
	 */
	public static void updateInfiniteRecurrence(TaskObject task) throws RecurrenceException {
		int index = task.getTaskDateTimes().size() - 1;
		LocalDateTimePair lastTimingInList = task.getTaskDateTimes().get(index);

		lastTimingInList = setNextTimePair(task.getInterval(), lastTimingInList);
		task.addToTaskDateTimes(lastTimingInList);
		logger.log(Level.INFO, "Inserted a new timing for infinite recurrence");
	}

	/**
	 * Method called by setAllRecurringDeadlineTimes and setAllRecurringEventTimes, if the recurrence is based
	 * on a specified end date.
	 * 
	 * @param task
	 *            TaskObject which is recurring.
	 * @param timePair
	 *            LocalDateTimePair variable containing the first set of timings.
	 * @param interval
	 *            Interval object containing information on the recurrence of the task.
	 * @throws RecurrenceException
	 *             thrown if there are problems generating the next sets of timings
	 */
	private static void setTimingsBasedOnUntil(TaskObject task, LocalDateTimePair timePair, Interval interval)
			throws RecurrenceException {
		// In event that local time has been modified to non-max but local date is still max
		if (!interval.getUntil().toLocalDate().equals(LocalDate.MAX)) {
			while (!timePair.getStartDateTime().isAfter(interval.getUntil())) {
				// not after == before and equal
				task.addToTaskDateTimes(timePair);
				timePair = setNextTimePair(interval, timePair);
			}
			logger.log(Level.INFO, "Added recurring times till specified end date");
		} else {
			RecurrenceException e = new RecurrenceException(task.getInterval().getUntil());
			throw e;
		}
	}

	/**
	 * Method called by setAllRecurringDeadlines and setAllRecurringEvents, if the recurrence is based on a
	 * specific number of counts, or is infinitely recurring.
	 * 
	 * @param task
	 *            TaskObject which is recurring
	 * @param timePair
	 *            LocalDateTimePair containing the first occurrence of the task.
	 * @param interval
	 *            Interval object containing the specified recurrences of the task.
	 * @param count
	 *            int containing the desired number of recurrences. Set to a default constant if it is
	 *            infinitely recurring.
	 * @throws RecurrenceException
	 *             thrown if there are problems generating the next recurring times.
	 */
	private static void setTimingsBasedOnCounts(TaskObject task, LocalDateTimePair timePair,
			Interval interval, int count) throws RecurrenceException {
		int[] byDayArray = interval.getByDayArray();

		if (byDayArray[0] == 1) {
			if (count != -1) {
				// Updates the number of counts to reflect effects of byDay
				int countMultiplier = retrieveMultiplier(byDayArray);
				count = count * countMultiplier;
			}
		}
		for (int i = 0; i < count; i++) {
			task.addToTaskDateTimes(timePair);
			timePair = setNextTimePair(interval, timePair);
		}
		logger.log(Level.INFO, "Added recurring times for specified number of counts");
	}

	private static int retrieveMultiplier(int[] byDayArray) {
		int countMultiplier = 0;
		for (int i = 1; i <= 7; i++) {
			if (byDayArray[i] == 1) {
				countMultiplier++;
			}
		}
		return countMultiplier;
	}

	private static LocalDateTimePair setNextTimePair(Interval interval, LocalDateTimePair timePair)
			throws RecurrenceException {
		LocalDateTime startDateTime = timePair.getStartDateTime();
		LocalDateTime endDateTime = timePair.getEndDateTime();
		LocalDateTimePair nextTimePair = new LocalDateTimePair();

		int[] byDayArray = interval.getByDayArray();

		if (byDayArray[0] == 0) {
			nextTimePair = obtainNextTime(interval, startDateTime, endDateTime);
		} else {
			// implementation with byDay
			nextTimePair = obtainNextTimeByDay(interval, startDateTime, endDateTime);
		}

		return nextTimePair;
	}

	/**
	 * Adds the time interval between recurrences to the current start date time and end date time, forming
	 * the next set of timings for the next occurrence.
	 * 
	 * @param interval
	 *            Interval object which contains the details of the recurrence
	 * @param startDateTime
	 *            LocalDateTime which indicates the current startDateTime
	 * @param endDateTime
	 *            LocalDateTime which indicates the current endDateTime
	 * @return LocalDateTimePair containing a new set of timings for the task
	 * @throws RecurrenceException
	 *             thrown when there is no valid frequency
	 */
	private static LocalDateTimePair obtainNextTime(Interval interval, LocalDateTime startDateTime,
			LocalDateTime endDateTime) throws RecurrenceException {
		String frequency = interval.getFrequency();
		int timeInterval = interval.getTimeInterval();

		switch (frequency) {
		case FREQ_HOURLY:
			startDateTime = startDateTime.plusHours(timeInterval);
			if (!endDateTime.isEqual(LocalDateTime.MAX)) {
				// if it is a deadline, endDateTime remains unadjusted
				endDateTime = endDateTime.plusHours(timeInterval);
			}
			break;

		case FREQ_DAILY:
			startDateTime = startDateTime.plusDays(timeInterval);
			if (!endDateTime.isEqual(LocalDateTime.MAX)) {
				endDateTime = endDateTime.plusDays(timeInterval);
			}
			break;

		case FREQ_WEEKLY:
			startDateTime = startDateTime.plusWeeks(timeInterval);
			if (!endDateTime.isEqual(LocalDateTime.MAX)) {
				endDateTime = endDateTime.plusWeeks(timeInterval);
			}
			break;

		case FREQ_MONTHLY:
			startDateTime = startDateTime.plusMonths(timeInterval);
			if (!endDateTime.isEqual(LocalDateTime.MAX)) {
				endDateTime = endDateTime.plusMonths(timeInterval);
			}
			break;

		case FREQ_YEARLY:
			startDateTime = startDateTime.plusYears(timeInterval);
			if (!endDateTime.isEqual(LocalDateTime.MAX)) {
				endDateTime = endDateTime.plusYears(timeInterval);
			}
			break;

		default:
			RecurrenceException e = new RecurrenceException(interval);
			throw e;
		}

		logger.log(Level.INFO, "added a new pair of timings");
		return new LocalDateTimePair(startDateTime, endDateTime);
	}

	/**
	 * Method called if byDayArray is initialised, meaning that the recurrence occurs over multiple days (e.g.
	 * every Monday and Wednesday). First takes into account the duration between the startDateTime and
	 * endDateTime, and stores it as a Duration object. If the endDateTime variable is LocalDateTime.MAX, this
	 * step will be skipped. <br>
	 * In the next step, a comparison list will be generated. This comparison list is generated by finding the
	 * next occurrence, from the current date and time, of each marked day in byDayArray. For example, if
	 * today is Tuesday and my recurrence is on Monday and Wednesday, the comparison list will contain the
	 * dates of next Monday and this Wednesday. <br>
	 * Next, the dates will be compared. The earliest date will be chosen. Using the same example, this means
	 * that this Wednesday will be chosen. <br>
	 * Next it will be determined if the timing chosen is within the same week as the current day. If it is,
	 * the chosen date will be set as the next startDateTime, with the endDateTime being the duration added to
	 * the startDateTime if applicable. Otherwise, the interval will be added to this startDateTime, with one
	 * week deducted for adjustment.
	 * 
	 * @param interval
	 *            Interval object which contains the details of the recurrence
	 * @param startDateTime
	 *            LocalDateTime which indicates the current startDateTime
	 * @param endDateTime
	 *            LocalDateTime which indicates the current endDateTime
	 * @return LocalDateTimePair containing a new set of timings for the task
	 */
	private static LocalDateTimePair obtainNextTimeByDay(Interval interval, LocalDateTime startDateTime,
			LocalDateTime endDateTime) {

		Duration duration = Duration.ZERO;
		if (!endDateTime.equals(LocalDateTime.MAX)) {
			duration = Duration.between(startDateTime, endDateTime);
		}

		ArrayList<LocalDateTime> comparisonList = generateComparisonList(interval, startDateTime);
		assert (comparisonList.size() > 0);

		startDateTime = generateNextStartDateTime(interval, startDateTime, comparisonList);
		if (!endDateTime.equals(LocalDateTime.MAX)) {
			endDateTime = startDateTime.plus(duration);
		}

		return new LocalDateTimePair(startDateTime, endDateTime);
	}

	private static ArrayList<LocalDateTime> generateComparisonList(Interval interval,
			LocalDateTime startDateTime) {
		ArrayList<LocalDateTime> comparisonList = new ArrayList<LocalDateTime>();
		int[] byDayArray = interval.getByDayArray();
		for (int i = 1; i <= 7; i++) {
			if (byDayArray[i] == 1) {
				DayOfWeek dayOfWeek = DayOfWeek.of(i);
				LocalDateTime dateTimeForComparing = startDateTime.with(TemporalAdjusters.next(dayOfWeek));
				comparisonList.add(dateTimeForComparing);
			}
		}
		return comparisonList;
	}

	private static LocalDateTime generateNextStartDateTime(Interval interval, LocalDateTime startDateTime,
			ArrayList<LocalDateTime> comparisonList) {

		assert (comparisonList.size() > 0);

		Collections.sort(comparisonList);
		// Takes the first timing as it is the earliest
		LocalDateTime newStartDateTime = comparisonList.get(0);

		// If in the same week, no need to consider the task interval
		boolean isInTheSameWeek = checkIfInTheSameWeek(startDateTime, newStartDateTime);
		if (!isInTheSameWeek) {
			newStartDateTime = modifyStartDateTime(interval, newStartDateTime);
		}
		return newStartDateTime;
	}

	private static boolean checkIfInTheSameWeek(LocalDateTime startDateTime, LocalDateTime newStartDateTime) {
		LocalDate startDate = startDateTime.toLocalDate();
		LocalDate newStartDate = newStartDateTime.toLocalDate();
		startDate = startDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
		newStartDate = newStartDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));

		// Checks if their upcoming Sundays are equal
		if (newStartDate.isEqual(startDate)) {
			return true;
		} else {
			return false;
		}
	}

	private static LocalDateTime modifyStartDateTime(Interval interval, LocalDateTime newStartDateTime) {
		String frequency = interval.getFrequency();
		int timeInterval = interval.getTimeInterval();

		// To negate the effects of obtaining the date in the next week earlier
		newStartDateTime = newStartDateTime.minusWeeks(1);

		switch (frequency) {
		case FREQ_HOURLY:
			newStartDateTime = newStartDateTime.plusHours(timeInterval);
			break;

		case FREQ_DAILY:
			newStartDateTime = newStartDateTime.plusDays(timeInterval);
			break;

		case FREQ_WEEKLY:
			newStartDateTime = newStartDateTime.plusWeeks(timeInterval);
			break;

		case FREQ_MONTHLY:
			newStartDateTime = newStartDateTime.plusMonths(timeInterval);
			break;

		case FREQ_YEARLY:
			newStartDateTime = newStartDateTime.plusYears(timeInterval);
			break;
		}

		return newStartDateTime;
	}

	private static boolean checkIfInfiniteRecurrence(Interval interval) {
		if (interval.getCount() == -1 && interval.getUntil().isEqual(LocalDateTime.MAX)) {
			return true;
		} else {
			return false;
		}
	}

	private static void handleChangeInStatusForOneOccurrence(TaskObject task, String status) {
		task.setIsRecurring(false);
		task.setStatus(status);
		logger.log(Level.INFO, "recurring deadline has come to an end");
	}
}
```
###### \src\logic\RecurringTest.java
``` java

package logic;

import static org.junit.Assert.*;
import java.util.ArrayList;
import java.time.LocalDateTime;
import org.junit.runners.MethodSorters;
import org.junit.FixMethodOrder;

import common.*;
import logic.timeoutput.TimeOutput;

import org.junit.Test;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class RecurringTest {

	public ArrayList<TaskObject> testArray = new ArrayList<TaskObject>();

	// EXCEPTIONS THROWN FOR INTERVAL CLASS
	@Test
	// Interval containing counts > 0
	public void testA() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 03, 17, 14, 00),
				LocalDateTime.of(2016, 03, 17, 16, 00), "event", "incomplete", 1);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, 5, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		testArray.add(task);
		Recurring.updateRecurringEvents(testArray);

		LocalDateTime nextStartDateTime = LocalDateTime.of(2016, 04, 14, 14, 00);
		LocalDateTime nextEndDateTime = LocalDateTime.of(2016, 04, 14, 16, 00);

		assertEquals(nextStartDateTime, testArray.get(0).getStartDateTime());
		assertEquals(nextEndDateTime, testArray.get(0).getEndDateTime());
		
		for (int i = 0; i < testArray.size(); i++) {
			if (testArray.get(i).getTaskId() < 0) {
				System.out.println(testArray.get(i).getTimeOutputString());
				System.out.println(testArray.get(i).getStatus());
				System.out.println(testArray.get(i).getTaskId());
			}
		}
	}

	@Test
	// Interval containing until but not yet end of recurrence
	public void testB() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 03, 17, 14, 00),
				LocalDateTime.of(2016, 03, 18, 16, 00), "event", "incomplete", 2);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.of(2016, 04, 14, 14, 00), "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}

		testArray.add(task);
		Recurring.updateRecurringEvents(testArray);

		LocalDateTime nextStartDateTime = LocalDateTime.of(2016, 04, 14, 14, 00);
		LocalDateTime nextEndDateTime = LocalDateTime.of(2016, 04, 15, 16, 00);

		assertEquals(nextStartDateTime, testArray.get(0).getStartDateTime());
		assertEquals(nextEndDateTime, testArray.get(0).getEndDateTime());
	}

	@Test
	// Interval containing counts == 0
	public void testC() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 03, 17, 14, 00),
				LocalDateTime.of(2016, 03, 17, 16, 00), "event", "incomplete", 3);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, 0, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		testArray.add(task);
		Recurring.updateRecurringEvents(testArray);

		LocalDateTime nextStartDateTime = LocalDateTime.of(2016, 03, 17, 14, 00);
		LocalDateTime nextEndDateTime = LocalDateTime.of(2016, 03, 17, 16, 00);

		assertEquals(nextStartDateTime, testArray.get(0).getStartDateTime());
		assertEquals(nextEndDateTime, testArray.get(0).getEndDateTime());

		assertEquals("overdue", testArray.get(0).getStatus());
	}

	@Test
	// Interval containing until which is reached
	public void testD() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 03, 17, 14, 00),
				LocalDateTime.of(2016, 03, 17, 16, 00), "event", "incomplete", 4);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.of(2016, 03, 16, 14, 00), "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		testArray.add(task);
		Recurring.updateRecurringEvents(testArray);

		LocalDateTime nextStartDateTime = LocalDateTime.of(2016, 03, 17, 14, 00);
		LocalDateTime nextEndDateTime = LocalDateTime.of(2016, 03, 17, 16, 00);

		assertEquals(nextStartDateTime, testArray.get(0).getStartDateTime());
		assertEquals(nextEndDateTime, testArray.get(0).getEndDateTime());

		assertEquals("overdue", testArray.get(0).getStatus());
	}

	@Test
	// Recurring task with different interval
	public void testE() throws Exception {
		TaskObject task = new TaskObject("Go to gym", LocalDateTime.of(2016, 03, 17, 15, 00),
				LocalDateTime.of(2016, 03, 17, 16, 00), "event", "incomplete", 5);
		task.setIsRecurring(true);
		Interval interval = new Interval("DAILY", 14, 10, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		testArray.add(task);
		Recurring.updateRecurringEvents(testArray);

		LocalDateTime nextStartDateTime = LocalDateTime.of(2016, 04, 14, 15, 00);
		LocalDateTime nextEndDateTime = LocalDateTime.of(2016, 04, 14, 16, 00);

		assertEquals(nextStartDateTime, testArray.get(0).getStartDateTime());
		assertEquals(nextEndDateTime, testArray.get(0).getEndDateTime());
	}

	/************************************************************************************/
	@Test
	// Recurring deadline which is not overdue, with counts
	public void testF() throws Exception {
		TaskObject task = new TaskObject("buy eggs", LocalDateTime.of(2016, 10, 13, 15, 00), "deadline", "incomplete",
				6);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, 5, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);

		testArray.add(task);
		Recurring.updateRecurringDeadlines(testArray);

		ArrayList<LocalDateTimePair> expectedDeadlineList = new ArrayList<LocalDateTimePair>();
		for (int i = 0; i < interval.getCount(); i++) {
			LocalDateTime dateTime = task.getStartDateTime().plusWeeks(i);
			expectedDeadlineList.add(new LocalDateTimePair(dateTime));
		}

		// Compares across all timings
		for (int i = 0; i < interval.getCount(); i++) {
			LocalDateTime expectedDateTime = expectedDeadlineList.get(i).getStartDateTime();
			LocalDateTime actualDateTime = task.getTaskDateTimes().get(i).getStartDateTime();
			assertEquals(expectedDateTime, actualDateTime);
		}
	}

	@Test
	// Recurring deadline which is not overdue, with until
	public void testG() throws Exception {
		TaskObject task = new TaskObject("buy tissue", LocalDateTime.of(2016, 7, 13, 15, 00), "deadline", "incomplete",
				7);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.of(2016, 9, 14, 15, 00), "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);

		testArray.add(task);
		Recurring.updateRecurringDeadlines(testArray);

		ArrayList<LocalDateTimePair> expectedDeadlineList = new ArrayList<LocalDateTimePair>();
		LocalDateTime dateTime = task.getStartDateTime();
		while (dateTime.isBefore(interval.getUntil())) {
			expectedDeadlineList.add(new LocalDateTimePair(dateTime));
			dateTime = dateTime.plusWeeks(1);
		}

		// Compares across all timings
		for (int i = 0; i < expectedDeadlineList.size(); i++) {
			LocalDateTime expectedDateTime = expectedDeadlineList.get(i).getStartDateTime();
			LocalDateTime actualDateTime = task.getTaskDateTimes().get(i).getStartDateTime();
			assertEquals(expectedDateTime, actualDateTime);
		}
	}

	@Test
	// Recurring deadline which is overdue, with until
	public void testH() throws Exception {
		TaskObject task = new TaskObject("buy lunch", LocalDateTime.of(2016, 3, 14, 15, 00), "deadline", "incomplete",
				8);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.of(2016, 5, 16, 14, 59), "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);

		testArray.add(task);
		int currentNumberOfTasks = testArray.size();
		int currentNumberOfRecurrences = task.getTaskDateTimes().size();
		Recurring.updateRecurringDeadlines(testArray);
		int newNumberOfTasks = testArray.size();
		int newNumberOfRecurrences = task.getTaskDateTimes().size();

		// Sum of tasks and timings is always the same
		assertTrue(currentNumberOfTasks + currentNumberOfRecurrences == newNumberOfTasks + newNumberOfRecurrences);
		// Checks that the updated deadline is after the current time
		assertTrue(task.getStartDateTime().isAfter(LocalDateTime.now()));

		for (int i = 0; i < testArray.size(); i++) {
			if (testArray.get(i).getTaskId() < 0) {
				// Split recurrences have a negative task ID
				System.out.println(testArray.get(i).getStartDateTime().toString());
				System.out.println(testArray.get(i).getStatus());
			}
		}

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			System.out.println(task.getTaskDateTimes().get(i).getStartDateTime().toString());
		}
	}

	@Test
	// Recurring deadline which is ALL overdue, with counts
	public void testI() throws Exception {
		TaskObject task = new TaskObject("buy lunch", LocalDateTime.of(2016, 3, 16, 15, 00), "deadline", "incomplete",
				9);
		task.setIsRecurring(true);
		Interval interval = new Interval("DAILY", 1, 5, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);

		testArray.add(task);
		int currentNumberOfTasks = testArray.size();
		int currentNumberOfRecurrences = task.getTaskDateTimes().size();
		Recurring.updateRecurringDeadlines(testArray);
		int newNumberOfTasks = testArray.size();
		int newNumberOfRecurrences = task.getTaskDateTimes().size();

		// Sum of tasks and timings is always the same
		assertTrue(currentNumberOfTasks + currentNumberOfRecurrences == newNumberOfTasks + newNumberOfRecurrences);
		// Checks that splitting only occurs 4 times
		assertTrue(newNumberOfTasks - currentNumberOfTasks == 4);

		for (int i = 0; i < testArray.size(); i++) {
			if (testArray.get(i).getTaskId() < 0) {
				// Split recurrences have a negative task ID
				System.out.println(testArray.get(i).getStartDateTime().toString());
				System.out.println(testArray.get(i).getStatus());
			}
		}

	}

	@Test
	// Until == startDateTime of another recurrence
	public void testJ() throws Exception {
		TaskObject task = new TaskObject("cs lecture", LocalDateTime.of(2016, 04, 01, 16, 00),
				LocalDateTime.of(2016, 04, 01, 18, 00), "event", "incomplete", 10);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.of(2016, 04, 22, 16, 00), "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}

		testArray.add(task);
		Recurring.updateRecurringEvents(testArray);

		LocalDateTime nextStartDateTime = LocalDateTime.of(2016, 04, 15, 16, 00);
		LocalDateTime nextEndDateTime = LocalDateTime.of(2016, 04, 15, 18, 00);

		assertEquals(nextStartDateTime, testArray.get(0).getStartDateTime());
		assertEquals(nextEndDateTime, testArray.get(0).getEndDateTime());
	}

	@Test
	// Addition of infinite event
	public void testK() throws Exception {
		TaskObject task = new TaskObject("cs lecture", LocalDateTime.of(2016, 04, 01, 16, 00),
				LocalDateTime.of(2016, 04, 01, 18, 00), "event", "incomplete", 11);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.MAX, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		assertTrue(task.getTaskDateTimes().size() == 10);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}

	@Test
	// Addition of infinite deadline
	public void testL() throws Exception {
		TaskObject task = new TaskObject("cs lecture", LocalDateTime.of(2016, 04, 01, 16, 00), "deadline", "incomplete",
				12);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.MAX, "");
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);

		testArray.add(task);
		Recurring.updateRecurringDeadlines(testArray);

		assertTrue(task.getTaskDateTimes().size() == 10);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setDeadlineTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime());
			System.out.println(line);
		}
	}

	/*****************************************************************************/
	/**
	 * Tests for the implementation of byDay
	 */

	@Test
	// event, byDay = Monday, Thursday, Sunday. Interval = 1 week
	public void testM() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 05, 15, 14, 00),
				LocalDateTime.of(2016, 05, 15, 16, 00), "event", "incomplete", 13);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, LocalDateTime.of(2016, 06, 19, 14, 00), "");
		interval.setByDay(1);
		interval.setByDay(4);
		interval.setByDay(7);
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);

		assertTrue(task.getTaskDateTimes().size() == 16);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}

	@Test
	// event, byDay = Tuesday, Saturday. Interval = 3 weeks
	public void testN() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 05, 17, 14, 00),
				LocalDateTime.of(2016, 05, 17, 16, 00), "event", "incomplete", 14);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 3, LocalDateTime.of(2016, 07, 19, 14, 00), "");
		interval.setByDay(2);
		interval.setByDay(6);
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);
		
		assertTrue(task.getTaskDateTimes().size() == 7);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}
	
	@Test
	// event, byDay = Wednesday, Saturday. Interval = 2 weeks
	public void testO() throws Exception {
		TaskObject task = new TaskObject("IE2130 Lecture", LocalDateTime.of(2016, 05, 19, 14, 00),
				LocalDateTime.of(2016, 05, 19, 16, 00), "event", "incomplete", 15);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 2, 10, "");
		interval.setByDay(3);
		interval.setByDay(6);
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);
		
		// 10 * 2 == 20
		assertTrue (task.getTaskDateTimes().size() == 20);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(),
					task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}
	
	@Test
	// deadline, byDay = Monday, Friday. Interval = 2 weeks
	public void testP() throws Exception {
		TaskObject task = new TaskObject("deadline 40", LocalDateTime.of(2016, 8, 19, 14, 00),
				"deadline", "incomplete", 16);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 2, 15, "");
		interval.setByDay(1);
		interval.setByDay(5);
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);
		
		// 15 * 2 == 30
		assertTrue (task.getTaskDateTimes().size() == 30);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setDeadlineTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime());
			System.out.println(line);
		}
	}
	
	@Test
	// deadline, byDay = Thursday, Friday, infinite recurrence 2 weeks
	public void testQ() throws Exception{
		TaskObject task = new TaskObject("deadline infinite", LocalDateTime.of(2016, 8, 21, 14, 00),
				"deadline", "incomplete", 17);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 2, -1, "");
		interval.setByDay(4);
		interval.setByDay(5);
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringDeadlineTimes(task);
		
		// 10 * 2 = 20
		assertTrue (task.getTaskDateTimes().size() == 20);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setDeadlineTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime());
			System.out.println(line);
		}
	}
	
	@Test
	// event, byDay = Wednesday, Friday, infinite recurrence 1 week
	public void testR() throws Exception{
		TaskObject task = new TaskObject("play soccer", LocalDateTime.of(2016, 05, 19, 14, 00),
				LocalDateTime.of(2016, 05, 19, 16, 00), "event", "incomplete", 18);
		task.setIsRecurring(true);
		Interval interval = new Interval("WEEKLY", 1, -1, "");
		interval.setByDay(3);
		interval.setByDay(5);
		task.setInterval(interval);

		LocalDateTimePair pair = new LocalDateTimePair(task.getStartDateTime(), task.getEndDateTime());
		task.addToTaskDateTimes(pair);
		Recurring.setAllRecurringEventTimes(task);
		
		// 10 * 2 = 20
		assertTrue (task.getTaskDateTimes().size() == 20);

		for (int i = 0; i < task.getTaskDateTimes().size(); i++) {
			String line = TimeOutput.setEventTimeOutput(task.getTaskDateTimes().get(i).getStartDateTime(), task.getTaskDateTimes().get(i).getEndDateTime());
			System.out.println(line);
		}
	}
}
```
###### \src\logic\save\Save.java
``` java

package logic.save;

import storage.*;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.nio.file.NoSuchFileException;
import java.util.ArrayList;
import java.util.logging.*;

import common.AtfLogger;
import common.TaskObject;

/**
 * Creates a Save object to perform two main types of operations. <br>
 * 1) Save to - Permanently changes the default location for the file to be saved. Also saves the file there
 * for the first time when this command is executed. <br>
 * 2) Save as - Saves a copy of the file at the specified location. Default location will not be changed.
 * 
 * @param int
 *            saveCommand - Default value 0, which will not be recognised by the program. Takes the value of 1
 *            for "Save to" and value of 2 for "Save as".
 * @param boolean
 *            isSaved - Value determines whether file was saved successfully to the location
 * @author ChongYan
 *
 */
public class Save {

	private static final String MESSAGE_SAVE_TO = "Tasks have been, and will continue to be saved to %1s";
	private static final String MESSAGE_SAVE_AS = "Tasks have been saved to %1s";
	private static final String MESSAGE_SAVE_INVALID = "Save command is invalid";
	private static final String MESSAGE_SAVE_ERROR = "Error saving file to %1s";
	private static final Logger logger = AtfLogger.getLogger();

	private boolean isSaved = false;
	private int saveCommand = 0;
	private String newFilePath = "";
	private ArrayList<String> output = new ArrayList<String>();
	private ArrayList<TaskObject> taskList = new ArrayList<TaskObject>();

	public Save() {

	}

	/**
	 * Constructor for Save object.
	 * 
	 * @param taskObj
	 *            - Contains the details of execution in the title attribute. Precondition: Title must be of
	 *            the format "to -file directory-" or "as -file directory-" or else the constructor will not
	 *            modify the value of saveCommand, which will lead to the abortion of the operation.
	 * @param taskList
	 */
	public Save(TaskObject taskObj, ArrayList<TaskObject> taskList) {
		String line = taskObj.getTitle();
		String[] cmd = new String[2];
		cmd = line.split(" ", 2);
		if (cmd[0].equals("to")) {
			saveCommand = 1;
		} else {
			if (cmd[0].equals("as")) {
				saveCommand = 2;
			}
		}
		newFilePath = cmd[1];
		this.taskList = taskList;
	}

	/**
	 * Main method of the Save class. Makes use of saveCommand to determine which save operation to execute.
	 * Does not do anything and returns an error output if saveCommand == 0, and if the file location is
	 * invalid.
	 * 
	 * @return ArrayList<String> containing an output message indicating the success or failure of operation
	 */
	public ArrayList<String> run() {
		try {
			if (saveCommand == 1) {
				saveTo();
			} else {
				if (saveCommand == 2) {
					saveAs();
				}
			}
		} catch (NoSuchFileException e) {
			e.printStackTrace();
			output.add(String.format(MESSAGE_SAVE_ERROR, newFilePath));
			logger.log(Level.WARNING, "unable to save file to new location");
		} catch (IOException e) {
			e.printStackTrace();
			output.add(String.format(MESSAGE_SAVE_ERROR, newFilePath));
			logger.log(Level.WARNING, "unable to save file to new location");
		} catch (InvalidPathException e) {
			e.printStackTrace();
			output.add(String.format(MESSAGE_SAVE_ERROR, newFilePath));
			logger.log(Level.WARNING, "unable to save file to new location");
		}
		if (output.isEmpty()) {
			createOutput();
		}
		return output;
	}

	private void saveTo() throws InvalidPathException, IOException, NoSuchFileException {
		IStorage storage = FileStorage.getInstance();
		storage.changeSaveLocation(newFilePath);
		storage.save(taskList);
		logger.log(Level.INFO, "File saved to new location");
		isSaved = true;
	}

	private void saveAs() throws InvalidPathException, IOException, NoSuchFileException {
		IStorage storage = FileStorage.getInstance();
		storage.createCopy(newFilePath, "filecopy.txt");
		isSaved = true;
		logger.log(Level.INFO, "File copy created in the same directory");
	}

	private void createOutput() {
		String text = "";
		if (isSaved) {
			if (saveCommand == 1) {
				text = String.format(MESSAGE_SAVE_TO, newFilePath);
				output.add(text);
			} else if (saveCommand == 2) {
				text = String.format(MESSAGE_SAVE_AS, newFilePath);
				output.add(text);
			}
		} else if (saveCommand == 0) {
			text = String.format(MESSAGE_SAVE_INVALID);
			output.add(text);
		} else {
			text = String.format(MESSAGE_SAVE_ERROR, newFilePath);
			output.add(text);
		}
		logger.log(Level.INFO, "created output");
	}
}
```
###### \src\logic\search\Search.java
``` java

	/**
	 * Retrieves the task contained in the last output task list via an index, and proceeds to output all the
	 * timings associated with the task.
	 */
	private void searchByIndex() {
		assert (searchIndex > 0 && searchIndex <= lastOutputTaskList.size());

		try {
			int taskIdToSearch = lastOutputTaskList.get(searchIndex - 1).getTaskId();
			findTaskWithIndex(taskIdToSearch);
		} catch (IndexOutOfBoundsException e) {
			createErrorOutput(MESSAGE_TASK_INDEX_NOT_FOUND_ERROR);
		}
	}

	private void findTaskWithIndex(int taskIdToSearch) throws IndexOutOfBoundsException{
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == taskIdToSearch) {
				TaskObject foundTask = taskList.get(i);
				setOutput(foundTask);
			}
		}
	}

	// ------------------------- GENERATING OUTPUT -------------------------

	private void setOutput() {
		if (matchedTasks.isEmpty()) {
			output.add(String.format(MESSAGE_NO_RESULTS_FOUND));
		} else {
			if (output.isEmpty()) {
				generateSearchParametersOutput();
				output.addAll(super.runSpecificList(matchedTasks));
			}
		}
	}

	private void setOutput(TaskObject foundTask) {
		LocalDateTime startDateTime;
		LocalDateTime endDateTime;
		String timeOutput;

		taskDateTimeOutput.clear();

		taskDateTimeOutput.add(String.format(MESSAGE_TIMINGS_FOUND, foundTask.getTitle()));
		if (foundTask.getIsRecurring()) {
			output.add(String.format(MESSAGE_RECURRENCE_TIMINGS_DISPLAY, searchIndex));
			try {
				if (foundTask.getCategory().equals(CATEGORY_EVENT)) {
					for (int i = 0; i < foundTask.getTaskDateTimes().size(); i++) {
						startDateTime = foundTask.getTaskDateTimes().get(i).getStartDateTime();
						endDateTime = foundTask.getTaskDateTimes().get(i).getEndDateTime();
						timeOutput = TimeOutput.setEventTimeOutput(startDateTime, endDateTime);
						timeOutput = Integer.toString(i + 1) + ". " + timeOutput;
						taskDateTimeOutput.add(timeOutput);
					}
				} else {
					if (foundTask.getCategory().equals(CATEGORY_DEADLINE)) {
						for (int i = 0; i < foundTask.getTaskDateTimes().size(); i++) {
							startDateTime = foundTask.getTaskDateTimes().get(i).getStartDateTime();
							timeOutput = TimeOutput.setDeadlineTimeOutput(startDateTime);
							timeOutput = Integer.toString(i + 1) + ". " + timeOutput;
							taskDateTimeOutput.add(timeOutput);
						}
					}
				}
			} catch (Exception e) {
				createErrorOutput(MESSAGE_INVALID_RECURRENCE);
			}
		} else {
			output.add(String.format(MESSAGE_NO_RECURRENCE_TIMING_DISPLAY, searchIndex));
			searchIndex = -1; // if it is a non-recurring task, the sidebar will not appear
			if (foundTask.getCategory().equals(CATEGORY_EVENT)) {
				TimeOutput.setEventTimeOutput(foundTask);
			} else {
				if (foundTask.getCategory().equals(CATEGORY_DEADLINE)) {
					TimeOutput.setDeadlineTimeOutput(foundTask);
				}
			}
			timeOutput = "1. " + foundTask.getTimeOutputString();
			taskDateTimeOutput.add(timeOutput);
		}
	}

```
###### \src\logic\timeoutput\TimeOutput.java
``` java

package logic.timeoutput;

import java.time.DateTimeException;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.time.temporal.TemporalAdjusters;
import java.time.DayOfWeek;

import java.util.ArrayList;
import java.util.Locale;

import common.TaskObject;

import static logic.constants.Strings.*;

public class TimeOutput {

	static DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/YY");
	static DateTimeFormatter shortFormatter = DateTimeFormatter.ofPattern("dd/MM");

	/**
	 * Formats a time output for GUI to display, for the entire list of tasks. For events, the following are
	 * the permutations for display: <br>
	 * 
	 * 1. with event within a day, start and end date in the same week as the current week:
	 * "from 15:00 to 16:00 on Thursday 24/03" <br>
	 * 2. with event across days, start and end date in the same week as the current week:
	 * "from 15:00 on Thursday 24/03 to 16:00 on Friday 25/03" <br>
	 * 3. with event across days, start date in current week, end date in next week:
	 * "from 15:00 on Thursday 24/03 to 16:00 on next Friday 01/04" <br>
	 * 4. with events within a day, start and end date in different week from current week:
	 * "from 15:00 to 16:00 on 31/03/16" <br>
	 * 5. with events across days, start and end date in different week from current week:
	 * "from 15:00 on 31/03/16 to 16:00 on 01/04/16" <br>
	 * 
	 * * if start time does not exist, format will be "from -date- to -end time- on date" <br>
	 * * if both start, end time do not exist, format will be "from -date- to -end date-" <br>
	 * * if only end time does not exist, format will be "from -start time- on -start date- to -end date-"
	 * <br>
	 * 
	 * <br>
	 * For deadlines, the following are the permutations for display: <br>
	 * 1. deadlines without time in same week: "by Thursday 24/03" <br>
	 * 2. deadlines with time in same week: "by 15:00 on Thursday 24/03" <br>
	 * 3. deadlines without time in different week: "by 31/03/16" <br>
	 * 4. deadlines with time in different week: "by 15:00 on 31/03/16"
	 * 
	 * @param taskList
	 *            contains all the tasks for the user
	 */

	public static void setTimeOutputForGui(ArrayList<TaskObject> taskList) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getCategory().equals(CATEGORY_EVENT)) {
				setEventTimeOutput(taskList.get(i));
			} else if (taskList.get(i).getCategory().equals(CATEGORY_DEADLINE)) {
				setDeadlineTimeOutput(taskList.get(i));
			} else {
				taskList.get(i).setTimeOutputString("");
				// No time displayed for floating tasks
			}
		}
	}
	
	/**
	 * Common method called by Delete and Edit to set the timeOutput for a task. Method basically contains
	 * control statements to determine if it is a deadline or an event, and calls the relevant helper
	 * functions to set the timeOutput
	 * 
	 * @param task
	 *            Task whose timeOutput is to be modified
	 */
	public static void setTaskTimeOutput(TaskObject task) {
		if (task.getCategory().equals(CATEGORY_DEADLINE)) {
			setDeadlineTimeOutput(task);
		} else if (task.getCategory().equals(CATEGORY_EVENT)) {
			setEventTimeOutput(task);
		}
	}

	// ==================================================================================
	// First Level of Abstraction
	// ==================================================================================
	/**
	 * Helper method to setTimeOutputForGui, but also called individually by methods in Search and Recurring
	 * to set the timeOutputString for a specific event without running through the entire task list. Format
	 * of timeOutputString identical to those specified in setTimeOutputForGui.
	 * 
	 * @param event
	 *            TaskObject of category "event" whose timeOutputString is to be modified
	 */
	public static void setEventTimeOutput(TaskObject event) {
		String line;
		String[] start;
		String[] end;

		try {
			start = createDateTimeArray(event.getStartDateTime(), false);
			if (checkIfInTheSameWeek(event.getStartDateTime().toLocalDate())) {
				end = createDateTimeArray(event.getEndDateTime(), true);
			} else {
				end = createDateTimeArray(event.getEndDateTime(), false);
			}
			line = formatEventTimeOutput(start, end);
			event.setTimeOutputString(line);
		} catch (DateTimeException e) {
			e.printStackTrace();
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
	}

	/**
	 * A variant of setEventTimeOutput, for Recurring tasks to display all occurrences in the desired
	 * timeOutput format. Only called from searchByIndex in Search.
	 * 
	 * @param startDateTime
	 *            LocalDateTime containing the start date and time of the event
	 * @param endDateTime
	 *            LocalDateTime containing the end date and time of the event
	 * @return String containing the timeOutput for this set of start and end timings
	 */
	public static String setEventTimeOutput(LocalDateTime startDateTime, LocalDateTime endDateTime) {
		String line = "";
		String[] start;
		String[] end;

		try {
			start = createDateTimeArray(startDateTime, false);
			if (checkIfInTheSameWeek(startDateTime.toLocalDate())) {
				end = createDateTimeArray(endDateTime, true);
			} else {
				end = createDateTimeArray(endDateTime, false);
			}
			line = formatEventTimeOutput(start, end);
		} catch (DateTimeException e) {
			e.printStackTrace();
		} catch (NullPointerException e) {
			e.printStackTrace();
		}

		return line;
	}

	/**
	 * Helper method to setTimeOutputForGui, but also called individually by methods in Search and Recurring
	 * to set the timeOutputString for a specific deadline without running through the entire task list.
	 * Format of timeOutputString identical to those specified in setTimeOutputForGui.
	 * 
	 * @param deadline
	 *            TaskObject of category "deadline" whose timeOutput is to be set
	 */
	public static void setDeadlineTimeOutput(TaskObject deadline) {
		String line;
		try {
			String[] start = createDateTimeArray(deadline.getStartDateTime(), false);
			line = formatDeadlineTimeOutput(start);
			deadline.setTimeOutputString(line);
		} catch (DateTimeException e) {
			System.out.println(MESSAGE_DATE_TIME_CONVERSION_ERROR);
		} catch (NullPointerException e) {
			System.out.println(MESSAGE_NULL_POINTER_EXCEPTION);
		}
	}

	/**
	 * A variant of setDeadlineTimeOutput, for Recurring tasks to display all occurrences in the desired
	 * timeOutput format. Only called from searchByIndex in Search.
	 * 
	 * @param startDateTime
	 *            LocalDateTime containing the deadline of this task
	 * @return String containing the timeOutput information for this task
	 */
	public static String setDeadlineTimeOutput(LocalDateTime startDateTime) {
		String line = "";
		try {
			String[] start = createDateTimeArray(startDateTime, false);
			line = formatDeadlineTimeOutput(start);
		} catch (DateTimeException e) {
			System.out.println(MESSAGE_DATE_TIME_CONVERSION_ERROR);
		} catch (NullPointerException e) {
			System.out.println(MESSAGE_NULL_POINTER_EXCEPTION);
		}
		return line;
	}

	// ==================================================================================
	// Second Level of Abstraction
	// ==================================================================================
	private static String formatEventTimeOutput(String[] start, String[] end) throws NullPointerException {
		String formattedString = "";
		if (end[0].equals(start[0])) { // If start date == end date
			formattedString = String.format(DISPLAY_TIME_EVENT_3, start[1], end[1], end[0]);
			// End Date will not be printed
		} else if (!end[1].equals("") && !start[1].equals("")) {
			// if both start and end time exist
			formattedString = String.format(DISPLAY_TIME_EVENT_1, start[1], start[0], end[1], end[0]);
			// End Date will be printed
		} else if (end[1].equals("")) { // if end time does not exist
			if (start[1].equals("")) { // if start time does not exist
				formattedString = String.format(DISPLAY_TIME_EVENT_2, start[0], end[0]);
			} else { // if start time exists
				formattedString = String.format(DISPLAY_TIME_EVENT_4, start[1], start[0], end[0]);
			}
		} else if (start[1].equals("")) { // if start time does not exist and end time exists
			formattedString = String.format(DISPLAY_TIME_EVENT_5, start[0], end[1], end[0]);
		}
		return formattedString;
	}
	
	private static String formatDeadlineTimeOutput(String[] start) throws NullPointerException {
		String formattedString = "";
		if (start[1].equals("")) {
			formattedString = String.format(DISPLAY_TIME_DEADLINE, start[0]);
			// If time due is empty
		} else {
			String startDateTime = start[1].concat(" on ").concat(start[0]);
			formattedString = String.format(DISPLAY_TIME_DEADLINE, startDateTime);
		}
		return formattedString;
	}

	// =================================================================================
	// Lower Levels of Abstraction
	// =================================================================================
	private static String[] createDateTimeArray(LocalDateTime dateTime, boolean isEndDate)
			throws DateTimeException {
		String[] timeArray = new String[2];

		timeArray[0] = processRelativeDate(dateTime.toLocalDate(), isEndDate);

		if (!dateTime.toLocalTime().equals(LocalTime.MAX)) {
			timeArray[1] = dateTime.toLocalTime().toString();
		} else {
			timeArray[1] = "";
		}
		return timeArray;
	}

	private static String processRelativeDate(LocalDate date, boolean isEndDate) {
		String dateString = "";
		String dayOfWeek = "";
		boolean isInTheSameWeek = checkIfInTheSameWeek(date);
		// event in this week: e.g Thursday 24/03, applies to both start end
		if (isInTheSameWeek) {
			dayOfWeek = date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);
			dateString = dayOfWeek + " " + date.format(shortFormatter);
		} else if (isEndDate) { // only applies for ending date of events
			boolean isInTheNextWeek = checkIfInTheNextWeek(date);
			if (isInTheNextWeek) {
				// event end date in next week: e.g. next Monday 28/03
				dayOfWeek = date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);
				dateString = "next " + dayOfWeek + " " + date.format(shortFormatter);
			} else {
				// event end date not in next week: e.g. 19/04
				dateString = date.format(shortFormatter);
			}
		} else {
			// event start date, deadline date: e.g. 19/04/16
			dateString = date.format(formatter);
		}
		return dateString;
	}

	private static boolean checkIfInTheSameWeek(LocalDate date) {
		DayOfWeek sunday = DayOfWeek.SUNDAY;
		LocalDate thisSunday = LocalDate.now().with(TemporalAdjusters.nextOrSame(sunday));
		LocalDate lastSunday = thisSunday.minusWeeks(1);

		if (!date.isAfter(thisSunday) && date.isAfter(lastSunday)) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean checkIfInTheNextWeek(LocalDate date) {
		DayOfWeek sunday = DayOfWeek.SUNDAY;
		LocalDate thisSunday = LocalDate.now().with(TemporalAdjusters.nextOrSame(sunday));
		LocalDate nextSunday = thisSunday.plusWeeks(1);

		if (!date.isAfter(nextSunday) && date.isAfter(thisSunday)) {
			return true;
		} else {
			return false;
		}
	}
}
```
###### \src\logic\timeoutput\TimeOutputTest.java
``` java

package logic.timeoutput;

import common.*;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Locale;
import java.time.LocalDateTime;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.TextStyle;
import java.time.temporal.TemporalAdjusters;

import org.junit.Test;
import org.junit.runners.MethodSorters;
import org.junit.FixMethodOrder;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)

public class TimeOutputTest {
	private static ArrayList<TaskObject> testArray = new ArrayList<TaskObject>();
	private ArrayList<String> actualTimeOutput = new ArrayList<String>();
	private static ArrayList<String> expectedTimeOutput = new ArrayList<String>();
	static DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/YY");
	static DateTimeFormatter shortFormatter = DateTimeFormatter.ofPattern("dd/MM");

	/**********************************************************************************/
	/**
	 * Tests for setTimeOutputForGui
	 */
	@Test
	public void testA() {
		TaskObject task = new TaskObject("deadline with time and date", "deadline", "incomplete", 1);
		task.setStartDateTime(LocalDateTime.of(2016, 3, 15, 16, 00));
		// of(int year, int month, int dayOfMonth, int hour, int minute)
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("by 16:00 on 15/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	public void testB() {
		TaskObject task = new TaskObject("event with different dates", "event", "incomplete", 2);
		task.setEndDateTime(LocalDateTime.of(2016, 3, 15, 16, 00));
		task.setStartDateTime(LocalDateTime.of(2016, 3, 12, 15, 00));
		// of(int year, int month, int dayOfMonth, int hour, int minute)
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("from 15:00 on 12/03/16 \nto 16:00 on 15/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	public void testC() {
		TaskObject task = new TaskObject("event in a single day", "event", "incomplete", 3);
		task.setEndDateTime(LocalDateTime.of(2016, 3, 15, 16, 00));
		task.setStartDateTime(LocalDateTime.of(2016, 3, 15, 15, 00));
		// of(int year, int month, int dayOfMonth, int hour, int minute)
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("from 15:00 to 16:00 \non 15/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	public void testD() {
		TaskObject task = new TaskObject("deadline without time", "deadline", "incomplete", 4);
		task.setStartDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 15), LocalTime.MAX));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("by 15/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Start date, no start time, end date, no end time
	public void testE() {
		TaskObject task = new TaskObject("event without time", "event", "incomplete", 5);
		task.setStartDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 15), LocalTime.MAX));
		task.setEndDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 16), LocalTime.MAX));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("from 15/03/16 to 16/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Start date, start time, end date, no end time
	public void testF() {
		TaskObject task = new TaskObject("event without time", "event", "incomplete", 6);
		task.setStartDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 15), LocalTime.of(13, 00)));
		task.setEndDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 16), LocalTime.MAX));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("from 13:00 on 15/03/16 \nto 16/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Start date, no start time, end date, end time
	public void testG() {
		TaskObject task = new TaskObject("event without time", "event", "incomplete", 7);
		task.setStartDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 15), LocalTime.MAX));
		task.setEndDateTime(LocalDateTime.of(LocalDate.of(2016, 3, 16), LocalTime.of(14, 00)));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}
		expectedTimeOutput.add("from 15/03/16 \nto 14:00 on 16/03/16");

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	/*******************************************************************************/
	/**
	 * Tests for setEventTimeOutput(LocalDateTime , LocalDateTime ) Possible
	 * paths for this function mostly tested in preceding tests
	 */

	@Test
	// Regular event with start date, time, end date, time
	public void testH() {
		LocalDateTime startDateTime = LocalDateTime.of(LocalDate.of(2016, 11, 16), LocalTime.of(9, 30));
		LocalDateTime endDateTime = LocalDateTime.of(LocalDate.of(2016, 11, 19), LocalTime.of(3, 20));

		String actualOutput = TimeOutput.setEventTimeOutput(startDateTime, endDateTime);
		String expectedOutput = "from 09:30 on 16/11/16 \nto 03:20 on 19/11/16";

		assertEquals(expectedOutput, actualOutput);
	}

	/*********************************************************************************/
	/**
	 * Tests for setEventTimeOutput for events and deadlines due in the current
	 * week. Tests are written in a way to make it independent of when the tests
	 * are run
	 */
	@Test
	// Start date and time, end date and time on the same day
	public void testI() {
		TaskObject task = new TaskObject("event this week", "event", "incomplete", 9);
		task.setStartDateTime(LocalDateTime.of(LocalDate.now(), LocalTime.of(12, 00)));
		task.setEndDateTime(LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 00)));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);
		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}

		String dayOfWeek = LocalDate.now().getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);
		String dateString = LocalDate.now().format(shortFormatter);

		expectedTimeOutput.add("from 12:00 to 14:00 \non " + dayOfWeek + " " + dateString);

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Start date and time, end date and time on different days of current week
	public void testJ() {
		TaskObject task = new TaskObject("event from thurs to fri", "event", "incomplete", 10);

		LocalDate thisThursday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.THURSDAY));
		LocalDate thisFriday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY));
		LocalDate thisSunday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));

		if (thisThursday.isAfter(thisSunday)) {
			thisThursday = thisThursday.minusWeeks(1);
		}

		if (thisFriday.isAfter(thisSunday)) {
			thisFriday = thisFriday.minusWeeks(1);
		}

		task.setStartDateTime(LocalDateTime.of(thisThursday, LocalTime.of(00, 00)));
		task.setEndDateTime(LocalDateTime.of(thisFriday, LocalTime.of(23, 59)));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);

		String startDateString = thisThursday.format(shortFormatter);
		String endDateString = thisFriday.format(shortFormatter);

		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}

		expectedTimeOutput.add("from 00:00 on Thursday " + startDateString + " \nto 23:59 on Friday " + endDateString);

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Deadline within this week
	public void testK() {
		TaskObject task = new TaskObject("deadline with time and date", "deadline", "incomplete", 11);

		LocalDate thisTuesday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));
		LocalDate thisSunday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));

		if (thisTuesday.isAfter(thisSunday)) {
			thisTuesday = thisTuesday.minusWeeks(1);
		}

		task.setStartDateTime(LocalDateTime.of(thisTuesday, LocalTime.of(15, 00)));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);

		String dateString = thisTuesday.format(shortFormatter);

		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}

		expectedTimeOutput.add("by 15:00 on Tuesday " + dateString);

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Deadline within this week, without time
	public void testL() {
		TaskObject task = new TaskObject("deadline with date", "deadline", "incomplete", 12);

		LocalDate thisMonday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));
		LocalDate thisSunday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));

		if (thisMonday.isAfter(thisSunday)) {
			thisMonday = thisMonday.minusWeeks(1);
		}

		task.setStartDateTime(LocalDateTime.of(thisMonday, LocalTime.MAX));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);

		String dateString = thisMonday.format(shortFormatter);

		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}

		expectedTimeOutput.add("by Monday " + dateString);

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}

	@Test
	// Event with start date in current week and end date in next week
	public void testM() {
		TaskObject task = new TaskObject("event from sunday to monday", "event", "incomplete", 13);

		LocalDate nextMonday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		LocalDate thisSunday = LocalDate.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));

		task.setStartDateTime(LocalDateTime.of(thisSunday, LocalTime.of(00, 00)));
		task.setEndDateTime(LocalDateTime.of(nextMonday, LocalTime.of(23, 59)));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);

		String startDateString = thisSunday.format(shortFormatter);
		String endDateString = nextMonday.format(shortFormatter);

		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}

		expectedTimeOutput.add("from 00:00 on Sunday " + startDateString + " \nto 23:59 on next Monday " + endDateString);

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}
	
	@Test
	// Event with start date and end date in next week
	public void testN() {
		TaskObject task = new TaskObject("event from sunday to monday", "event", "incomplete", 13);

		LocalDate nextMonday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		LocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
		
		if(nextSunday.isBefore(nextMonday)) {
			nextSunday = nextSunday.plusWeeks(1);
		}

		task.setStartDateTime(LocalDateTime.of(nextMonday, LocalTime.of(00, 00)));
		task.setEndDateTime(LocalDateTime.of(nextSunday, LocalTime.of(23, 59)));
		testArray.add(task);
		TimeOutput.setTimeOutputForGui(testArray);

		String startDateString = nextMonday.format(formatter);
		String endDateString = nextSunday.format(formatter);

		for (int i = 0; i < testArray.size(); i++) {
			actualTimeOutput.add(testArray.get(i).getTimeOutputString());
		}

		expectedTimeOutput.add("from 00:00 on " + startDateString + " \nto 23:59 on " + endDateString);

		assertEquals(expectedTimeOutput, actualTimeOutput);
	}
	
}
```
