# A0080510X
###### \src\common\AtfLogger.java
``` java

package common;

import java.io.File;
import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class AtfLogger {

    static private FileHandler fileHandler;
    static private SimpleFormatter formatter;
    static private String LOGGER_NAME = "log";
    
    public static Logger logger = null;

    public static Logger getLogger() {
        if (logger == null) { 
            logger = Logger.getLogger(LOGGER_NAME);
            logger.setLevel(Level.INFO);
            try {
                File dir = new File(storage.Constants.FILEPATH_LOGDIR.toString());
                dir.mkdirs();
                fileHandler = new FileHandler(storage.Constants.FILEPATH_LOGFILE.toString(),
                                              true);
            } catch (SecurityException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            logger.addHandler(fileHandler);

            formatter = new SimpleFormatter();
            fileHandler.setFormatter(formatter);
            return logger;
        }
        return logger;
    }
}
```
###### \src\logic\help\HelpTopic.java
``` java

package logic.help;

import java.util.ArrayList;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * This class is a representation of a help topic. 
 * The contents of the topic and name of the topic can be obtained from the class methods.
 * 
 * @author Hang
 *
 */
public class HelpTopic {

	public static String HELP_RESOURCES_PATH = "/src/logic/help/";
	
	private int topicNumber = 0;
	private String topicName = "";
	private ArrayList<String> topicContents = new ArrayList<String> ();
	
	/**
	 * Constructs the HelpTopic Object of the specified topic number. Initializes
	 * the private attributes of topicNumber, topicName and the details. These
	 * attributes can be read using the getter functions.
	 * @param topicNumber The topic number of the HelpTopic to be constructed.
	 */
	public HelpTopic(int topicNumber) {
		setTopicNumber(topicNumber);
		String topicResource = getResourcePath(Integer.toString(topicNumber));
		ArrayList<String> details = readResource(topicResource);
		topicName = setTopicName(details);
		topicContents = setTopicContents(details);
	}

    private void setTopicNumber(int topic) {
		topicNumber = topic;
    }
	
	private String getResourcePath(String num) {
		String helpResourcePath = num + ".txt";
		return helpResourcePath;
	}
	
	/**
     * Reads the help content from the specified topicFile resource.
     * @param topicResource Name of the help resource to read from.
     * @return content The contents of the helpTopic read.
     */
    private ArrayList<String> readResource(String topicResource) {
        ArrayList<String> content = new ArrayList<String> ();
        InputStream is = this.getClass().getResourceAsStream(topicResource);
        if (is == null) {
            return content;
        }
        String textLine = "";
        try { 
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            textLine = reader.readLine();
            while (textLine != null) {
                content.add(textLine);
                textLine = reader.readLine();
            }
            reader.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
        return content;
    }
    
    private String setTopicName(ArrayList<String> details) {
        return details.get(0); 
    }
	
    private ArrayList<String> setTopicContents(ArrayList<String> details) {
        details.remove(0);
        return details;
    }
    
	// Getters and setters
	public int getTopicNumber() {
		return topicNumber;
	}
	
	public String getTopicName() {
		return topicName;
	}
	
	public ArrayList<String> getDetails() {
		return topicContents;
	}

}
```
###### \src\logic\save\saveTest.java
``` java

package logic.save;

import static org.junit.Assert.assertEquals;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.junit.After;
import org.junit.BeforeClass;
import org.junit.Test;

import logic.Logic;
import storage.Constants;

public class saveTest {

    static Path defaultSavePath = Paths.get(Constants.DEFAULT_DIRECTORY, Constants.FILENAME_DATA);
    static Path movedSavePath = Paths.get(Constants.DEFAULT_DIRECTORY, 
            Constants.ATF_DIRECTORY, Constants.FILENAME_DATA);
    
    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        deleteInfo();
    }

    @After
    public void tearDown() throws Exception {
        deleteInfo();
    }

    @Test
    public void testChangePreferedDirectory() throws FileNotFoundException, IOException {
        Logic logic = new Logic();
        String expectedDirectory = Paths.get(Constants.DEFAULT_DIRECTORY, 
                Constants.ATF_DIRECTORY).toString();
        logic.run("add task1");
        logic.run("save to " + expectedDirectory);
        logic.run("add task2");
        
        BufferedReader fileReader = new BufferedReader(
                new FileReader (Constants.FILEPATH_SAVEINFO.toString()));
        String actualDirectory = fileReader.readLine();
        fileReader.close();     
        File movedFile = new File(movedSavePath.toString());
        assertEquals(expectedDirectory, actualDirectory);
        assertEquals(true, movedFile.exists());
    }
    
    private static void deleteInfo() throws IOException {
        Files.deleteIfExists(defaultSavePath);
        Files.deleteIfExists(movedSavePath);
        Files.deleteIfExists(Constants.FILEPATH_SAVEINFO);
    }

}
```
###### \src\storage\Constants.java
``` java

package storage;

import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Constants used in the Storage Component.
 * @author Hang
 *
 */
public final class Constants {

    /**
     * The Default Directory is the working directory where the program is stored.
     */
    public static final String DEFAULT_DIRECTORY = ".";
    
    /**
     * ATF Directory is a directory created in the default directory to include all 
     * program files not involving task data created by the program.
     */
    public static final String ATF_DIRECTORY = "atf_files";
    
    /**
     * These constants define the default names of the data file and backup data file.
     */
    public static final String FILENAME_DATA = "data.txt";
    public static final String FILENAME_BACKUP_DATA = "atf_backup.json";
    public static final Path FILEPATH_BACKUP_DATA = Paths
            .get(DEFAULT_DIRECTORY, ATF_DIRECTORY , FILENAME_BACKUP_DATA);
    
    /**
     * These constants define the names and path of the file containing the user specified 
     * preferred save directory.
     */
    public static final String FILENAME_SAVEINFO = "saveInfo.txt";
    public static final Path FILEPATH_SAVEINFO = Paths.get(ATF_DIRECTORY, FILENAME_SAVEINFO);
    public static final Path FILEPATH_DEFAULT_SAVE = Paths
            .get(DEFAULT_DIRECTORY, ATF_DIRECTORY , FILENAME_SAVEINFO);
    
    /**
     * These constants define the log file and path of the log file used by the program.
     */
    public static final String FILENAME_LOG = "log.txt";
    public static final Path FILEPATH_LOGDIR = Paths.get(DEFAULT_DIRECTORY, ATF_DIRECTORY);
    public static final Path FILEPATH_LOGFILE = Paths.get(FILEPATH_LOGDIR.toString(), FILENAME_LOG);
    
    /**
     * These constants define the log messages used in storage.
     */
    static final String LOG_SAVED = "Tasks saved to: %s";
    static final String LOG_LOADED = "Tasks loaded from: %s";
    static final String LOG_MKDIR = "Directory created: %s";
    static final String LOG_CHANGE_PREFERED_DIR = "Directory changed to: %s";
    

    
    
    
}
```
###### \src\storage\FilePath.java
``` java

package storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.Logger;

import common.AtfLogger;

/**
 * The FilePath class manages the path for storing and retrieving tasks.
 * 
 * @author Hang
 *
 */
public class FilePath {

    /**
     * Changes the default directory location to store the data file to the provided path.
     * <p>
     * @param directory Location of new directory to contain data file for saved tasks.
     * @throws IOException Error saving new directory.
     */
    protected static void changePreferedDirectory(String directory) throws IOException {
        Logger logger = AtfLogger.getLogger();
        mkdirIfNotExist(directory);
        if (!directoryValid(directory)) {
            throw new InvalidPathException(directory, "Cannot be used");
        }
        writePreferredDirectory(directory);
        logger.info(String.format(Constants.LOG_CHANGE_PREFERED_DIR, directory));
    }

    /**
     * Returns the path of the file containing saved tasks. By default returns
     * the directory containing the program unless another directory has been defined.
     * <p>
     * @return String of path of the file containing saved tasks.
     * @throws InvalidPathException Specified preferred directory is invalid.
     * @throws IOException Error reading file containing default path.
     */
    protected static String getPath() throws InvalidPathException , IOException {
        String directory = readPreferedDirectory();
        if (!directoryValid(directory)) {
            throw new InvalidPathException(directory, "Cannot be used");
        }
        Path path = Paths.get(directory, Constants.FILENAME_DATA);
        return path.toString();
    }

    /**
     * Sets the save location to the default if the save location has not been specified. 
     * The location where the data files created by the program will be set 
     * to the working directory containing the program. If the save location has already
     * been specified, it will not be changed. 
     * @throws IOException Error creating the file containing the save location
     */
    protected static void initializeDefaultSave() throws IOException {
        if(!Files.exists(Constants.FILEPATH_DEFAULT_SAVE)) {
            changePreferedDirectory(Constants.DEFAULT_DIRECTORY);
        }
    }
    
    /**
     * Checks if the specified directory is usable for writing and reading data from.
     * @param directory
     * @return <li><code>true</code> If the directory can be used.
     * <li><code>false</code> If the specified directory cannot be used.
     */
    protected static boolean directoryValid(String directory)  {
        if (directory == null) {
            return false;
        }
        Path path = Paths.get(directory);
        if( !Files.isExecutable(path) || !Files.isWritable(path) || !Files.isReadable(path)) {
            return false;
        }
        return true;
    }

    protected static boolean pathValid(String filePath) {
        if (filePath == null) {
            return false;
        }
        Path path = Paths.get(filePath);
        return Files.isReadable(path) && Files.isWritable(path);
    }
    
    private static String readPreferedDirectory() throws FileNotFoundException, IOException  {
        BufferedReader fileReader = new BufferedReader(
                new FileReader (Constants.FILEPATH_SAVEINFO.toString()));
        String directory = fileReader.readLine();
        fileReader.close();
        return directory;
    }
    
    private static void mkdirIfNotExist(String directory) {
        Logger logger = AtfLogger.getLogger();
        File file = new File(directory);
        if (!file.exists()) {
            file.mkdirs();
            logger.info(String.format(Constants.LOG_MKDIR, directory));
        }
    }

    private static void writePreferredDirectory(String directory) throws IOException {
        FileWriter fileWriter = new FileWriter(Constants.FILEPATH_SAVEINFO.toString() , false);
        PrintWriter printWriter = new PrintWriter(fileWriter);
        printWriter.print(directory);
        printWriter.close();
    }
}
```
###### \src\storage\FileStorage.java
``` java

package storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import com.google.gson.JsonSyntaxException;

import common.TaskObject;

/**
 * Implementation of the APIs of the Storage component.
 * @author Hang
 *
 */
public class FileStorage implements IStorage {

    private static FileStorage instance = null;

    private FileStorage() {
    }

    public static FileStorage getInstance() {
        if (instance == null) {
            instance = new FileStorage();
        }
        return instance;
    }

    @Override
    public void save(ArrayList<TaskObject> newTaskList) 
            throws NoSuchFileException, IOException {
        overwriteSave(newTaskList);
        overwriteBackup(newTaskList);
    }

    @Override
    public ArrayList<TaskObject> load() 
            throws InvalidPathException, FileNotFoundException, IOException , JsonSyntaxException {
        String filePath = null;
        try {
            filePath = FilePath.getPath();
        } catch (FileNotFoundException e) {
            return new ArrayList<TaskObject>();
        } 
        ArrayList<TaskObject> taskList = load(filePath);
        return taskList;
    }
    
    @Override
    public ArrayList<TaskObject> load(String filePath) 
            throws InvalidPathException, FileNotFoundException, IOException, JsonSyntaxException{
        if (!FilePath.pathValid(filePath)) {
            throw new InvalidPathException(filePath, "Invalid Directory");
        }
        ArrayList<TaskObject> taskList = TaskData.readTasks(filePath);
        return taskList;
    }
    
    @Override
    public ArrayList<TaskObject> loadBackup() throws InvalidPathException, 
            JsonSyntaxException, FileNotFoundException, IOException {
        return load(Constants.FILEPATH_BACKUP_DATA.toString());
    }
    
    @Override
    public String createCopy(String directory , String fileName) 
            throws InvalidPathException ,IOException  {
        if (!FilePath.directoryValid(directory)) {
            throw new InvalidPathException(directory, "Invalid Directory");
        }
        ArrayList<TaskObject> taskList = load();
        return writeNewTxtFile(directory, fileName, taskList);
    }

    private String writeNewTxtFile(String directory, String fileName, ArrayList<TaskObject> taskList) 
            throws IOException {
        String filePath = Paths.get(directory, fileName).toString();
        File toSave = new File(filePath.concat(".txt"));
        String suffix = "(%d)";
        for (int i = 1; toSave.exists(); i++ ) {
            filePath = Paths.get(directory, fileName.concat(String.format(suffix, i)))
                    .toString();
            toSave = new File(filePath);
        }
        filePath = filePath.concat(".txt");
        TaskData.writeTasks(taskList, filePath);
        return filePath;
    }

    @Override
    public void changeSaveLocation (String directory) 
            throws InvalidPathException, IOException {
        if (!FilePath.directoryValid(directory)) {
            throw new InvalidPathException(directory, "Invalid Directory");
        }
        ArrayList<TaskObject> taskList = load();
        try {
            deleteExistingSave();
        } catch (FileNotFoundException e) {
            //No existing Saved File to delete
        } 
        FilePath.changePreferedDirectory(directory);
        save(taskList);
    }
    
    private void overwriteBackup(ArrayList<TaskObject> newTaskList) throws IOException {
        String filePath = Constants.FILEPATH_BACKUP_DATA.toString();
        TaskData.writeTasks(newTaskList, filePath);
    }

    private void overwriteSave(ArrayList<TaskObject> newTaskList) throws IOException, FileNotFoundException {
        String filePath = null;
        try {
        filePath = FilePath.getPath();
        } catch (FileNotFoundException e) {
            FilePath.initializeDefaultSave();
            filePath = FilePath.getPath();
        }
        if (filePath == null) { // defensive measure
            FilePath.initializeDefaultSave();
            filePath = FilePath.getPath();
        }
        TaskData.writeTasks(newTaskList, filePath);
    }
    
    private void deleteExistingSave() throws FileNotFoundException, IOException {
        String filePath = FilePath.getPath();
        Path path = Paths.get(filePath);
        Files.deleteIfExists(path);
    }
    
}
```
###### \src\storage\IStorage.java
``` java

package storage;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;

import com.google.gson.JsonSyntaxException;

import common.TaskObject;

/**
 * Interface Defining all the APIs for the storage component.
 * @author Hang
 *
 */
public interface IStorage {

    /**
     * Writes tasks to storage. Overwrites existing tasks stored in storage.
     * If no existing preferred save location is found, the preferred save location
     * will be set to the default save location. 
     * <p>
     * @param taskList - The list of tasksObjects to be written
     * @throws IOException Error with saving tasks to disks
     */
    void save(ArrayList<TaskObject> taskList) throws IOException;

    /**
     * Loads all saved tasks into storage from existing specified file. If no existing 
     * existing preferred save location is specified, returns an empty list.
     * @return List of TaskObjects. Empty list returned if no save location is specified.
     * @throws FileNotFoundException Unable to find file in specified save location.
     * @throws IOException Error reading from disk.
     * @throws JsonSyntaxException File not in correct format.
     */
    ArrayList<TaskObject> load() throws FileNotFoundException, IOException , JsonSyntaxException;
    
    /**
     * Creates a copy of the file with the specified file name containing all stored task 
     * information at the specified directory. If existing files exist at the specified path,
     * the file copy will be saved with a suffix. The file will not be saved with any extension.
     * <p>
     * The tasks stored in storage should first be updated using <code>load</code> or <code>save</code>
     * for the created copy to contain the most recent task information.
     * <p>
     * @param directory Path of directory to create the copy in
     * @param fileName Name of file to be created
     * @return The file path of the created file copy.
     * @throws IOException Error Copying Existing Files
     * @throws InvalidPathException  The path specified cannot be used
     */
    String createCopy(String directory, String fileName) throws InvalidPathException, IOException;

    /**
     * <p>
     * @param directory The new preferred directory to store the task data file.
     * @throws IOException Error writing to specified directory
     * @throws InvalidPathException The specified directory cannot be used
     */
    void changeSaveLocation(String directory) throws InvalidPathException, IOException;

    /**
     * Load from specified path.
     * 
     * @param filePath The filePath of the data file to be read.
     * @return The list of tasks read from the data file.
     * @throws InvalidPathException The specified path is invalid.
     * @throws IOException Error reading from file.
     * @throws FileNotFoundException No file found at the specified path.
     * @throws JsonSyntaxException Specified file is not in correct format.
     */
    ArrayList<TaskObject> load(String filePath)
            throws InvalidPathException, IOException, FileNotFoundException, JsonSyntaxException;
    
    /**
     * Load from backup file.
     * @return The list of tasks read from the backup file.
     * @throws InvalidPathException The specified path is invalid.
     * @throws IOException Error reading from file.
     * @throws FileNotFoundException No file found at the specified path.
     * @throws JsonSyntaxException Specified file is not in correct format.
     */
    ArrayList<TaskObject> loadBackup() throws InvalidPathException, JsonSyntaxException, 
            FileNotFoundException, IOException;
    
}
```
###### \src\storage\TaskData.java
``` java

package storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.InvalidPathException;
import java.util.ArrayList;
import java.util.logging.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;

import common.AtfLogger;
import common.TaskObject;


/**
 * TaskData contains methods for writing tasks onto disk and for loading tasks from disk.
 * Tasks stored on the disk will be represented in Json.
 * 
 * @author Hang
 */
public class TaskData {

    private static final String NEW_LINE = "\n";
    
    /**
     * Creates a file at the specified path containing details of the tasks to be stored.
     * If existing file at the specified path is present, it will be overwritten.
     * The taskObjects will serialized and stored as Json representation in the file.
     * <p>
     * @param taskList An <code>ArrayList</code> containing all the task objects to be
     * stored into the file.
     * @param filePath The file path of the file to be created.
     * @throws IOException Error writing to specified path.
     */
    protected static void writeTasks(ArrayList<TaskObject> taskList, String filePath) 
            throws IOException {
        if(filePath == null) {
            throw new InvalidPathException("Saving to invalid Path", filePath);
        }
        Logger logger = AtfLogger.getLogger();
        BufferedWriter writer = new BufferedWriter(new FileWriter(filePath, false));
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String json = gson.toJson(taskList);
        writer.write(json + NEW_LINE);
        writer.close();
        logger.info(String.format(Constants.LOG_SAVED, filePath));
    }
    
    /**
     * Reads from the file at the specified filePath and creates taskObjects 
     * by deserializing the tasks stored in the file.
     * The specified file must contains tasks serialized in Json format.
     * <p>
     * @param filePath The path of the file containing the stored tasks information.
     * @return An <code>ArrayList</code> containing all the task objects that are 
     * read from the file. 
     * @throws FileNotFoundException The specified file path does not exist.
     * @throws IOException Error reading from existing file.
     * @throws JsonSyntaxException Error converting file contents to task objects. 
     * The file does not contain tasks that are correctly represented in Json.
     */
    static ArrayList<TaskObject> readTasks(String filePath) 
            throws FileNotFoundException, IOException, JsonSyntaxException {
        if(filePath == null) {
            throw new FileNotFoundException("No file to read from");
        }
        Logger logger = AtfLogger.getLogger();
        ArrayList<TaskObject> taskList = new ArrayList<TaskObject>();
        BufferedReader fileReader = new BufferedReader (new FileReader(filePath));
        Type typeOfTaskList = new TypeToken<ArrayList<TaskObject>>(){}.getType();
        Gson gson = new Gson();
        taskList = gson.fromJson(fileReader, typeOfTaskList);
        fileReader.close();
        logger.info(String.format(Constants.LOG_LOADED, filePath));
        return taskList;
    }

}
```
###### \src\test\AssertHelper.java
``` java

package test;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import common.TaskObject;

/**
 * This class contains methods to help compare taskObjects.
 * @author Hang
 *
 */
public class AssertHelper {

    public static void assertTaskEquals(String testDescription, TaskObject task1, TaskObject task2) {
        assertEquals(testDescription + " title", task1.getTitle(), task2.getTitle());
        assertEquals(testDescription + " start dateTime", task1.getStartDateTime(), task2.getEndDateTime());
        assertEquals(testDescription + " end dateTime", task1.getEndDateTime(), task2.getEndDateTime());
        assertEquals(testDescription + " category", task1.getCategory(), task2.getCategory());
        assertEquals(testDescription + " Status", task1.getStatus(), task2.getStatus());
        assertEquals(testDescription + " taskId", task1.getTaskId(), task2.getTaskId());
    }
    
    public static void assertTaskListEquals(String testDescription, 
            ArrayList<TaskObject> expectedTaskList, ArrayList<TaskObject> actualTaskList) {
        assertEquals(testDescription + "listSize" , expectedTaskList.size(), actualTaskList.size());
        int size = expectedTaskList.size();
        for (int i = 0; i < size; i++) {
            assertTaskEquals( testDescription+ "dataListContent" , expectedTaskList.get(i) , actualTaskList.get(i));
        }
    }

    public static void assertArrayListEquals(String message, int size, ArrayList<String> expectedDataList, ArrayList<String> dataList) {
        assertEquals(message + "listSize" , expectedDataList.size(), dataList.size());
        for (int i = 0; i < size; i++) {
            assertEquals( message+ "dataListContent" , expectedDataList.get(i) , dataList.get(i));
        }
    }

    }
```
###### \src\test\storage\FilePathTest.java
``` java

package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import storage.Constants;

public class FilePathTest extends storage.FilePath {

    private static final String DATA_FILE_NAME = Constants.FILENAME_DATA;

    @Before
    public void setUp() throws IOException {
        Path path = Constants.FILEPATH_SAVEINFO;
        Path path2 = Paths.get(".", "bin" , "save");
        Files.deleteIfExists(path);
        Files.deleteIfExists(path2);
        
    }
    
    
    @After
    public void tearDown() throws IOException {
        Path path = Constants.FILEPATH_SAVEINFO;
        Path path2 = Paths.get(".", "bin" , "save");
        Files.deleteIfExists(path);
        Files.deleteIfExists(path2);
        
    }
    /**
     * This is a case to detect that there is no existing preferred directory settings
     * @throws FileNotFoundException
     * @throws IOException
     */
    @Test(expected = FileNotFoundException.class)
    public void testGetPathNoFile() throws FileNotFoundException, IOException {
        getPath();
    }
    
    /**
     * This is a case to check that the corrected preferred directory settings is 
     * read when the settings have been written to disk previously.
     * @throws NoSuchFileException
     * @throws IOException
     */
    @Test
    public void testGetPath() throws NoSuchFileException, IOException {
        String saveDir = Paths.get(".").toAbsolutePath().normalize().toString();
        writeSaveDir(saveDir);
        String actualFilePath = getPath();
        String expectedFilePath = Paths.get(saveDir, DATA_FILE_NAME).toString();
        assertEquals("Returned file Path", expectedFilePath , actualFilePath);
    }

    /**
     * Test case for checking that a valid folder can indeed be used by storage.
     */
    @Test
    public void testCheckValidFolder() {
        directoryValid(".");
    }

    /**
     * Test case for checking that an invalid folder is indeed not usable by storage.
     */
    public void testCheckInalidPath() {
        assertEquals(false, directoryValid("fail"));
    }
    
    /**
     * Test case to check that the change Directory command indeed changes the stored
     * settings on the file saved on disk.
     * @throws IOException
     */
    @Test
    public void testChangeDirectory() throws IOException {
        String saveDir = Paths.get(".").toAbsolutePath().normalize().toString();
        Path path = Paths.get(saveDir, "bin");
        Path expectedPath = Paths.get(saveDir, "bin" , DATA_FILE_NAME);
        changePreferedDirectory(path.toString());
        assertEquals( "Change Directory to bin" , expectedPath.toString() , getPath() );
    }
    
    /**
     * Test case to check that the change Directory command indeed changes the stored 
     * settings on the file saved on disk and can create the new directory if it does not
     * already exist.
     * @throws IOException
     */
    @Test
    public void testChangeNewDirectory() throws IOException {
        String saveDir = Paths.get(".").toAbsolutePath().normalize().toString();
        Path path = Paths.get(saveDir, "bin" , "save");
        Path expectedPath = Paths.get(saveDir, "bin"  , "save" , DATA_FILE_NAME);
        changePreferedDirectory(path.toString());
        assertEquals( "Change Directory to bin" , expectedPath.toString() , getPath() );
    }
        
    private void writeSaveDir(String directory) throws IOException {
        FileWriter fileWriter = new FileWriter(Constants.FILEPATH_SAVEINFO.toString() , false);
        PrintWriter printWriter = new PrintWriter(fileWriter);
        printWriter.print(directory.toString());
        printWriter.close();
    }


    
}


```
###### \src\test\storage\FileStorageTest.java
``` java

package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.google.gson.JsonSyntaxException;

import common.TaskObject;
import storage.Constants;
import storage.FileStorage;
import storage.IStorage;
import test.AssertHelper;
import test.TaskGenerator;

/**
 * @author Hang
 *
 */
public class FileStorageTest {

    
    public static ArrayList<TaskObject> taskList1 = new ArrayList<TaskObject>();
    public static ArrayList<TaskObject> taskList2 = new ArrayList<TaskObject>();
    public static String moveDir = Paths.get(Constants.ATF_DIRECTORY).toString();
    static Path defaultFilePath = Paths.get(Constants.DEFAULT_DIRECTORY, Constants.FILENAME_DATA);
    static Path copyFilePath = Paths.get(moveDir , "test.txt");
    static Path copyFilePath2 = Paths.get(moveDir , "test(1).txt");
    static Path moveFilePath = Paths.get(moveDir , Constants.FILENAME_DATA);
    
    
    IStorage storage = FileStorage.getInstance();
    
    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        TaskGenerator taskGen = new TaskGenerator();
        taskList1 = taskGen.getTaskList(5);
        taskList2 = taskGen.getTaskList(5);
        deleteInfo();
    }

    /**
     * @throws java.lang.Exception
     */
    @AfterClass
    public static void tearDownAfterClass() throws Exception {
        deleteInfo();
    }

    private static void deleteInfo() throws IOException {
        Files.deleteIfExists(defaultFilePath);
        Files.deleteIfExists(copyFilePath);
        Files.deleteIfExists(moveFilePath);
        Files.deleteIfExists(copyFilePath2);
        Files.deleteIfExists(Constants.FILEPATH_DEFAULT_SAVE);
    }

    /**
     * @throws java.lang.Exception
     */
    @Before
    public void setUp() throws Exception {
        storage = null;
    }

    /**
     * @throws java.lang.Exception
     */
    @After
    public void tearDown() throws Exception {
        //deleteInfo();
    }

    /**
     * Tests that files can be saved and read from storage.
     * @throws IOException
     */
    @Test
    public void testSaveLoad() throws IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        ArrayList<TaskObject> actualTaskList = storage.load();
        AssertHelper.assertTaskListEquals("SaveLoad" , taskList1 , actualTaskList);
    }
    
    /**
     * Tests that files can be saved and the saved files persists after storage is closed,
     * and that the files can still be read subsequently. 
     * @throws IOException
     */
    @Test
    public void testSaveLoadSeperate() throws IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        storage = null;
        storage = FileStorage.getInstance();
        ArrayList<TaskObject> actualTaskList = storage.load();
        AssertHelper.assertTaskListEquals("SaveLoad" , taskList1 , actualTaskList);
    }
    
    /**
     * Tests that files are updated by new saves and the updated list is read subsequently.
     * @throws IOException
     */
    @Test
    public void testOverWrite() throws IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        storage.save(taskList2);
        ArrayList<TaskObject> actualTaskList = storage.load();
        AssertHelper.assertTaskListEquals("SaveLoad" , taskList2 , actualTaskList);
    }
    /**
     * Tests that a copy can be created and read from a different location.
     * @throws IOException
     */
    @Test
    public void testCreateCopyLoadFrom() throws IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        storage.createCopy(moveDir, "test");
        String path = Paths.get(moveDir, "test.txt").toString();
        ArrayList<TaskObject> actualTaskList = storage.load(path);
        AssertHelper.assertTaskListEquals("CreateCopyLoadFrom" , taskList1 , actualTaskList);
    }
    
    @Test
    public void testCreateDuplicateCopyLoadFrom() throws IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        storage.createCopy(moveDir, "test");
        String savedPath = storage.createCopy(moveDir, "test");
        String path = Paths.get(moveDir, "test(1).txt").toString();
        ArrayList<TaskObject> actualTaskList = storage.load(path);
        assertEquals("Saved path", copyFilePath2.toString(), savedPath);
        AssertHelper.assertTaskListEquals("CreateCopyLoadFrom" , taskList1 , actualTaskList);
    }

    @Test (expected = InvalidPathException.class)
    public void testLoadFrom() throws InvalidPathException, JsonSyntaxException, FileNotFoundException, IOException {
        IStorage storage = FileStorage.getInstance();
        String path = Paths.get(Constants.DEFAULT_DIRECTORY, Constants.FILENAME_DATA).toString();
        storage.load(path);
    }
    
    /**
     * Tests that the preferred directory to save files can be changed and storage reads from the 
     * new preferred directory subsequently.
     * @throws InvalidPathException
     * @throws JsonSyntaxException
     * @throws FileNotFoundException
     * @throws IOException
     * @throws ExistingFileNotFoundException 
     */
    @Test
    public void testChangeSaveLocation() throws InvalidPathException, JsonSyntaxException, 
            FileNotFoundException, IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        ArrayList<TaskObject> actualTaskListOldSave = storage.load();
        storage.changeSaveLocation(moveDir);
        BufferedReader fileReader = new BufferedReader(
                new FileReader (Constants.FILEPATH_SAVEINFO.toString()));
        String actualDirectory = fileReader.readLine();
        fileReader.close();
        storage.save(taskList2);
        ArrayList<TaskObject> actualTaskListNewSave = storage.load();
        assertEquals("Save Dir", moveDir, actualDirectory);
        AssertHelper.assertTaskListEquals("CreateCopyLoadFromNew" , taskList2 , actualTaskListNewSave);
        AssertHelper.assertTaskListEquals("CreateCopyLoadFromOld" , taskList2 , actualTaskListOldSave);
    }
    
    @Test
    public void testChangeSaveLocationInitial() throws InvalidPathException, JsonSyntaxException, 
            FileNotFoundException, IOException {
        IStorage storage = FileStorage.getInstance();
        storage.changeSaveLocation(moveDir);
        BufferedReader fileReader = new BufferedReader(
                new FileReader (Constants.FILEPATH_SAVEINFO.toString()));
        String actualDirectory = fileReader.readLine();
        fileReader.close();
        storage.save(taskList1);
        ArrayList<TaskObject> actualTaskListNewSave = storage.load();
        assertEquals("Save Dir", moveDir, actualDirectory);
        AssertHelper.assertTaskListEquals("CreateCopyLoadFromNew" , taskList1 , actualTaskListNewSave);
    }
    
    /**
     * Tests that storage correctly identifies that a save location is invalid and throws an exception
     * when attempted to change the preferred directory to an invalid location.
     * @throws InvalidPathException
     * @throws JsonSyntaxException
     * @throws FileNotFoundException
     * @throws IOException
     * @throws ExistingFileNotFoundException 
     */
    @Test (expected = InvalidPathException.class)
    public void testChangeInvalidSaveLocation() throws InvalidPathException, 
            JsonSyntaxException, FileNotFoundException, IOException {
        IStorage storage = FileStorage.getInstance();
        storage.save(taskList1);
        storage.changeSaveLocation("Invalid");
    }


}
```
###### \src\test\storage\StorageTest.java
``` java

package test.storage;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;


/**
 * Runs all tests case written for the storage component.
 * 
 * FilePathTest contains unit tests covering the methods of the filePath class.
 * FileStorageTests consist of test cases covering the APIs of the storage component.
 * 
 * Refer to the respective source files for descriptions of the individual test cases.
 * 
 * @author Hang
 *
 */

@RunWith(Suite.class)
@SuiteClasses({
    FilePathTest.class,
    FileStorageTest.class,
})

public class StorageTest {}
```
###### \src\test\TaskGenerator.java
``` java

package test;

import java.util.ArrayList;

import common.TaskObject;

/**
 * This class helps to create a list of unique dummy tasks for testing.
 * @author Hang
 *
 */
public class TaskGenerator {
    public static Integer taskId = 0;

    public ArrayList<TaskObject> taskList = new ArrayList<TaskObject>();

    public TaskObject getTask() {
        taskId += 1;
        TaskObject task = new TaskObject("task" + taskId.toString());
        task.setTaskId(taskId);
        return task;
    }

    public ArrayList<TaskObject> getTaskList( int size) {
        taskList.clear();
        for (int i = 0; i < size; i++) {
            taskList.add(getTask());
        }
        return taskList;
    }

}
```
